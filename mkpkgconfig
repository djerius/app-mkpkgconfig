#! /usr/bin/env perl

# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;

$fatpacked{"Algorithm/Dependency.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ALGORITHM_DEPENDENCY';
  package Algorithm::Dependency;use 5.005;use strict;use Params::Util qw{_INSTANCE _ARRAY};use Algorithm::Dependency::Item ();use Algorithm::Dependency::Source ();our$VERSION='1.112';sub new {my$class=shift;my%args=@_;my$source=_INSTANCE($args{source},'Algorithm::Dependency::Source')or return undef;my$self=bless {source=>$source,selected=>{},},$class;if ($args{ignore_orphans}){$self->{ignore_orphans}=1}_ARRAY($args{selected})or return$self;my%selected=();for my$id (@{$args{selected}}){return undef unless$source->item($id);return undef if$selected{$id};$selected{$id}=1}$self->{selected}=\%selected;$self}sub source {$_[0]->{source}}sub selected_list {sort keys %{$_[0]->{selected}}}sub selected {$_[0]->{selected}->{$_[1]}}sub item {$_[0]->{source}->item($_[1])}sub depends {my$self=shift;my@stack=@_ or return undef;my@depends=();my%checked=();while (my$id=shift@stack){my$Item=$self->{source}->item($id)or $self->{ignore_orphans}? next : return undef;next if$checked{$id};push@stack,$Item->depends;$checked{$id}=1;unless (scalar grep {$id eq $_}@_){push@depends,$id}}my$s=$self->{selected};return [sort grep {!$s->{$_}}@depends ]}sub schedule {my$self=shift;my@items=@_ or return undef;my$depends=$self->depends(@items)or return undef;my$s=$self->{selected};return [sort grep {!$s->{$_}}@items,@$depends ]}sub schedule_all {my$self=shift;$self->schedule(map {$_->id}$self->source->items)}1;
ALGORITHM_DEPENDENCY

$fatpacked{"Algorithm/Dependency/Item.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ALGORITHM_DEPENDENCY_ITEM';
  package Algorithm::Dependency::Item;use 5.005;use strict;use Algorithm::Dependency ();our$VERSION='1.112';sub new {my$class=shift;my$id=(defined $_[0]and!ref $_[0]and $_[0]ne '')? shift : return undef;bless {id=>$id,depends=>[@_ ]},$class}sub id {$_[0]->{id}}sub depends {@{$_[0]->{depends}}}1;
ALGORITHM_DEPENDENCY_ITEM

$fatpacked{"Algorithm/Dependency/Ordered.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ALGORITHM_DEPENDENCY_ORDERED';
  package Algorithm::Dependency::Ordered;use 5.005;use strict;use Algorithm::Dependency ();our$VERSION='1.112';our@ISA='Algorithm::Dependency';sub schedule {my$self=shift;my$source=$self->{source};my@items=@_ or return undef;return undef if grep {!$source->item($_)}@items;my$rv=$self->SUPER::schedule(@items);my@queue=$rv ? @$rv : return undef;my%selected=%{$self->{selected}};my$error_marker='';my@schedule=();while (my$id=shift@queue){return undef if$id eq $error_marker;my$Item=$self->{source}->item($id)or return undef;my@missing=grep {!$selected{$_}}$Item->depends;if ($self->{ignore_orphans}){@missing=grep {$self->{source}->item($_)}@missing}if (@missing){$error_marker=$id unless$error_marker;push@queue,$id;next}push@schedule,$id;$selected{$id}=1;$error_marker=''}\@schedule}1;
ALGORITHM_DEPENDENCY_ORDERED

$fatpacked{"Algorithm/Dependency/Source.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ALGORITHM_DEPENDENCY_SOURCE';
  package Algorithm::Dependency::Source;use 5.005;use strict;use Algorithm::Dependency ();use Params::Util qw{_SET};our$VERSION='1.112';sub new {my$class=shift;if ($class eq __PACKAGE__){die "Cannot directly instantiate Algorithm::Dependency::Source." ." You must use a subclass"}my$self=bless {loaded=>0,items_hash=>undef,items_array=>undef,},$class;$self}sub load {my$self=shift;if ($self->{loaded}){$self->{loaded}=0;$self->{items_hash}=undef;$self->{items_array}=undef}my$items=$self->_load_item_list;return$items unless$items;unless (_SET($items,'Algorithm::Dependency::Item')){die(ref($self)."::_load_item_list did not return an Algorithm::Dependency::Item set")}for my$item (@$items){my$id=$item->id;if ($self->{items_hash}->{$id }){return undef}push @{$self->{items_array}},$item;$self->{items_hash}->{$id}=$item}$self->{loaded}=1}sub item {my$self=shift;my$id=(defined $_[0]and!ref $_[0]and $_[0]ne '')? shift : return undef;$self->{loaded}or $self->load or return undef;$self->{items_hash}->{$id}}sub items {my$self=shift;$self->{loaded}or $self->load or return undef;@{$self->{items_array}}}sub missing_dependencies {my$self=shift;$self->{loaded}or $self->load or return undef;my%missing=map {$_=>1}grep {!$self->item($_)}map {$_->depends}$self->items;%missing ? [sort keys%missing ]: 0}sub _load_item_list {die "Class $_[0] failed to define the method _load_item_list"}1;
ALGORITHM_DEPENDENCY_SOURCE

$fatpacked{"Algorithm/Dependency/Source/File.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ALGORITHM_DEPENDENCY_SOURCE_FILE';
  package Algorithm::Dependency::Source::File;use 5.005;use strict;use Algorithm::Dependency::Source ();our$VERSION='1.112';our@ISA='Algorithm::Dependency::Source';sub new {my$class=shift;my$filename=shift or return undef;return undef unless -r $filename;my$self=$class->SUPER::new()or return undef;$self->{filename}=$filename;$self}sub _load_item_list {my$self=shift;local $/=undef;open(FILE,$self->{filename})or return undef;defined(my$source=<FILE>)or return undef;close(FILE)or return undef;my@content=grep {!/^\s*(?:\#|$)/}split /\s*[\015\012][\s\015\012]*/,$source;my@Items=();for my$line (@content){my@sections=grep {length $_}split /\W+/,$line;return undef unless scalar@sections;my$Item=Algorithm::Dependency::Item->new(@sections)or return undef;push@Items,$Item}\@Items}1;
ALGORITHM_DEPENDENCY_SOURCE_FILE

$fatpacked{"Algorithm/Dependency/Source/HoA.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ALGORITHM_DEPENDENCY_SOURCE_HOA';
  package Algorithm::Dependency::Source::HoA;use 5.005;use strict;use Algorithm::Dependency::Source ();use Params::Util qw{_HASH _ARRAY0};our$VERSION='1.112';our@ISA='Algorithm::Dependency::Source';sub new {my$class=shift;my$hash=_HASH(shift)or return undef;for my$deps (values %$hash){_ARRAY0($deps)or return undef}my$self=$class->SUPER::new()or return undef;$self->{hash}=$hash;$self}sub _load_item_list {my$self=shift;my$hash=$self->{hash};my@items=map {Algorithm::Dependency::Item->new($_,@{$hash->{$_}})or return undef}keys %$hash;\@items}1;
ALGORITHM_DEPENDENCY_SOURCE_HOA

$fatpacked{"Algorithm/Dependency/Source/Invert.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ALGORITHM_DEPENDENCY_SOURCE_INVERT';
  package Algorithm::Dependency::Source::Invert;use 5.005;use strict;use Params::Util '_INSTANCE';use Algorithm::Dependency::Source::HoA ();our$VERSION='1.112';our@ISA='Algorithm::Dependency::Source::HoA';sub new {my$class=shift;my$source=_INSTANCE(shift,'Algorithm::Dependency::Source')or return undef;my@items=$source->items;my%hoa=map {$_->id=>[]}@items;for my$item (@items){my$id=$item->id;my@deps=$item->depends;for my$dep (@deps){push @{$hoa{$dep}},$id}}$class->SUPER::new(\%hoa)}1;
ALGORITHM_DEPENDENCY_SOURCE_INVERT

$fatpacked{"Algorithm/Dependency/Weight.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ALGORITHM_DEPENDENCY_WEIGHT';
  package Algorithm::Dependency::Weight;use 5.005;use strict;use List::Util ();use Algorithm::Dependency ();use Params::Util qw{_INSTANCE _STRING};our$VERSION='1.112';sub new {my$class=shift;my%args=@_;my$source=_INSTANCE($args{source},'Algorithm::Dependency')? $args{source}->source : _INSTANCE($args{source},'Algorithm::Dependency::Source')or return undef;my$algdep=Algorithm::Dependency->new(source=>$source,ignore_orphans=>1,)or return undef;my$self=bless {source=>$source,algdep=>$algdep,weight=>{},},$class;$self}sub source {$_[0]->{source}}sub weight {my$self=shift;my$id=defined(_STRING($_[0]))? shift : return undef;$self->{weight}->{$id}or $self->{weight}->{$id}=$self->_weight($id)}sub _weight {my$self=shift;my$items=$self->{algdep}->schedule($_[0])or return undef;scalar(@$items)}sub weight_merged {my$self=shift;my$items=$self->{algdep}->schedule(@_)or return undef;scalar(@$items)}sub weight_hash {my$self=shift;my@names=@_;my%hash=();for my$name (@names){if ($self->{weight}->{$name}){$hash{$name}=$self->{weight}->{$name};next}$hash{$name}=$self->weight($name)or return undef}\%hash}sub weight_all {my$self=shift;my@items=$self->source->items;defined$items[0]or return undef;$self->weight_hash(map {$_->id}@items)}1;
ALGORITHM_DEPENDENCY_WEIGHT

$fatpacked{"App/mkpkgconfig.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_MKPKGCONFIG';
  package App::mkpkgconfig;use strict;use warnings;our$VERSION='v2.0.1';1;
APP_MKPKGCONFIG

$fatpacked{"App/mkpkgconfig/PkgConfig.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_MKPKGCONFIG_PKGCONFIG';
  package App::mkpkgconfig::PkgConfig;use v5.10.0;use Regexp::Common 'balanced';use Moo;use App::mkpkgconfig::PkgConfig::Entry;use constant Keyword=>'App::mkpkgconfig::PkgConfig::Entry::Keyword';use constant Variable=>'App::mkpkgconfig::PkgConfig::Entry::Variable';our$VERSION='v2.0.1';use IO::File ();use IO::Handle ();sub croak {require Carp;goto&Carp::croak}use namespace::clean;has _keywords=>(is=>'ro',default=>sub {{}},init_args=>'keywords',);has _variables=>(is=>'ro',default=>sub {{}},init_args=>'variables',);sub new_from {my$class=shift;my$file=shift;open(my$fh,'<',$file)or croak ("unable to open $file\n");my$pkg=$class->new;while (defined($_=$fh->getline)){next if /^\s*#/;next if /^\s*$/;chomp;croak("unable to parse line: $_\n")unless /^[\s]*(?<name>[^\s:=]+)\s*(?<op>[:=])\s*(?<value>.*?)\s*(#.*)?$/;if ($+{op}eq ':'){$pkg->add_keyword($+{name}=>$+{value})}else {$pkg->add_variable($+{name}=>$+{value})}}close$fh or croak;return$pkg}sub variable {return $_[0]->_variables->{$_[1]}}sub variables {return values %{$_[0]->_variables}}sub keyword {return $_[0]->_keywords->{$_[1]}}sub keywords {return values %{$_[0]->_keywords}}sub add_variable {my ($self,$name,$value)=@_;croak ("attempt to set $name to an undefined value\n")unless defined$name;$self->_variables->{$name}=Variable->new($name,$value)}sub add_variables {my ($self,$variables)=@_;$self->add_variable($_,$variables->{$_})for keys %{$variables}}sub add_keyword {my ($self,$name,$value)=@_;croak ("attempt to set $name to an undefined value\n")unless defined$name;$self->_keywords->{$name}=Keyword->new($name,$value)}sub add_keywords {my ($self,$keywords)=@_;$self->add_keyword($_,$keywords->{$_})for keys %{$keywords}}sub write {my ($self,$file)=(shift,shift);my%options=(vars=>[],write=>'all',@_);my$fh =defined$file ? IO::File->new($file,'w'): IO::Handle->new_from_fd(fileno(STDOUT),'w')or croak("unable to create $file: $!\n");if ($options{comments}&& @{$options{comments}}){$fh->say("# $_")for @{$options{comments}};$fh->say()}my@entries=values %{$self->_keywords};if ($options{write}eq 'req'){if (defined$options{vars}){push@entries,$self->_variables->{$_}// croak("request for an undefined variable: $_\n")for @{$options{vars}}}}else {push@entries,values %{$self->_variables}}my@vars_needed=$self->resolve_dependencies(@entries);$fh->say("${_} = @{[ $self->_variables->{$_}->value ]}")foreach$self->order_variables(@vars_needed);$fh->say();$fh->say("${_}: @{[ $self->_keywords->{$_}->value ]}")foreach order_keywords(keys %{$self->_keywords});return}sub _entry_type {$_[0]->isa(Keyword)? "Keyword" : "Variable",}sub resolve_dependencies {my ($self,@entries)=@_;my%validated;use Hash::Ordered;for my$entry (@entries){my$track=Hash::Ordered->new;$track->push($entry->name,undef);my@depends=([$entry->depends ]);while (@depends){while (my$name=pop @{$depends[-1]}){next if$validated{$name};if ($track->exists($name)){croak(sprintf("%s '%s' has a circular dependency: %s\n",_entry_type($entry),$entry->name,join('->',$track->keys,$name)))}my$var=$self->_variables->{$name}// croak(sprintf("%s '%s' depends upon an undefined variable: %s\n",_entry_type($entry),$entry->name,join('->',$track->keys,$name,'undef'),));$track->push($name,undef);push@depends,[$var->depends ]}my ($name)=$track->pop;$validated{$name}=undef;pop@depends}delete$validated{$entry->name}if$entry->isa(Keyword)}return keys%validated}sub order_variables {my ($self,@needed)=@_;return ()unless@needed;@needed=do {my%uniqstr;@uniqstr{@needed}=();keys%uniqstr};my%dephash=map {$_=>[($self->_variables->{$_}// croak("unknown variable: $_\n"))->depends ]}@needed;require Algorithm::Dependency::Ordered;require Algorithm::Dependency::Source::HoA;my$ordered;eval {my$deps =Algorithm::Dependency::Ordered->new(source=>Algorithm::Dependency::Source::HoA->new(\%dephash))or die("error creating dependency object\n");$ordered=$deps->schedule(@needed);if (!defined$ordered){die("error in variable dependencies: perhaps there's cycle?\n"),}};if (length(my$err=$@)){require Data::Dumper;die($err,Data::Dumper->Dump([\%dephash,\@needed ],[qw(deps needed)]))}my@nodeps=sort grep {!@{$dephash{$_}}}@$ordered;if (@nodeps){my%nodeps;@nodeps{@nodeps}=();$ordered=[@nodeps,grep {!exists$nodeps{$_}}@$ordered ]}return @{$ordered}}sub order_keywords {my (@keywords)=@_;my%keywords;@keywords{@keywords }=();my@first_keys =grep {exists$keywords{$_}}qw(Name Description Version);my%last_keys;@last_keys{@keywords }=();delete@last_keys{@first_keys};return@first_keys,keys%last_keys}1;
APP_MKPKGCONFIG_PKGCONFIG

$fatpacked{"App/mkpkgconfig/PkgConfig/Entry.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_MKPKGCONFIG_PKGCONFIG_ENTRY';
  package App::mkpkgconfig::PkgConfig::Entry;use strict;use warnings;use Syntax::Construct qw(non-destructive-subst);our$VERSION='v2.0.1';use Regexp::Common 'balanced';sub new {my ($class,$name,$value)=@_;bless {name=>$name,value=>$value,depends=>_parse_dependencies($value),},$class}sub name {return $_[0]->{name}}sub value {return $_[0]->{value}}sub depends {return @{$_[0]->{depends}}}sub _parse_dependencies {my@depends=map {s/(?:^[{])|(?:[}]$)//gr}$_[0]=~ /(?<!\$)\$$RE{balanced}{-parens => '{}'}/g;my%depends;@depends{@depends}=();return [keys%depends ]}package App::mkpkgconfig::PkgConfig::Entry::Variable;use parent -norequire=>'App::mkpkgconfig::PkgConfig::Entry';package App::mkpkgconfig::PkgConfig::Entry::Keyword;use parent -norequire=>'App::mkpkgconfig::PkgConfig::Entry';1;
APP_MKPKGCONFIG_PKGCONFIG_ENTRY

$fatpacked{"B/Hooks/EndOfScope.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'B_HOOKS_ENDOFSCOPE';
  package B::Hooks::EndOfScope;use strict;use warnings;our$VERSION='0.24';use 5.006001;BEGIN {use Module::Implementation 0.05;Module::Implementation::build_loader_sub(implementations=>['XS','PP' ],symbols=>['on_scope_end' ],)->()}use Sub::Exporter::Progressive 0.001006 -setup=>{exports=>['on_scope_end' ],groups=>{default=>['on_scope_end']},};1;
B_HOOKS_ENDOFSCOPE

$fatpacked{"B/Hooks/EndOfScope/PP.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'B_HOOKS_ENDOFSCOPE_PP';
  package B::Hooks::EndOfScope::PP;use warnings;use strict;our$VERSION='0.24';use constant _PERL_VERSION=>"$]";BEGIN {if (_PERL_VERSION =~ /^5\.009/){die "By design B::Hooks::EndOfScope does not operate in pure-perl mode on perl 5.9.X\n"}elsif (_PERL_VERSION < '5.010'){require B::Hooks::EndOfScope::PP::HintHash;*on_scope_end=\&B::Hooks::EndOfScope::PP::HintHash::on_scope_end}else {require B::Hooks::EndOfScope::PP::FieldHash;*on_scope_end=\&B::Hooks::EndOfScope::PP::FieldHash::on_scope_end}}use Sub::Exporter::Progressive 0.001006 -setup=>{exports=>['on_scope_end'],groups=>{default=>['on_scope_end']},};sub __invoke_callback {local $@;eval {$_[0]->();1}or do {my$err=$@;require Carp;Carp::cluck((join ' ','A scope-end callback raised an exception, which can not be propagated when','B::Hooks::EndOfScope operates in pure-perl mode. Your program will CONTINUE','EXECUTION AS IF NOTHING HAPPENED AFTER THIS WARNING. Below is the complete','exception text, followed by a stack-trace of the callback execution:',)."\n\n$err\n\r");sleep 1 if -t *STDERR}}1;
B_HOOKS_ENDOFSCOPE_PP

$fatpacked{"B/Hooks/EndOfScope/PP/FieldHash.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'B_HOOKS_ENDOFSCOPE_PP_FIELDHASH';
  package B::Hooks::EndOfScope::PP::FieldHash;use strict;use warnings;our$VERSION='0.24';use Tie::Hash ();use Hash::Util::FieldHash 'fieldhash';fieldhash my%hh;{package B::Hooks::EndOfScope::PP::_TieHintHashFieldHash;our@ISA=('Tie::StdHash');sub DELETE {my$ret=shift->SUPER::DELETE(@_);B::Hooks::EndOfScope::PP::__invoke_callback($_)for @$ret;$ret}}sub on_scope_end (&) {$^H |= 0x020000;tie(%hh,'B::Hooks::EndOfScope::PP::_TieHintHashFieldHash')unless tied%hh;push @{$hh{\%^H}||= []},$_[0]}1;
B_HOOKS_ENDOFSCOPE_PP_FIELDHASH

$fatpacked{"B/Hooks/EndOfScope/PP/HintHash.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'B_HOOKS_ENDOFSCOPE_PP_HINTHASH';
  package B::Hooks::EndOfScope::PP::HintHash;use strict;use warnings;our$VERSION='0.24';use Scalar::Util ();use constant _NEEDS_MEMORY_CORRUPTION_FIXUP=>("$]" >= 5.008 and "$]" < 5.008004)? 1 : 0;use constant _PERL_VERSION=>"$]";sub on_scope_end (&) {$^H |= 0x020000 if _PERL_VERSION >= 5.008;local %^H=%^H if _PERL_VERSION < 5.008;bless \%^H,'B::Hooks::EndOfScope::PP::HintHash::__GraveyardTransport' if (_NEEDS_MEMORY_CORRUPTION_FIXUP and ref \%^H eq 'HASH');push @{$^H{sprintf '__B_H_EOS__guardstack_0X%x',Scalar::Util::refaddr(\%^H)}||= bless ([],'B::Hooks::EndOfScope::PP::_SG_STACK')},$_[0]}sub B::Hooks::EndOfScope::PP::_SG_STACK::DESTROY {B::Hooks::EndOfScope::PP::__invoke_callback($_)for @{$_[0]}}{my@Hint_Hash_Graveyard;push@Hint_Hash_Graveyard,\@Hint_Hash_Graveyard if _NEEDS_MEMORY_CORRUPTION_FIXUP;sub B::Hooks::EndOfScope::PP::HintHash::__GraveyardTransport::DESTROY {push@Hint_Hash_Graveyard,$_[0];bless $_[0],'B::Hooks::EndOfScope::PP::HintHash::__DeactivateGraveyardTransport';%{$_[0]}=()}}1;
B_HOOKS_ENDOFSCOPE_PP_HINTHASH

$fatpacked{"B/Hooks/EndOfScope/XS.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'B_HOOKS_ENDOFSCOPE_XS';
  package B::Hooks::EndOfScope::XS;use strict;use warnings;our$VERSION='0.24';use 5.008004;use Variable::Magic 0.48 ();use Sub::Exporter::Progressive 0.001006 -setup=>{exports=>['on_scope_end'],groups=>{default=>['on_scope_end']},};my$wiz=Variable::Magic::wizard data=>sub {[$_[1]]},free=>sub {$_->()for @{$_[1]};()},local=>\undef ;sub on_scope_end (&) {$^H |= 0x020000;if (my$stack=Variable::Magic::getdata %^H,$wiz){push @{$stack},$_[0]}else {Variable::Magic::cast %^H,$wiz,$_[0]}}1;
B_HOOKS_ENDOFSCOPE_XS

$fatpacked{"Class/Method/Modifiers.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CLASS_METHOD_MODIFIERS';
  use strict;use warnings;package Class::Method::Modifiers;our$VERSION='2.13';use base 'Exporter';our@EXPORT=qw(before after around);our@EXPORT_OK=(@EXPORT,qw(fresh install_modifier));our%EXPORT_TAGS=(moose=>[qw(before after around)],all=>\@EXPORT_OK,);BEGIN {*_HAS_READONLY=$] >= 5.008 ? sub(){1}: sub(){0}}our%MODIFIER_CACHE;sub _install_modifier;*_install_modifier=\&install_modifier;sub install_modifier {my$into=shift;my$type=shift;my$code=pop;my@names=@_;@names=@{$names[0]}if ref($names[0])eq 'ARRAY';return _fresh($into,$code,@names)if$type eq 'fresh';for my$name (@names){my$hit=$into->can($name)or do {require Carp;Carp::confess("The method '$name' is not found in the inheritance hierarchy for class $into")};my$qualified=$into.'::'.$name;my$cache=$MODIFIER_CACHE{$into}{$name}||= {before=>[],after=>[],around=>[],};if (!exists($cache->{"orig"})){no strict 'refs';$cache->{"orig"}=*{$qualified}{CODE};$cache->{"wrapped"}=$cache->{"orig"}|| $hit}if ($type eq 'after'){push @{$cache->{$type}},$code}else {unshift @{$cache->{$type}},$code}if ($type eq 'around'){my$method=$cache->{wrapped};my$attrs=_sub_attrs($code);$cache->{wrapped}=eval "package $into; +sub $attrs { \$code->(\$method, \@_); };"}if (@{$cache->{$type}}==1){my$before=$cache->{"before"};my$after=$cache->{"after"};my$wrapped=\$cache->{"wrapped"};my$attrs=_sub_attrs($cache->{wrapped});my$generated="package $into;\n";$generated .= "sub $name $attrs {";if (@$before){$generated .= '
                      for my $method (@$before) {
                          $method->(@_);
                      }
                  '}if (@$after){$generated .= '
                      my $ret;
                      if (wantarray) {
                          $ret = [$$wrapped->(@_)];
                          '.(_HAS_READONLY ? 'Internals::SvREADONLY(@$ret, 1);' : '').'
                      }
                      elsif (defined wantarray) {
                          $ret = \($$wrapped->(@_));
                      }
                      else {
                          $$wrapped->(@_);
                      }
  
                      for my $method (@$after) {
                          $method->(@_);
                      }
  
                      wantarray ? @$ret : $ret ? $$ret : ();
                  '}else {$generated .= '$$wrapped->(@_);'}$generated .= '}';no strict 'refs';no warnings 'redefine';no warnings 'closure';eval$generated}}}sub before {_install_modifier(scalar(caller),'before',@_)}sub after {_install_modifier(scalar(caller),'after',@_)}sub around {_install_modifier(scalar(caller),'around',@_)}sub fresh {my$code=pop;my@names=@_;@names=@{$names[0]}if ref($names[0])eq 'ARRAY';_fresh(scalar(caller),$code,@names)}sub _fresh {my ($into,$code,@names)=@_;for my$name (@names){if ($name !~ /\A [a-zA-Z_] [a-zA-Z0-9_]* \z/xms){require Carp;Carp::confess("Invalid method name '$name'")}if ($into->can($name)){require Carp;Carp::confess("Class $into already has a method named '$name'")}if (_is_in_package($code,$into)){no strict 'refs';*{"$into\::$name"}=$code}else {no warnings 'closure';my$attrs=_sub_attrs($code);eval "package $into; sub $name $attrs { \$code->(\@_) }"}}}sub _sub_attrs {my ($coderef)=@_;local*_sub=$coderef;local $@;(eval 'return 1; &_sub = 1')? ':lvalue' : ''}sub _is_in_package {my ($coderef,$package)=@_;require B;my$cv=B::svref_2object($coderef);return$cv->GV->STASH->NAME eq $package}1;
CLASS_METHOD_MODIFIERS

$fatpacked{"Data/OptList.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DATA_OPTLIST';
  use strict;use warnings;package Data::OptList;$Data::OptList::VERSION='0.110';use List::Util ();use Params::Util ();use Sub::Install 0.921 ();my%test_for;BEGIN {%test_for=(CODE=>\&Params::Util::_CODELIKE,HASH=>\&Params::Util::_HASHLIKE,ARRAY=>\&Params::Util::_ARRAYLIKE,SCALAR=>\&Params::Util::_SCALAR0,)}sub mkopt {my ($opt_list)=shift;my ($moniker,$require_unique,$must_be);my ($name_test,$is_a);if (@_){if (@_==1 and Params::Util::_HASHLIKE($_[0])){($moniker,$require_unique,$must_be,$name_test)=@{$_[0]}{qw(moniker require_unique must_be name_test) }}else {($moniker,$require_unique,$must_be)=@_}if (defined$must_be){$must_be=[$must_be ]unless ref$must_be;my@checks=map {my$class=$_;$test_for{$_}|| sub {$_[1]=$class;goto \&Params::Util::_INSTANCE}}@$must_be;$is_a=(@checks==1)? $checks[0]: sub {my$value=$_[0];List::Util::first {defined($_->($value))}@checks};$moniker='unnamed' unless defined$moniker}}return []unless$opt_list;$name_test ||= sub {!ref $_[0]};$opt_list=[map {$_=>(ref$opt_list->{$_}? $opt_list->{$_}: ())}keys %$opt_list ]if ref$opt_list eq 'HASH';my@return;my%seen;for (my$i=0;$i < @$opt_list;$i++){my$name=$opt_list->[$i];if ($require_unique){Carp::croak "multiple definitions provided for $name" if$seen{$name}++}my$value;if ($i < $#$opt_list){if (not defined$opt_list->[$i+1]){$i++}elsif (!$name_test->($opt_list->[$i+1])){$value=$opt_list->[++$i];if ($is_a &&!$is_a->($value)){my$ref=ref$value;Carp::croak "$ref-ref values are not valid in $moniker opt list"}}}push@return,[$name=>$value ]}return \@return}sub mkopt_hash {my ($opt_list,$moniker,$must_be)=@_;return {}unless$opt_list;$opt_list=mkopt($opt_list,$moniker,1,$must_be);my%hash=map {$_->[0]=>$_->[1]}@$opt_list;return \%hash}BEGIN {*import=Sub::Install::exporter {exports=>[qw(mkopt mkopt_hash)],}}1;
DATA_OPTLIST

$fatpacked{"Devel/GlobalDestruction.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DEVEL_GLOBALDESTRUCTION';
  package Devel::GlobalDestruction;use strict;use warnings;our$VERSION='0.14';use Sub::Exporter::Progressive -setup=>{exports=>[qw(in_global_destruction) ],groups=>{default=>[-all ]},};if (defined ${^GLOBAL_PHASE}){eval 'sub in_global_destruction () { ${^GLOBAL_PHASE} eq q[DESTRUCT] }; 1' or die $@}elsif (eval {require Devel::GlobalDestruction::XS;no warnings 'once';*in_global_destruction=\&Devel::GlobalDestruction::XS::in_global_destruction;1}){}else {require B;eval 'sub in_global_destruction () { ${B::main_cv()} == 0 }; 1' or die $@}1;
DEVEL_GLOBALDESTRUCTION

$fatpacked{"Getopt/Long/Descriptive.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'GETOPT_LONG_DESCRIPTIVE';
  use strict;use warnings;package Getopt::Long::Descriptive;$Getopt::Long::Descriptive::VERSION='0.105';use Carp qw(carp croak);use File::Basename ();use Getopt::Long 2.33;use List::Util qw(first);use Params::Validate 0.97 qw(:all);use Scalar::Util ();use Getopt::Long::Descriptive::Opts;use Getopt::Long::Descriptive::Usage;my$prog_name;sub prog_name {@_ ? ($prog_name=shift): $prog_name}BEGIN {prog_name(File::Basename::basename($0))}use Sub::Exporter::Util ();use Sub::Exporter 0.972 -setup=>{exports=>[describe_options=>\'_build_describe_options',q(prog_name),@{$Params::Validate::EXPORT_TAGS{types}}],groups=>[default=>[qw(describe_options) ],types=>$Params::Validate::EXPORT_TAGS{types},],};my%CONSTRAINT=(implies=>\&_mk_implies,required=>{optional=>0 },only_one=>\&_mk_only_one,);our$MungeOptions=1;sub _nohidden {return grep {!$_->{constraint}->{hidden}}@_}sub _expand {my@expanded;for my$opt (@_){push@expanded,{spec=>$opt->[0]|| '',desc=>@$opt > 1 ? $opt->[1]: 'spacer',constraint=>$opt->[2]|| {},name=>@$opt ? _munge((split /[:=|!+]/,$opt->[0]|| '')[0]): '',}}return@expanded}my%HIDDEN=(hidden=>1,);my$SPEC_RE=qr{(?:[:=][0-9\w\+]+[%@]?(\{[0-9]*,[0-9]*\})?|[!+])$};sub _strip_assignment {my ($self,$str)=@_;(my$copy=$str)=~ s{$SPEC_RE}{};if (wantarray){my$len=length$copy;my$assignment=substr$str,$len;if (!defined($assignment)){$assignment=''}return ($copy,$assignment)}return$copy}sub describe_options {my$sub=__PACKAGE__->_build_describe_options(describe_options=>{}=>{});$sub->(@_)}sub usage_class {'Getopt::Long::Descriptive::Usage'}sub _build_describe_options {my ($class)=@_;sub {my$format=shift;my$arg=(ref $_[-1]and ref $_[-1]eq 'HASH')? pop @_ : {};my@opts;my%parent_of;my%method_map;for my$opt (_expand(@_)){$method_map{$opt->{name}}=undef unless$opt->{desc}eq 'spacer';if (ref($opt->{desc})eq 'ARRAY'){$opt->{constraint}->{one_of}=delete$opt->{desc};$opt->{desc}='hidden'}if ($HIDDEN{$opt->{desc}}){$opt->{constraint}->{hidden}++}if ($opt->{constraint}->{one_of}){for my$one_opt (_expand(@{delete$opt->{constraint}->{one_of}})){$parent_of{$one_opt->{name}}=$opt->{name};$one_opt->{constraint}->{implies}->{$opt->{name}}=$one_opt->{name};for my$wipe (qw(required default)){if ($one_opt->{constraint}->{$wipe}){carp "'$wipe' constraint does not make sense in sub-option";delete$one_opt->{constraint}->{$wipe}}}$one_opt->{constraint}->{one_of}=$opt->{name};push@opts,$one_opt;$method_map{$one_opt->{name}}=undef unless$one_opt->{desc}eq 'spacer'}}if ($opt->{constraint}{shortcircuit}&& exists$opt->{constraint}{default}){carp('option "' .$opt->{name}.q[": 'default' does not make sense for shortcircuit options])}push@opts,$opt}my@go_conf=@{$arg->{getopt_conf}|| $arg->{getopt}|| []};if ($arg->{getopt}){warn "describe_options: 'getopt' is deprecated, please use 'getopt_conf' instead\n"}push@go_conf,"bundling" unless grep {/bundling/i}@go_conf;push@go_conf,"no_auto_help" unless grep {/no_auto_help/i}@go_conf;push@go_conf,"no_ignore_case" unless grep {/no_ignore_case/i}@go_conf;my@getopt_specs=map {$_->{spec}}grep {$_->{desc}ne 'spacer'}@opts;my@specs=map {$_->{spec}}grep {$_->{desc}ne 'spacer'}_nohidden(@opts);my$short=join q{},sort {lc$a cmp lc$b or $a cmp $b}grep {/^.$/}map {split /\|/}map {scalar __PACKAGE__->_strip_assignment($_)}@specs;my$long=grep /\b[^|]{2,}/,@specs;my%replace=("%"=>"%","c"=>prog_name,"o"=>join(q{ },($short ? "[-$short]" : ()),($long ? "[long options...]" : ())),);(my$str=$format)=~ s<%(.)><
        defined $replace{$1}
        ? $replace{$1}
        : Carp::croak("unknown sequence %$1 in first argument to describe_options")
      >ge;$str =~ s/[\x20\t]{2,}/ /g;my$usage=$class->usage_class->new({options=>[_nohidden(@opts)],leader_text=>$str,show_defaults=>$arg->{show_defaults},});Getopt::Long::Configure(@go_conf);my%return;$usage->die unless GetOptions(\%return,grep {length}@getopt_specs);my@given_keys=keys%return;for my$opt (keys%return){my$newopt=_munge($opt);next if$newopt eq $opt;$return{$newopt}=delete$return{$opt}}for my$copt (sort {($b->{constraint}{shortcircuit}|| 0)<=> ($a->{constraint}{shortcircuit}|| 0)}grep {$_->{constraint}}@opts){delete$copt->{constraint}->{hidden};my$is_shortcircuit=delete$copt->{constraint}{shortcircuit};my$name=$copt->{name};my$new=_validate_with(name=>$name,params=>\%return,spec=>$copt->{constraint},opts=>\@opts,usage=>$usage,given_keys=>\@given_keys,parent_of=>\%parent_of,);next unless (defined($new)|| exists($return{$name}));$return{$name}=$new;if ($is_shortcircuit){%return=($name=>$return{$name});last}}my$opt_obj=Getopt::Long::Descriptive::Opts->___new_opt_obj({values=>{%method_map,%return },given=>{map {;$_=>1}@given_keys },});return($opt_obj,$usage)}}sub _munge {my ($opt)=@_;return$opt unless$MungeOptions;$opt=lc($opt);$opt =~ tr/-/_/;return$opt}sub _validate_with {my (%arg)=validate(@_,{name=>1,params=>1,spec=>1,opts=>1,usage=>1,given_keys=>1,parent_of=>1,});my$spec=$arg{spec};my%pvspec;for my$ct (keys %{$spec}){if ($CONSTRAINT{$ct}and ref$CONSTRAINT{$ct}eq 'CODE'){$pvspec{callbacks}||= {};$pvspec{callbacks}={%{$pvspec{callbacks}},$CONSTRAINT{$ct}->($arg{name},$spec->{$ct},$arg{params},$arg{opts},),}}else {%pvspec=(%pvspec,$CONSTRAINT{$ct}? %{$CONSTRAINT{$ct}}: ($ct=>$spec->{$ct}),)}}$pvspec{optional}=1 unless exists$pvspec{optional};if (!defined($arg{params}{$arg{name}})&& $pvspec{default}&& $spec->{implies}){$arg{params}{$arg{name}}=delete$pvspec{default}}my%p;my$ok=eval {%p=validate_with(params=>[%{$arg{params}},'-given_keys',$arg{given_keys},'-parent_of',$arg{parent_of},],spec=>{$arg{name}=>\%pvspec },allow_extra=>1,on_fail=>sub {my$fail_msg=shift;Getopt::Long::Descriptive::_PV_Error->throw($fail_msg)},);1};if (!$ok){my$error=$@;if (Scalar::Util::blessed($error)&& $error->isa('Getopt::Long::Descriptive::_PV_Error')){$arg{usage}->die({pre_text=>$error->error ."\n" })}die $@}return$p{$arg{name}}}sub _norm_imply {my ($what)=@_;return {$what=>1 }unless my$ref=ref$what;return$what if$ref eq 'HASH';return {map {$_=>1}@$what }if$ref eq 'ARRAY';die "can't imply: $what"}sub _mk_implies {my$name=shift;my$what=_norm_imply(shift);my$param=shift;my$opts=shift;for my$implied (keys %$what){die("option specification for $name implies nonexistent option $implied\n")unless first {$_->{name}eq $implied}@$opts}my$whatstr=join(q{, },map {"$_=$what->{$_}"}keys %$what);return "$name implies $whatstr"=>sub {my ($pv_val,$rest)=@_;return 1 unless defined$pv_val;while (my ($key,$val)=each %$what){my$parent=$rest->{'-parent_of'}{$name};my@siblings=$parent ? (grep {;defined$rest->{'-parent_of'}{$_}&& $rest->{'-parent_of'}{$_}eq $parent}@{$rest->{'-given_keys'}}): ();if (@siblings > 1){die "these options conflict; each wants to set the $parent: @siblings\n"}if (exists$param->{$key}and $param->{$key}ne $val and grep {;$_ eq $key}@{$rest->{'-given_keys'}}){die("option specification for $name implies that $key should be " ."set to '$val', but it is '$param->{$key}' already\n")}$param->{$key}=$val}return 1}}sub _mk_only_one {die "unimplemented"}{package Getopt::Long::Descriptive::_PV_Error;sub error {$_[0]->{error}}sub throw {my ($class,$error_msg)=@_;my$self={error=>$error_msg };bless$self,$class;die$self}}1;
GETOPT_LONG_DESCRIPTIVE

$fatpacked{"Getopt/Long/Descriptive/Opts.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'GETOPT_LONG_DESCRIPTIVE_OPTS';
  use strict;use warnings;package Getopt::Long::Descriptive::Opts;$Getopt::Long::Descriptive::Opts::VERSION='0.105';use Scalar::Util qw(blessed weaken);my%_CREATED_OPTS;my$SERIAL_NUMBER=1;sub _specified {my ($self,$name)=@_;my$meta=$_CREATED_OPTS{blessed$self }{meta};return$meta->{given}{$name }}sub _specified_opts {my ($self)=@_;my$class=blessed$self;my$meta=$_CREATED_OPTS{$class }{meta};return$meta->{specified_opts}if$meta->{specified_opts};my@keys=grep {$meta->{given}{$_ }}(keys %{$meta->{given}});my%opts;@opts{@keys }=@$self{@keys };$meta->{specified_opts}=\%opts;bless$meta->{specified_opts}=>$class;weaken$meta->{specified_opts};$meta->{specified_opts}}sub _complete_opts {my ($self)=@_;my$class=blessed$self;my$meta=$_CREATED_OPTS{$class }{meta};return$meta->{complete_opts}}sub ___class_for_opt {my ($class,$arg)=@_;my$values=$arg->{values};my@bad=grep {$_ !~ /^[a-z_]\w*$/}keys %$values;Carp::confess("perverse option names given: @bad")if@bad;my$new_class="$class\::__OPT__::" .$SERIAL_NUMBER++;$_CREATED_OPTS{$new_class }={meta=>$arg };{no strict 'refs';${"$new_class\::VERSION"}=$class->VERSION;*{"$new_class\::ISA"}=['Getopt::Long::Descriptive::Opts' ];for my$opt (keys %$values){*{"$new_class\::$opt"}=sub {$_[0]->{$opt }}}}return$new_class}sub ___new_opt_obj {my ($class,$arg)=@_;my$copy={%{$arg->{values}}};my$new_class=$class->___class_for_opt($arg);delete$copy->{$_}for grep {!defined$copy->{$_}}keys %$copy;my$self=bless$copy=>$new_class;$_CREATED_OPTS{$new_class }{meta}{complete_opts}=$self;return$self}1;
GETOPT_LONG_DESCRIPTIVE_OPTS

$fatpacked{"Getopt/Long/Descriptive/Usage.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'GETOPT_LONG_DESCRIPTIVE_USAGE';
  use strict;use warnings;package Getopt::Long::Descriptive::Usage;$Getopt::Long::Descriptive::Usage::VERSION='0.105';use List::Util qw(max);sub new {my ($class,$arg)=@_;my@to_copy=qw(leader_text options show_defaults);my%copy;@copy{@to_copy }=@$arg{@to_copy };bless \%copy=>$class}sub text {my ($self)=@_;return join qq{\n},$self->leader_text,$self->option_text}sub leader_text {$_[0]->{leader_text}}sub option_text {my ($self)=@_;my@options=@{$self->{options}|| []};my$string=q{};my@specs=map {$_->{spec}}grep {$_->{desc}ne 'spacer'}@options;my$length=(max(map {_option_length($_)}@specs)|| 0);my$spec_fmt="\t%-${length}s";while (@options){my$opt=shift@options;my$spec=$opt->{spec};my$desc=$opt->{desc};my$assign;if ($desc eq 'spacer'){if (ref$opt->{spec}){$string .= "${ $opt->{spec} }\n";next}else {my@lines=$self->_split_description($length,$opt->{spec});$string .= length($_)? sprintf("$spec_fmt\n",$_): "\n" for@lines;next}}($spec,$assign)=Getopt::Long::Descriptive->_strip_assignment($spec);my ($left,$right)=_parse_assignment($assign);$spec=join q{ },reverse map {length > 1 ? "--$left$_$right" : "-${_}$right"}split /\|/,$spec;my@desc=$self->_split_description($length,$desc);if (exists$opt->{constraint}->{default}and $self->{show_defaults}){my$dflt=$opt->{constraint}->{default};$dflt=!defined$dflt ? '(undef)' :!length$dflt ? '(empty string)' : $dflt;push@desc,"(default value: $dflt)"}$string .= sprintf "$spec_fmt  %s\n",$spec,shift@desc;for my$line (@desc){$string .= "\t";$string .= q{ } x ($length + 2);$string .= "$line\n"}}return$string}sub _option_length {my ($fullspec)=@_;my$number_opts=1;my$last_pos=0;my$number_shortopts=0;my ($spec,$argspec)=Getopt::Long::Descriptive->_strip_assignment($fullspec);my$length=length$spec;my ($left,$right)=_parse_assignment($argspec);my$arglen=length($left)+ length($right);while ($spec =~ m{\|}g){$number_opts++;if (pos($spec)- $last_pos==2){$number_shortopts++}$last_pos=pos($spec)}if ($length - $last_pos==1){$number_shortopts++}my$number_longopts=$number_opts - $number_shortopts;my$total_arglen=$number_opts * $arglen;my$total_optsep=2 * $number_longopts + $number_shortopts;my$total=$length + $total_optsep + $total_arglen;return$total}sub _split_description {my ($self,$length,$desc)=@_;my$max_length=78 - ($length + 8 + 2);return$desc if length$desc <= $max_length;my@lines;while (length$desc > $max_length){my$idx=rindex(substr($desc,0,$max_length),q{ },);last unless$idx >= 0;push@lines,substr($desc,0,$idx);substr($desc,0,$idx + 1)=q{}}push@lines,$desc;return@lines}sub _parse_assignment {my ($assign_spec)=@_;my$result='STR';my$desttype;if (length($assign_spec)< 2){return ('[no-]','')if$assign_spec eq '!';return ('','')}my$optional=substr($assign_spec,0,1)eq ':';my$argument=substr$assign_spec,1,2;if ($argument =~ m/^[io]/ or $assign_spec =~ m/^:[+0-9]/){$result='INT'}elsif ($argument =~ m/^f/){$result='NUM'}if (length($assign_spec)> 2){$desttype=substr($assign_spec,2,1);if ($desttype eq '@'){$result .= '...'}elsif ($desttype eq '%'){$result="KEY=${result}..."}}if ($optional){return ("","[=$result]")}return (""," $result")}sub warn {warn shift->text}sub die {my$self=shift;my$arg=shift || {};die(join q{},grep {defined}$arg->{pre_text},$self->text,$arg->{post_text})}use overload (q{""}=>"text",'&{}'=>sub {my ($self)=@_;Carp::cluck("use of __PACKAGE__ objects as a code ref is deprecated");return sub {return $_[0]? $self->text : $self->warn}});1;
GETOPT_LONG_DESCRIPTIVE_USAGE

$fatpacked{"Hash/Ordered.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'HASH_ORDERED';
  use 5.006;use strict;use warnings;package Hash::Ordered;our$VERSION='0.014';use Carp ();use constant {_DATA=>0,_KEYS=>1,_INDX=>2,_OFFS=>3,_GCNT=>4,_ITER=>5,};use constant {_INDEX_THRESHOLD=>25,_TOMBSTONE=>\1,};BEGIN {if ($] gt '5.010000'){eval q{
              sub _stringify { no overloading; "$_[0]" }
              sub _numify { no overloading; 0+$_[0] }
          };die $@ if $@}else {eval q{
              require Scalar::Util;
              sub _stringify { sprintf("%s=ARRAY(0x%x)",ref($_[0]),Scalar::Util::refaddr($_[0])) }
              sub _numify { Scalar::Util::refaddr($_[0]) }
          };die $@ if $@}}use overload q{""}=>\&_stringify,q{0+}=>\&_numify,q{bool}=>sub {!!scalar %{$_[0]->[_DATA]}},fallback=>1;sub new {my$class=shift;Carp::croak("new() requires key-value pairs")unless @_ % 2==0;my (%data,@keys,$k);while (@_){$k=shift;push@keys,"$k" unless exists$data{$k};$data{$k}=shift}return bless [\%data,\@keys,undef,0,0 ],$class}sub clone {my$self=CORE::shift;my$clone;if (@_){my%subhash;@subhash{@_}=@{$self->[_DATA]}{@_};$clone=[\%subhash,[map "$_",@_ ],undef,0,0 ]}elsif ($self->[_INDX]){$clone=[{%{$self->[_DATA]}},[grep!ref($_),@{$self->[_KEYS]}],undef,0,0 ]}else {$clone=[{%{$self->[_DATA]}},[@{$self->[_KEYS]}],undef,0,0 ]}return bless$clone,ref$self}sub keys {my ($self)=@_;return wantarray ? (grep!ref($_),@{$self->[_KEYS]}): @{$self->[_KEYS]}- $self->[_GCNT]}sub values {my$self=CORE::shift;return wantarray ? (map {$self->[_DATA]{$_}}(@_ ? @_ : grep!ref($_),@{$self->[_KEYS]})): @{$self->[_KEYS]}- $self->[_GCNT]}sub get {return $_[0]->[_DATA]{$_[1]}}sub set {my ($self,$key)=@_;if (!exists$self->[_DATA]{$key}){my$keys=$self->[_KEYS];if (my$indx=$self->[_INDX]){$indx->{$key}=@$keys ? $indx->{$keys->[-1]}+ 1 : 0}CORE::push @{$self->[_KEYS]},"$key"}return$self->[_DATA]{$key}=$_[2]}sub exists {return exists $_[0]->[_DATA]{$_[1]}}sub delete {my ($self,$key)=@_;if (exists$self->[_DATA]{$key}){my$keys=$self->[_KEYS];if (!$self->[_INDX]&& @$keys > _INDEX_THRESHOLD){my%indx;$indx{$keys->[$_]}=$_ for 0 .. $#{$keys};$self->[_INDX]=\%indx}if ($self->[_INDX]){$keys->[delete($self->[_INDX]{$key})+ $self->[_OFFS]]=_TOMBSTONE;if (++$self->[_GCNT]> @$keys / 2){@{$self->[_KEYS]}=grep!ref($_),@{$self->[_KEYS]};$self->[_INDX]=undef;$self->[_OFFS]=0;$self->[_GCNT]=0}elsif (ref($keys->[0])){my$i=0;$i++ while ref($keys->[$i]);splice @$keys,0,$i;$self->[_GCNT]-= $i;$self->[_OFFS]-= $i}elsif (ref($keys->[-1])){my$i=$#{$keys};$i-- while ref($keys->[$i]);$self->[_GCNT]-= $#{$keys}- $i;splice @$keys,$i + 1}}else {my$i;for (0 .. $#{$keys}){if ($keys->[$_]eq $key){$i=$_;last}}splice @$keys,$i,1}return delete$self->[_DATA]{$key}}return undef}sub clear {my ($self)=@_;@$self=({},[],undef,0,0);return}sub push {my$self=CORE::shift;my ($data,$keys)=@$self;while (@_){my ($k,$v)=splice(@_,0,2);$self->delete($k)if exists$data->{$k};$data->{$k}=$v;if (my$indx=$self->[_INDX]){$indx->{$k}=@$keys ? $indx->{$keys->[-1]}+ 1 : 0}CORE::push @$keys,"$k"}return @$keys - $self->[_GCNT]}sub pop {my ($self)=@_;if ($self->[_INDX]){my$key=$self->[_KEYS][-1];return$key,$self->delete($key)}else {my$key=CORE::pop @{$self->[_KEYS]};return defined($key)? ($key,delete$self->[_DATA]{$key}): ()}}sub unshift {my$self=CORE::shift;my ($data,$keys)=@$self;while (@_){my ($k,$v)=splice(@_,-2,2);$self->delete($k)if exists$data->{$k};$data->{$k}=$v;CORE::unshift @$keys,"$k";$self->[_INDX]{$k}=-(++$self->[_OFFS])if$self->[_INDX]}return @$keys - $self->[_GCNT]}sub shift {my ($self)=@_;if ($self->[_INDX]){my$key=$self->[_KEYS][0];return$key,$self->delete($key)}else {my$key=CORE::shift @{$self->[_KEYS]};return defined($key)? ($key,delete$self->[_DATA]{$key}): ()}}sub merge {my$self=CORE::shift;while (@_){my ($k,$v)=splice(@_,0,2);if (!exists$self->[_DATA]{$k}){my$size=CORE::push @{$self->[_KEYS]},"$k";$self->[_INDX]{$k}=$size - 1 if$self->[_INDX]}$self->[_DATA]{$k}=$v}return @{$self->[_KEYS]}- $self->[_GCNT]}sub as_list {my$self=CORE::shift;return map {;$_=>$self->[_DATA]{$_}}(@_ ? @_ : grep!ref($_),@{$self->[_KEYS]})}sub iterator {my ($self,@keys)=@_;@keys=grep!ref($_),@{$self->[_KEYS]}unless@keys;my$data=$self->[_DATA];return sub {return unless@keys;my$key=CORE::shift(@keys);return ($key=>$data->{$key})}}sub preinc {return ++$_[0]->[_DATA]{$_[1]}}sub postinc {return $_[0]->[_DATA]{$_[1]}++}sub predec {return --$_[0]->[_DATA]{$_[1]}}sub postdec {return $_[0]->[_DATA]{$_[1]}--}sub add {return $_[0]->[_DATA]{$_[1]}+= $_[2]|| 0}sub subtract {return $_[0]->[_DATA]{$_[1]}-= $_[2]|| 0}sub concat {if (defined $_[2]){return $_[0]->[_DATA]{$_[1]}.= $_[2]}else {return $_[0]->[_DATA]{$_[1]}}}sub or_equals {my ($self,$key)=@_;if (my$val=$self->get($key)){return$val}return$self->set($key,$_[2])}sub dor_equals {my ($self,$key)=@_;if (defined(my$val=$self->get($key))){return$val}return$self->set($key,$_[2])}{no strict 'refs';*{__PACKAGE__ .'::TIEHASH'}=\&new;*{__PACKAGE__ .'::STORE'}=\&set;*{__PACKAGE__ .'::FETCH'}=\&get;*{__PACKAGE__ .'::EXISTS'}=\&exists;*{__PACKAGE__ .'::DELETE'}=\&delete;*{__PACKAGE__ .'::CLEAR'}=\&clear}sub FIRSTKEY {my ($self)=@_;my@keys=grep!ref($_),@{$self->[_KEYS]};$self->[_ITER]=sub {return unless@keys;return CORE::shift(@keys)};return$self->[_ITER]->()}sub NEXTKEY {return defined($_[0]->[_ITER])? $_[0]->[_ITER]->(): undef}sub SCALAR {return scalar %{$_[0]->[_DATA]}}1;
HASH_ORDERED

$fatpacked{"Method/Generate/Accessor.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'METHOD_GENERATE_ACCESSOR';
  package Method::Generate::Accessor;use Moo::_strictures;use Moo::_Utils qw(_load_module _maybe_load_module _install_coderef);use Moo::Object ();BEGIN {our@ISA=qw(Moo::Object)}use Sub::Quote qw(quote_sub quoted_from_sub quotify sanitize_identifier);use Scalar::Util 'blessed';use Carp qw(croak);BEGIN {our@CARP_NOT=qw(Moo::_Utils)}BEGIN {*_CAN_WEAKEN_READONLY=("$]" < 5.008_003 or $ENV{MOO_TEST_PRE_583})? sub(){0}: sub(){1};our$CAN_HAZ_XS=!$ENV{MOO_XS_DISABLE}&& _maybe_load_module('Class::XSAccessor')&& (eval {Class::XSAccessor->VERSION('1.07')});our$CAN_HAZ_XS_PRED=$CAN_HAZ_XS && (eval {Class::XSAccessor->VERSION('1.17')})}BEGIN {package Method::Generate::Accessor::_Generated;$Carp::Internal{+__PACKAGE__}=1}my$module_name_only=qr/\A$Module::Runtime::module_name_rx\z/;sub _die_overwrite {my ($pkg,$method,$type)=@_;croak "You cannot overwrite a locally defined method ($method) with " .($type || 'an accessor')}sub generate_method {my ($self,$into,$name,$spec,$quote_opts)=@_;$quote_opts={no_defer=>1,package=>'Method::Generate::Accessor::_Generated',%{$quote_opts||{}},};$spec->{allow_overwrite}++ if$name =~ s/^\+//;croak "Must have an is" unless my$is=$spec->{is};if ($is eq 'ro'){$spec->{reader}=$name unless exists$spec->{reader}}elsif ($is eq 'rw'){$spec->{accessor}=$name unless exists$spec->{accessor}or ($spec->{reader}and $spec->{writer})}elsif ($is eq 'lazy'){$spec->{reader}=$name unless exists$spec->{reader};$spec->{lazy}=1;$spec->{builder}||= '_build_'.$name unless exists$spec->{default}}elsif ($is eq 'rwp'){$spec->{reader}=$name unless exists$spec->{reader};$spec->{writer}="_set_${name}" unless exists$spec->{writer}}elsif ($is ne 'bare'){croak "Unknown is ${is}"}if (exists$spec->{builder}){if(ref$spec->{builder}){$self->_validate_codulatable('builder',$spec->{builder},"$into->$name",'or a method name');$spec->{builder_sub}=$spec->{builder};$spec->{builder}=1}$spec->{builder}='_build_'.$name if ($spec->{builder}||0)eq 1;croak "Invalid builder for $into->$name - not a valid method name" if$spec->{builder}!~ $module_name_only}if (($spec->{predicate}||0)eq 1){$spec->{predicate}=$name =~ /^_/ ? "_has${name}" : "has_${name}"}if (($spec->{clearer}||0)eq 1){$spec->{clearer}=$name =~ /^_/ ? "_clear${name}" : "clear_${name}"}if (($spec->{trigger}||0)eq 1){$spec->{trigger}=quote_sub('shift->_trigger_'.$name.'(@_)')}if (($spec->{coerce}||0)eq 1){my$isa=$spec->{isa};if (blessed$isa and $isa->can('coercion')){$spec->{coerce}=$isa->coercion}elsif (blessed$isa and $isa->can('coerce')){$spec->{coerce}=sub {$isa->coerce(@_)}}else {croak "Invalid coercion for $into->$name - no appropriate type constraint"}}for my$setting (qw(isa coerce)){next if!exists$spec->{$setting};$self->_validate_codulatable($setting,$spec->{$setting},"$into->$name")}if (exists$spec->{default}){if (ref$spec->{default}){$self->_validate_codulatable('default',$spec->{default},"$into->$name",'or a non-ref')}}if (exists$spec->{moosify}){if (ref$spec->{moosify}ne 'ARRAY'){$spec->{moosify}=[$spec->{moosify}]}for my$spec (@{$spec->{moosify}}){$self->_validate_codulatable('moosify',$spec,"$into->$name")}}my%methods;if (my$reader=$spec->{reader}){_die_overwrite($into,$reader,'a reader')if!$spec->{allow_overwrite}&& defined &{"${into}::${reader}"};if (our$CAN_HAZ_XS && $self->is_simple_get($name,$spec)){$methods{$reader}=$self->_generate_xs(getters=>$into,$reader,$name,$spec)}else {$self->{captures}={};$methods{$reader}=quote_sub "${into}::${reader}" =>'    Carp::croak("'.$reader.' is a read-only accessor") if @_ > 1;'."\n" .$self->_generate_get($name,$spec)=>delete$self->{captures}=>$quote_opts }}if (my$accessor=$spec->{accessor}){_die_overwrite($into,$accessor,'an accessor')if!$spec->{allow_overwrite}&& defined &{"${into}::${accessor}"};if (our$CAN_HAZ_XS && $self->is_simple_get($name,$spec)&& $self->is_simple_set($name,$spec)){$methods{$accessor}=$self->_generate_xs(accessors=>$into,$accessor,$name,$spec)}else {$self->{captures}={};$methods{$accessor}=quote_sub "${into}::${accessor}" =>$self->_generate_getset($name,$spec)=>delete$self->{captures}=>$quote_opts }}if (my$writer=$spec->{writer}){_die_overwrite($into,$writer,'a writer')if!$spec->{allow_overwrite}&& defined &{"${into}::${writer}"};if (our$CAN_HAZ_XS && $self->is_simple_set($name,$spec)){$methods{$writer}=$self->_generate_xs(setters=>$into,$writer,$name,$spec)}else {$self->{captures}={};$methods{$writer}=quote_sub "${into}::${writer}" =>$self->_generate_set($name,$spec)=>delete$self->{captures}=>$quote_opts }}if (my$pred=$spec->{predicate}){_die_overwrite($into,$pred,'a predicate')if!$spec->{allow_overwrite}&& defined &{"${into}::${pred}"};if (our$CAN_HAZ_XS && our$CAN_HAZ_XS_PRED){$methods{$pred}=$self->_generate_xs(exists_predicates=>$into,$pred,$name,$spec)}else {$self->{captures}={};$methods{$pred}=quote_sub "${into}::${pred}" =>$self->_generate_simple_has('$_[0]',$name,$spec)."\n" =>delete$self->{captures}=>$quote_opts }}if (my$builder=delete$spec->{builder_sub}){_install_coderef("${into}::$spec->{builder}"=>$builder)}if (my$cl=$spec->{clearer}){_die_overwrite($into,$cl,'a clearer')if!$spec->{allow_overwrite}&& defined &{"${into}::${cl}"};$self->{captures}={};$methods{$cl}=quote_sub "${into}::${cl}" =>$self->_generate_simple_clear('$_[0]',$name,$spec)."\n" =>delete$self->{captures}=>$quote_opts }if (my$hspec=$spec->{handles}){my$asserter=$spec->{asserter}||= '_assert_'.$name;my@specs=do {if (ref($hspec)eq 'ARRAY'){map [$_=>$_ ],@$hspec}elsif (ref($hspec)eq 'HASH'){map [$_=>ref($hspec->{$_})? @{$hspec->{$_}}: $hspec->{$_}],keys %$hspec}elsif (!ref($hspec)){require Moo::Role;_load_module$hspec;map [$_=>$_ ],Moo::Role->methods_provided_by($hspec)}else {croak "You gave me a handles of ${hspec} and I have no idea why"}};for my$delegation_spec (@specs){my ($proxy,$target,@args)=@$delegation_spec;_die_overwrite($into,$proxy,'a delegation')if!$spec->{allow_overwrite}&& defined &{"${into}::${proxy}"};$self->{captures}={};$methods{$proxy}=quote_sub "${into}::${proxy}" =>$self->_generate_delegation($asserter,$target,\@args)=>delete$self->{captures}=>$quote_opts }}if (my$asserter=$spec->{asserter}){_die_overwrite($into,$asserter,'an asserter')if!$spec->{allow_overwrite}&& defined &{"${into}::${asserter}"};local$self->{captures}={};$methods{$asserter}=quote_sub "${into}::${asserter}" =>$self->_generate_asserter($name,$spec)=>delete$self->{captures}=>$quote_opts }\%methods}sub merge_specs {my ($self,@specs)=@_;my$spec=shift@specs;for my$old_spec (@specs){for my$key (keys %$old_spec){if ($key eq 'handles'){}elsif ($key eq 'moosify'){$spec->{$key}=[map {ref $_ eq 'ARRAY' ? @$_ : $_}grep defined,($old_spec->{$key},$spec->{$key})]}elsif ($key eq 'builder' || $key eq 'default'){$spec->{$key}=$old_spec->{$key}if!(exists$spec->{builder}|| exists$spec->{default})}elsif (!exists$spec->{$key}){$spec->{$key}=$old_spec->{$key}}}}$spec}sub is_simple_attribute {my ($self,$name,$spec)=@_;!grep$spec->{$_},qw(lazy default builder coerce isa trigger predicate weak_ref)}sub is_simple_get {my ($self,$name,$spec)=@_;!($spec->{lazy}and (exists$spec->{default}or $spec->{builder}))}sub is_simple_set {my ($self,$name,$spec)=@_;!grep$spec->{$_},qw(coerce isa trigger weak_ref)}sub has_default {my ($self,$name,$spec)=@_;$spec->{builder}or exists$spec->{default}or (($spec->{is}||'')eq 'lazy')}sub has_eager_default {my ($self,$name,$spec)=@_;(!$spec->{lazy}and (exists$spec->{default}or $spec->{builder}))}sub _generate_get {my ($self,$name,$spec)=@_;my$simple=$self->_generate_simple_get('$_[0]',$name,$spec);if ($self->is_simple_get($name,$spec)){$simple}else {$self->_generate_use_default('$_[0]',$name,$spec,$self->_generate_simple_has('$_[0]',$name,$spec),)}}sub generate_simple_has {my$self=shift;$self->{captures}={};my$code=$self->_generate_simple_has(@_);($code,delete$self->{captures})}sub _generate_simple_has {my ($self,$me,$name)=@_;"exists ${me}->{${\quotify $name}}"}sub _generate_simple_clear {my ($self,$me,$name)=@_;"    delete ${me}->{${\quotify $name}}\n"}sub generate_get_default {my$self=shift;$self->{captures}={};my$code=$self->_generate_get_default(@_);($code,delete$self->{captures})}sub generate_use_default {my$self=shift;$self->{captures}={};my$code=$self->_generate_use_default(@_);($code,delete$self->{captures})}sub _generate_use_default {my ($self,$me,$name,$spec,$test)=@_;my$get_value=$self->_generate_get_default($me,$name,$spec);if ($spec->{coerce}){$get_value=$self->_generate_coerce($name,$get_value,$spec->{coerce})}$test." ? \n" .$self->_generate_simple_get($me,$name,$spec)."\n:" .($spec->{isa}? "    do {\n      my \$value = ".$get_value.";\n" ."      ".$self->_generate_isa_check($name,'$value',$spec->{isa}).";\n" ."      ".$self->_generate_simple_set($me,$name,$spec,'$value')."\n" ."    }\n" : '    ('.$self->_generate_simple_set($me,$name,$spec,$get_value).")\n")}sub _generate_get_default {my ($self,$me,$name,$spec)=@_;if (exists$spec->{default}){ref$spec->{default}? $self->_generate_call_code($name,'default',$me,$spec->{default}): quotify$spec->{default}}else {"${me}->${\$spec->{builder}}"}}sub generate_simple_get {my ($self,@args)=@_;$self->{captures}={};my$code=$self->_generate_simple_get(@args);($code,delete$self->{captures})}sub _generate_simple_get {my ($self,$me,$name)=@_;my$name_str=quotify$name;"${me}->{${name_str}}"}sub _generate_set {my ($self,$name,$spec)=@_;my ($me,$source)=('$_[0]','$_[1]');if ($self->is_simple_set($name,$spec)){return$self->_generate_simple_set($me,$name,$spec,$source)}my ($coerce,$trigger,$isa_check)=@{$spec}{qw(coerce trigger isa)};if ($coerce){$source=$self->_generate_coerce($name,$source,$coerce)}if ($isa_check){'scalar do { my $value = '.$source.";\n" .'  ('.$self->_generate_isa_check($name,'$value',$isa_check)."),\n" .'  ('.$self->_generate_simple_set($me,$name,$spec,'$value')."),\n" .($trigger ? '('.$self->_generate_trigger($name,$me,'$value',$trigger)."),\n" : '').'  ('.$self->_generate_simple_get($me,$name,$spec)."),\n" ."}"}elsif ($trigger){my$set=$self->_generate_simple_set($me,$name,$spec,$source);"scalar (\n" .'  ('.$self->_generate_trigger($name,$me,"($set)",$trigger)."),\n" .'  ('.$self->_generate_simple_get($me,$name,$spec)."),\n" .")"}else {'('.$self->_generate_simple_set($me,$name,$spec,$source).')'}}sub generate_coerce {my$self=shift;$self->{captures}={};my$code=$self->_generate_coerce(@_);($code,delete$self->{captures})}sub _attr_desc {my ($name,$init_arg)=@_;return quotify($name)if!defined($init_arg)or $init_arg eq $name;return quotify($name).' (constructor argument: '.quotify($init_arg).')'}sub _generate_coerce {my ($self,$name,$value,$coerce,$init_arg)=@_;$self->_wrap_attr_exception($name,"coercion",$init_arg,$self->_generate_call_code($name,'coerce',"${value}",$coerce),1,)}sub generate_trigger {my$self=shift;$self->{captures}={};my$code=$self->_generate_trigger(@_);($code,delete$self->{captures})}sub _generate_trigger {my ($self,$name,$obj,$value,$trigger)=@_;$self->_generate_call_code($name,'trigger',"${obj}, ${value}",$trigger)}sub generate_isa_check {my ($self,@args)=@_;$self->{captures}={};my$code=$self->_generate_isa_check(@args);($code,delete$self->{captures})}sub _wrap_attr_exception {my ($self,$name,$step,$arg,$code,$want_return)=@_;my$prefix=quotify("${step} for "._attr_desc($name,$arg).' failed: ');"do {\n" .'  local $Method::Generate::Accessor::CurrentAttribute = {'."\n" .'    init_arg => '.quotify($arg).",\n" .'    name     => '.quotify($name).",\n" .'    step     => '.quotify($step).",\n" ."  };\n" .($want_return ? '  (my $_return),'."\n" : '').'  (my $_error), (my $_old_error = $@);'."\n" ."  (eval {\n" .'    ($@ = $_old_error),'."\n" .'    (' .($want_return ? '$_return ='."\n" : '').$code."),\n" ."    1\n" ."  } or\n" .'    $_error = CORE::ref $@ ? $@ : '.$prefix.'.$@);'."\n" .'  ($@ = $_old_error),'."\n" .'  (defined $_error and CORE::die $_error);'."\n" .($want_return ? '  $_return;'."\n" : '')."}\n"}sub _generate_isa_check {my ($self,$name,$value,$check,$init_arg)=@_;$self->_wrap_attr_exception($name,"isa check",$init_arg,$self->_generate_call_code($name,'isa_check',$value,$check))}sub _generate_call_code {my ($self,$name,$type,$values,$sub)=@_;$sub=\&{$sub}if blessed($sub);if (my$quoted=quoted_from_sub($sub)){my$local=1;if ($values eq '@_' || $values eq '$_[0]'){$local=0;$values='@_'}my$code=$quoted->[1];if (my$captures=$quoted->[2]){my$cap_name=qq{\$${type}_captures_for_}.sanitize_identifier($name);$self->{captures}->{$cap_name}=\$captures;Sub::Quote::inlinify($code,$values,Sub::Quote::capture_unroll($cap_name,$captures,6),$local)}else {Sub::Quote::inlinify($code,$values,undef,$local)}}else {my$cap_name=qq{\$${type}_for_}.sanitize_identifier($name);$self->{captures}->{$cap_name}=\$sub;"${cap_name}->(${values})"}}sub _sanitize_name {sanitize_identifier($_[1])}sub generate_populate_set {my$self=shift;$self->{captures}={};my$code=$self->_generate_populate_set(@_);($code,delete$self->{captures})}sub _generate_populate_set {my ($self,$me,$name,$spec,$source,$test,$init_arg)=@_;my$has_default=$self->has_eager_default($name,$spec);if (!($has_default || $test)){return ''}if ($has_default){my$get_default=$self->_generate_get_default($me,$name,$spec);$source=$test ? "(\n  ${test}\n" ."   ? ${source}\n   : " .$get_default .")" : $get_default}if ($spec->{coerce}){$source=$self->_generate_coerce($name,$source,$spec->{coerce},$init_arg)}if ($spec->{isa}){$source='scalar do { my $value = '.$source.";\n" .'  ('.$self->_generate_isa_check($name,'$value',$spec->{isa},$init_arg)."),\n" ."  \$value\n" ."}\n"}my$set=$self->_generate_simple_set($me,$name,$spec,$source);my$trigger=$spec->{trigger}? $self->_generate_trigger($name,$me,$self->_generate_simple_get($me,$name,$spec),$spec->{trigger}): undef;if ($has_default){"($set)," .($trigger && $test ? "($test and $trigger)," : '')."\n"}else {"($test and ($set)" .($trigger ? ", ($trigger)" : '')."),\n"}}sub _generate_core_set {my ($self,$me,$name,$spec,$value)=@_;my$name_str=quotify$name;"${me}->{${name_str}} = ${value}"}sub _generate_simple_set {my ($self,$me,$name,$spec,$value)=@_;my$name_str=quotify$name;my$simple=$self->_generate_core_set($me,$name,$spec,$value);if ($spec->{weak_ref}){require Scalar::Util;my$get=$self->_generate_simple_get($me,$name,$spec);my$weak_simple=_CAN_WEAKEN_READONLY ? "do { Scalar::Util::weaken(${simple}); no warnings 'void'; $get }" : <<"EOC"}else {$simple}}sub _generate_getset {my ($self,$name,$spec)=@_;q{(@_ > 1}."\n      ? ".$self->_generate_set($name,$spec)."\n      : ".$self->_generate_get($name,$spec)."\n    )"}sub _generate_asserter {my ($self,$name,$spec)=@_;my$name_str=quotify($name);"do {\n" ."  my \$val = ".$self->_generate_get($name,$spec).";\n" ."  ".$self->_generate_simple_has('$_[0]',$name,$spec)."\n" ."    or Carp::croak(q{Attempted to access '}.${name_str}.q{' but it is not set});\n" ."  \$val;\n" ."}\n"}sub _generate_delegation {my ($self,$asserter,$target,$args)=@_;my$arg_string=do {if (@$args){$self->{captures}{'@curries'}=$args;'@curries, @_'}else {'@_'}};"shift->${asserter}->${target}(${arg_string});"}sub _generate_xs {my ($self,$type,$into,$name,$slot)=@_;Class::XSAccessor->import(class=>$into,$type=>{$name=>$slot },replace=>1,);$into->can($name)}sub default_construction_string {'{}'}sub _validate_codulatable {my ($self,$setting,$value,$into,$appended)=@_;my$error;if (blessed$value){local $@;no warnings 'void';eval {\&$value;1}and return 1;$error="could not be converted to a coderef: $@"}elsif (ref$value eq 'CODE'){return 1}else {$error='is not a coderef or code-convertible object'}croak "Invalid $setting '" .($INC{'overload.pm'}? overload::StrVal($value): $value)."' for $into " .$error .($appended ? " $appended" : '')}1;
          ( eval { Scalar::Util::weaken($simple); 1 }
            ? do { no warnings 'void'; $get }
            : do {
              if( \$@ =~ /Modification of a read-only value attempted/) {
                require Carp;
                Carp::croak( sprintf (
                  'Reference to readonly value in "%s" can not be weakened on Perl < 5.8.3',
                  $name_str,
                ) );
              } else {
                die \$@;
              }
            }
          )
  EOC
METHOD_GENERATE_ACCESSOR

$fatpacked{"Method/Generate/BuildAll.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'METHOD_GENERATE_BUILDALL';
  package Method::Generate::BuildAll;use Moo::_strictures;use Moo::Object ();BEGIN {our@ISA=qw(Moo::Object)}use Sub::Quote qw(quote_sub quotify);use Moo::_Utils qw(_getglob);use Moo::_mro;sub generate_method {my ($self,$into)=@_;quote_sub "${into}::BUILDALL" =>join('',$self->_handle_subbuild($into),qq{    my \$self = shift;\n},$self->buildall_body_for($into,'$self','@_'),qq{    return \$self\n},)=>{}=>{no_defer=>1 }}sub _handle_subbuild {my ($self,$into)=@_;'    if (ref($_[0]) ne '.quotify($into).') {'."\n".'      return shift->Moo::Object::BUILDALL(@_)'.";\n".'    }'."\n"}sub buildall_body_for {my ($self,$into,$me,$args)=@_;my@builds=grep *{_getglob($_)}{CODE},map "${_}::BUILD",reverse @{mro::get_linear_isa($into)};'    (('.$args.')[0]->{__no_BUILD__} or ('."\n" .join('',map qq{      ${me}->${_}(${args}),\n},@builds)."    )),\n"}1;
METHOD_GENERATE_BUILDALL

$fatpacked{"Method/Generate/Constructor.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'METHOD_GENERATE_CONSTRUCTOR';
  package Method::Generate::Constructor;use Moo::_strictures;use Sub::Quote qw(quote_sub quotify);use Sub::Defer;use Moo::_Utils qw(_getstash _getglob);use Moo::_mro;use Scalar::Util qw(weaken);use Carp qw(croak);use Carp::Heavy ();BEGIN {our@CARP_NOT=qw(Sub::Defer)}BEGIN {local$Moo::sification::disabled=1;require Moo;Moo->import}sub register_attribute_specs {my ($self,@new_specs)=@_;$self->assert_constructor;my$specs=$self->{attribute_specs}||={};my$ag=$self->accessor_generator;while (my ($name,$new_spec)=splice@new_specs,0,2){if ($name =~ s/^\+//){croak "has '+${name}' given but no ${name} attribute already exists" unless my$old_spec=$specs->{$name};$ag->merge_specs($new_spec,$old_spec)}if ($new_spec->{required}&&!($ag->has_default($name,$new_spec)||!exists$new_spec->{init_arg}|| defined$new_spec->{init_arg})){croak "You cannot have a required attribute (${name})" ." without a default, builder, or an init_arg"}$new_spec->{index}=scalar keys %$specs unless defined$new_spec->{index};$specs->{$name}=$new_spec}$self}sub all_attribute_specs {$_[0]->{attribute_specs}}sub accessor_generator {$_[0]->{accessor_generator}}sub construction_string {my ($self)=@_;$self->{construction_string}||= $self->_build_construction_string}sub buildall_generator {require Method::Generate::BuildAll;Method::Generate::BuildAll->new}sub _build_construction_string {my ($self)=@_;my$builder=$self->{construction_builder};$builder ? $self->$builder : 'bless(' .$self->accessor_generator->default_construction_string .', $class);'}sub install_delayed {my ($self)=@_;$self->assert_constructor;my$package=$self->{package};my (undef,@isa)=@{mro::get_linear_isa($package)};my$isa=join ',',@isa;my (undef,$from_file,$from_line)=caller(Carp::short_error_loc());my$constructor=defer_sub "${package}::new"=>sub {my (undef,@new_isa)=@{mro::get_linear_isa($package)};if (join(',',@new_isa)ne $isa){my ($expected_new)=grep {*{_getglob($_.'::new')}{CODE}}@isa;my ($found_new)=grep {*{_getglob($_.'::new')}{CODE}}@new_isa;if (($found_new||'')ne ($expected_new||'')){$found_new ||= 'none';$expected_new ||= 'none';croak "Expected parent constructor of $package to be" ." $expected_new, but found $found_new: changing the inheritance" ." chain (\@ISA) at runtime (after $from_file line $from_line) is unsupported"}}my$constructor=$self->generate_method($package,'new',$self->{attribute_specs},{no_install=>1,no_defer=>1 });$self->{inlined}=1;weaken($self->{constructor}=$constructor);$constructor};$self->{inlined}=0;weaken($self->{constructor}=$constructor);$self}sub current_constructor {my ($self,$package)=@_;return *{_getglob("${package}::new")}{CODE}}sub assert_constructor {my ($self)=@_;my$package=$self->{package}or return 1;my$current=$self->current_constructor($package)or return 1;my$constructor=$self->{constructor}or croak "Unknown constructor for $package already exists";croak "Constructor for $package has been replaced with an unknown sub" if$constructor!=$current;croak "Constructor for $package has been inlined and cannot be updated" if$self->{inlined}}sub generate_method {my ($self,$into,$name,$spec,$quote_opts)=@_;$quote_opts={%{$quote_opts||{}},package=>$into,};for my$no_init (grep!exists($spec->{$_}{init_arg}),keys %$spec){$spec->{$no_init}{init_arg}=$no_init}local$self->{captures}={};my$into_buildargs=$into->can('BUILDARGS');my$body ='    my $invoker = CORE::shift();'."\n" .'    my $class = CORE::ref($invoker) ? CORE::ref($invoker) : $invoker;'."\n" .$self->_handle_subconstructor($into,$name).($into_buildargs && $into_buildargs!=\&Moo::Object::BUILDARGS ? $self->_generate_args_via_buildargs : $self->_generate_args).$self->_check_required($spec).'    my $new = '.$self->construction_string.";\n" .$self->_assign_new($spec).($into->can('BUILD')? $self->buildall_generator->buildall_body_for($into,'$new','$args'): '').'    return $new;'."\n";if ($into->can('DEMOLISH')){require Method::Generate::DemolishAll;Method::Generate::DemolishAll->new->generate_method($into)}quote_sub "${into}::${name}"=>$body,$self->{captures},$quote_opts||{}}sub _handle_subconstructor {my ($self,$into,$name)=@_;if (my$gen=$self->{subconstructor_handler}){'    if ($class ne '.quotify($into).') {'."\n".$gen.'    }'."\n"}else {''}}sub _cap_call {my ($self,$code,$captures)=@_;@{$self->{captures}}{keys %$captures}=values %$captures if$captures;$code}sub _generate_args_via_buildargs {my ($self)=@_;q{    my $args = $class->BUILDARGS(@_);}."\n" .q{    Carp::croak("BUILDARGS did not return a hashref") unless CORE::ref($args) eq 'HASH';} ."\n"}sub _generate_args {my ($self)=@_;return <<'_EOA'}sub _assign_new {my ($self,$spec)=@_;my$ag=$self->accessor_generator;my%test;NAME: foreach my$name (sort keys %$spec){my$attr_spec=$spec->{$name};next NAME unless defined($attr_spec->{init_arg})or $ag->has_eager_default($name,$attr_spec);$test{$name}=$attr_spec->{init_arg}}join '',map {my$arg=$test{$_};my$arg_key=quotify($arg);my$test=defined$arg ? "exists \$args->{$arg_key}" : undef;my$source=defined$arg ? "\$args->{$arg_key}" : undef;my$attr_spec=$spec->{$_};$self->_cap_call($ag->generate_populate_set('$new',$_,$attr_spec,$source,$test,$arg,))}sort keys%test}sub _check_required {my ($self,$spec)=@_;my@required_init=map$spec->{$_}{init_arg},grep {my$s=$spec->{$_};$s->{required}and not($s->{builder}or exists$s->{default})}sort keys %$spec;return '' unless@required_init;'    if (my @missing = grep !exists $args->{$_}, ' .join(', ',map quotify($_),@required_init).') {'."\n" .q{      Carp::croak("Missing required arguments: ".CORE::join(', ', sort @missing));}."\n" ."    }\n"}sub new {my$class=shift;delete _getstash(__PACKAGE__)->{new};bless$class->BUILDARGS(@_),$class}Moo->_constructor_maker_for(__PACKAGE__)->register_attribute_specs(attribute_specs=>{is=>'ro',reader=>'all_attribute_specs',},accessor_generator=>{is=>'ro' },construction_string=>{is=>'lazy' },construction_builder=>{is=>'bare' },subconstructor_handler=>{is=>'ro' },package=>{is=>'bare' },);if ($INC{'Moo/HandleMoose.pm'}&&!$Moo::sification::disabled){Moo::HandleMoose::inject_fake_metaclass_for(__PACKAGE__)}1;
      my $args = scalar @_ == 1
        ? CORE::ref $_[0] eq 'HASH'
          ? { %{ $_[0] } }
          : Carp::croak("Single parameters to new() must be a HASH ref"
              . " data => ". $_[0])
        : @_ % 2
          ? Carp::croak("The new() method for $class expects a hash reference or a"
              . " key/value list. You passed an odd number of arguments")
          : {@_}
      ;
  _EOA
METHOD_GENERATE_CONSTRUCTOR

$fatpacked{"Method/Generate/DemolishAll.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'METHOD_GENERATE_DEMOLISHALL';
  package Method::Generate::DemolishAll;use Moo::_strictures;use Moo::Object ();BEGIN {our@ISA=qw(Moo::Object)}use Sub::Quote qw(quote_sub quotify);use Moo::_Utils qw(_getglob);use Moo::_mro;BEGIN {*_USE_DGD="$]" < 5.014 ? sub(){1}: sub(){0};require Devel::GlobalDestruction if _USE_DGD()}sub generate_method {my ($self,$into)=@_;quote_sub "${into}::DEMOLISHALL",join '',$self->_handle_subdemolish($into),qq{    my \$self = shift;\n},$self->demolishall_body_for($into,'$self','@_'),qq{    return \$self\n};quote_sub "${into}::DESTROY",join '',q!    my $self = shift;
      my $e = do {
        local $?;
        local $@;!.(_USE_DGD ? q!
        require Devel::GlobalDestruction;! : '').q!
        package !.$into.q!;
        eval {
          $self->DEMOLISHALL(!.(_USE_DGD ? 'Devel::GlobalDestruction::in_global_destruction()' : q[${^GLOBAL_PHASE} eq 'DESTRUCT']).q!);
        };
        $@;
      };
  
      # fatal warnings+die in DESTROY = bad times (perl rt#123398)
      no warnings FATAL => 'all';
      use warnings 'all';
      die $e if $e; # rethrow
    !}sub demolishall_body_for {my ($self,$into,$me,$args)=@_;my@demolishers=grep *{_getglob($_)}{CODE},map "${_}::DEMOLISH",@{mro::get_linear_isa($into)};join '',qq{    package $into;\n},map qq{    ${me}->${_}(${args});\n},@demolishers}sub _handle_subdemolish {my ($self,$into)=@_;'    if (ref($_[0]) ne '.quotify($into).') {'."\n"."      package $into;\n".'      return shift->Moo::Object::DEMOLISHALL(@_)'.";\n".'    }'."\n"}1;
METHOD_GENERATE_DEMOLISHALL

$fatpacked{"Module/Implementation.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_IMPLEMENTATION';
  package Module::Implementation;$Module::Implementation::VERSION='0.09';use strict;use warnings;use Module::Runtime 0.012 qw(require_module);use Try::Tiny;unless (exists$Module::Implementation::{VERSION}&& ${$Module::Implementation::{VERSION}}){$Module::Implementation::{VERSION}=\42}my%Implementation;sub build_loader_sub {my$caller=caller();return _build_loader($caller,@_)}sub _build_loader {my$package=shift;my%args=@_;my@implementations=@{$args{implementations}};my@symbols=@{$args{symbols}|| []};my$implementation;my$env_var=uc$package;$env_var =~ s/::/_/g;$env_var .= '_IMPLEMENTATION';return sub {my ($implementation,$loaded)=_load_implementation($package,$ENV{$env_var},\@implementations,);$Implementation{$package}=$implementation;_copy_symbols($loaded,$package,\@symbols);return$loaded}}sub implementation_for {my$package=shift;return$Implementation{$package}}sub _load_implementation {my$package=shift;my$env_value=shift;my$implementations=shift;if ($env_value){die "$env_value is not a valid implementation for $package" unless grep {$_ eq $env_value}@{$implementations};my$requested="${package}::$env_value";($requested)=$requested =~ /^(.+)$/;try {require_module($requested)}catch {require Carp;Carp::croak("Could not load $requested: $_")};return ($env_value,$requested)}else {my$err;for my$possible (@{$implementations}){my$try="${package}::$possible";my$ok;try {require_module($try);$ok=1}catch {$err .= $_ if defined $_};return ($possible,$try)if$ok}require Carp;if (defined$err && length$err){Carp::croak("Could not find a suitable $package implementation: $err")}else {Carp::croak('Module::Runtime failed to load a module but did not throw a real error. This should never happen. Something is very broken')}}}sub _copy_symbols {my$from_package=shift;my$to_package=shift;my$symbols=shift;for my$sym (@{$symbols}){my$type=$sym =~ s/^([\$\@\%\&\*])// ? $1 : '&';my$from="${from_package}::$sym";my$to="${to_package}::$sym";{no strict 'refs';no warnings 'once';*{$to}=$type eq '&' ? \&{$from}: $type eq '$' ? \${$from}: $type eq '@' ? \@{$from}: $type eq '%' ? \%{$from}: $type eq '*' ? *{$from}: die "Can't copy symbol from $from_package to $to_package: $type$sym"}}}1;
MODULE_IMPLEMENTATION

$fatpacked{"Module/Runtime.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_RUNTIME';
  package Module::Runtime;BEGIN {require 5.006}BEGIN {${^WARNING_BITS}=""}our$VERSION="0.016";our@EXPORT_OK=qw($module_name_rx is_module_name is_valid_module_name check_module_name module_notional_filename require_module use_module use_package_optimistically $top_module_spec_rx $sub_module_spec_rx is_module_spec is_valid_module_spec check_module_spec compose_module_name);my%export_ok=map {($_=>undef)}@EXPORT_OK;sub import {my$me=shift;my$callpkg=caller(0);my$errs="";for(@_){if(exists$export_ok{$_}){if(/\A\$(.*)\z/s){*{$callpkg."::".$1}=\$$1}else {*{$callpkg."::".$_}=\&$_}}else {$errs .= "\"$_\" is not exported by the $me module\n"}}if($errs ne ""){die "${errs}Can't continue after import errors "."at @{[(caller(0))[1]]} line @{[(caller(0))[2]]}.\n"}}sub _is_string($) {my($arg)=@_;return defined($arg)&& ref(\$arg)eq "SCALAR"}our$module_name_rx=qr/[A-Z_a-z][0-9A-Z_a-z]*(?:::[0-9A-Z_a-z]+)*/;my$qual_module_spec_rx=qr#(?:/|::)[A-Z_a-z][0-9A-Z_a-z]*(?:(?:/|::)[0-9A-Z_a-z]+)*#;my$unqual_top_module_spec_rx=qr#[A-Z_a-z][0-9A-Z_a-z]*(?:(?:/|::)[0-9A-Z_a-z]+)*#;our$top_module_spec_rx=qr/$qual_module_spec_rx|$unqual_top_module_spec_rx/o;my$unqual_sub_module_spec_rx=qr#[0-9A-Z_a-z]+(?:(?:/|::)[0-9A-Z_a-z]+)*#;our$sub_module_spec_rx=qr/$qual_module_spec_rx|$unqual_sub_module_spec_rx/o;sub is_module_name($) {_is_string($_[0])&& $_[0]=~ /\A$module_name_rx\z/o}*is_valid_module_name=\&is_module_name;sub check_module_name($) {unless(&is_module_name){die +(_is_string($_[0])? "`$_[0]'" : "argument")." is not a module name\n"}}sub module_notional_filename($) {&check_module_name;my($name)=@_;$name =~ s!::!/!g;return$name.".pm"}BEGIN {*_WORK_AROUND_HINT_LEAKAGE="$]" < 5.011 &&!("$]" >= 5.009004 && "$]" < 5.010001)? sub(){1}: sub(){0};*_WORK_AROUND_BROKEN_MODULE_STATE="$]" < 5.009 ? sub(){1}: sub(){0}}BEGIN {if(_WORK_AROUND_BROKEN_MODULE_STATE){eval q{
  	sub Module::Runtime::__GUARD__::DESTROY {
  		delete $INC{$_[0]->[0]} if @{$_[0]};
  	}
  	1;
  };die $@ if $@ ne ""}}sub require_module($) {local %^H if _WORK_AROUND_HINT_LEAKAGE;if(_WORK_AROUND_BROKEN_MODULE_STATE){my$notional_filename=&module_notional_filename;my$guard=bless([$notional_filename ],"Module::Runtime::__GUARD__");my$result=CORE::require($notional_filename);pop @$guard;return$result}else {return scalar(CORE::require(&module_notional_filename))}}sub use_module($;$) {my($name,$version)=@_;require_module($name);$name->VERSION($version)if @_ >= 2;return$name}sub use_package_optimistically($;$) {my($name,$version)=@_;my$fn=module_notional_filename($name);eval {local$SIG{__DIE__};require_module($name)};die $@ if $@ ne "" && ($@ !~ /\ACan't locate \Q$fn\E .+ at \Q@{[__FILE__]}\E line/s || $@ =~ /^Compilation\ failed\ in\ require
  			 \ at\ \Q@{[__FILE__]}\E\ line/xm);$name->VERSION($version)if @_ >= 2;return$name}sub is_module_spec($$) {my($prefix,$spec)=@_;return _is_string($spec)&& $spec =~ ($prefix ? qr/\A$sub_module_spec_rx\z/o : qr/\A$top_module_spec_rx\z/o)}*is_valid_module_spec=\&is_module_spec;sub check_module_spec($$) {unless(&is_module_spec){die +(_is_string($_[1])? "`$_[1]'" : "argument")." is not a module specification\n"}}sub compose_module_name($$) {my($prefix,$spec)=@_;check_module_name($prefix)if defined$prefix;&check_module_spec;if($spec =~ s#\A(?:/|::)##){}else {$spec=$prefix."::".$spec if defined$prefix}$spec =~ s#/#::#g;return$spec}1;
MODULE_RUNTIME

$fatpacked{"Moo.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOO';
  package Moo;use Moo::_strictures;use Moo::_mro;use Moo::_Utils qw(_check_tracked _getglob _getstash _install_coderef _install_modifier _install_tracked _load_module _set_loaded _unimport_coderefs);use Carp qw(croak);BEGIN {our@CARP_NOT=qw(Method::Generate::Constructor Method::Generate::Accessor Moo::sification Moo::_Utils Moo::Role)}our$VERSION='2.004000';$VERSION =~ tr/_//d;require Moo::sification;Moo::sification->import;our%MAKERS;sub import {my$target=caller;my$class=shift;if ($INC{'Role/Tiny.pm'}and Role::Tiny->is_role($target)){croak "Cannot import Moo into a role"}_set_loaded(caller);strict->import;warnings->import;$class->_install_subs($target,@_);$class->make_class($target);return}sub make_class {my ($me,$target)=@_;my$makers=$MAKERS{$target}||= {};return$target if$makers->{is_class};my$stash=_getstash($target);$makers->{non_methods}={map +($_=>\&{"${target}::${_}"}),grep exists &{"${target}::${_}"},grep!/::\z/ &&!/\A\(/,keys %$stash };$makers->{is_class}=1;{no strict 'refs';@{"${target}::ISA"}=do {require Moo::Object;('Moo::Object')}unless @{"${target}::ISA"}}if ($INC{'Moo/HandleMoose.pm'}&&!$Moo::sification::disabled){Moo::HandleMoose::inject_fake_metaclass_for($target)}return$target}sub is_class {my ($me,$class)=@_;return$MAKERS{$class}&& $MAKERS{$class}{is_class}}sub _install_subs {my ($me,$target)=@_;my%install=$me->_gen_subs($target);_install_tracked$target=>$_=>$install{$_}for sort keys%install;return}sub _gen_subs {my ($me,$target)=@_;return (extends=>sub {$me->_set_superclasses($target,@_);$me->_maybe_reset_handlemoose($target);return},with=>sub {require Moo::Role;Moo::Role->apply_roles_to_package($target,@_);$me->_maybe_reset_handlemoose($target)},has=>sub {my$name_proto=shift;my@name_proto=ref$name_proto eq 'ARRAY' ? @$name_proto : $name_proto;if (@_ % 2!=0){croak "Invalid options for " .join(', ',map "'$_'",@name_proto)." attribute(s): even number of arguments expected, got " .scalar @_}my%spec=@_;for my$name (@name_proto){my$spec_ref=@name_proto > 1 ? +{%spec}: \%spec;$me->_constructor_maker_for($target)->register_attribute_specs($name,$spec_ref);$me->_accessor_maker_for($target)->generate_method($target,$name,$spec_ref);$me->_maybe_reset_handlemoose($target)}return},(map {my$type=$_;($type=>sub {_install_modifier($target,$type,@_);return},)}qw(before after around)),)}sub unimport {my$target=caller;_unimport_coderefs($target)}sub _set_superclasses {my$class=shift;my$target=shift;for my$superclass (@_){_load_module($superclass);if ($INC{'Role/Tiny.pm'}&& Role::Tiny->is_role($superclass)){croak "Can't extend role '$superclass'"}}@{*{_getglob("${target}::ISA")}{ARRAY}}=@_;if (my$old=delete$Moo::MAKERS{$target}{constructor}){$old->assert_constructor;delete _getstash($target)->{new};Moo->_constructor_maker_for($target)->register_attribute_specs(%{$old->all_attribute_specs})}elsif (!$target->isa('Moo::Object')){Moo->_constructor_maker_for($target)}$Moo::HandleMoose::MOUSE{$target}=[grep defined,map Mouse::Util::find_meta($_),@_ ]if Mouse::Util->can('find_meta')}sub _maybe_reset_handlemoose {my ($class,$target)=@_;if ($INC{'Moo/HandleMoose.pm'}&&!$Moo::sification::disabled){Moo::HandleMoose::maybe_reinject_fake_metaclass_for($target)}}sub _accessor_maker_for {my ($class,$target)=@_;return unless$MAKERS{$target};$MAKERS{$target}{accessor}||= do {my$maker_class=do {no strict 'refs';if (my$m=do {my@isa=@{mro::get_linear_isa($target)};shift@isa;if (my ($parent_new)=grep +(defined &{$_.'::new'}),@isa){$MAKERS{$parent_new}&& $MAKERS{$parent_new}{accessor}}else {undef}}){ref($m)}else {require Method::Generate::Accessor;'Method::Generate::Accessor'}};$maker_class->new}}sub _constructor_maker_for {my ($class,$target)=@_;return unless$MAKERS{$target};$MAKERS{$target}{constructor}||= do {require Method::Generate::Constructor;my%construct_opts=(package=>$target,accessor_generator=>$class->_accessor_maker_for($target),subconstructor_handler=>('      if ($Moo::MAKERS{$class}) {'."\n" .'        if ($Moo::MAKERS{$class}{constructor}) {'."\n" .'          package '.$target.';'."\n" .'          return $invoker->SUPER::new(@_);'."\n" .'        }'."\n" .'        '.$class.'->_constructor_maker_for($class);'."\n" .'        return $invoker->new(@_)'.";\n" .'      } elsif ($INC{"Moose.pm"} and my $meta = Class::MOP::get_metaclass_by_name($class)) {'."\n" .'        return $meta->new_object('."\n" .'          $class->can("BUILDARGS") ? $class->BUILDARGS(@_)'."\n" .'                      : $class->Moo::Object::BUILDARGS(@_)'."\n" .'        );'."\n" .'      }'."\n"),);my$con;my@isa=@{mro::get_linear_isa($target)};shift@isa;no strict 'refs';if (my ($parent_new)=grep +(defined &{$_.'::new'}),@isa){if ($parent_new eq 'Moo::Object'){}elsif (my$makers=$MAKERS{$parent_new}){$con=$makers->{constructor};$construct_opts{construction_string}=$con->construction_string if$con}elsif ($parent_new->can('BUILDALL')){$construct_opts{construction_builder}=sub {my$inv=$target->can('BUILDARGS')? '' : 'Moo::Object::';'do {' .'  my $args = $class->'.$inv.'BUILDARGS(@_);' .'  $args->{__no_BUILD__} = 1;' .'  $invoker->'.$target.'::SUPER::new($args);' .'}'}}else {$construct_opts{construction_builder}=sub {'$invoker->'.$target.'::SUPER::new(' .($target->can('FOREIGNBUILDARGS')? '$class->FOREIGNBUILDARGS(@_)' : '@_').')'}}}($con ? ref($con): 'Method::Generate::Constructor')->new(%construct_opts)->install_delayed ->register_attribute_specs(%{$con?$con->all_attribute_specs:{}})}}sub _concrete_methods_of {my ($me,$class)=@_;my$makers=$MAKERS{$class};my$non_methods=$makers->{non_methods}|| {};my$stash=_getstash($class);my$subs={map {;no strict 'refs';${"${class}::${_}"}=${"${class}::${_}"};($_=>\&{"${class}::${_}"})}grep exists &{"${class}::${_}"},grep!/::\z/,keys %$stash };my%tracked=map +($_=>1),_check_tracked($class,[keys %$subs ]);return {map +($_=>\&{"${class}::${_}"}),grep!($non_methods->{$_}&& $non_methods->{$_}==$subs->{$_}),grep!exists$tracked{$_},keys %$subs }}1;
MOO

$fatpacked{"Moo/HandleMoose.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOO_HANDLEMOOSE';
  package Moo::HandleMoose;use Moo::_strictures;use Moo::_Utils qw(_getstash);use Sub::Quote qw(quotify);use Carp qw(croak);our%TYPE_MAP;our$SETUP_DONE;sub import {return if$SETUP_DONE;inject_all();$SETUP_DONE=1}sub inject_all {croak "Can't inflate Moose metaclass with Moo::sification disabled" if$Moo::sification::disabled;require Class::MOP;inject_fake_metaclass_for($_)for grep $_ ne 'Moo::Object',keys%Moo::MAKERS;inject_fake_metaclass_for($_)for keys%Moo::Role::INFO;require Moose::Meta::Method::Constructor;@Moo::HandleMoose::FakeConstructor::ISA='Moose::Meta::Method::Constructor';@Moo::HandleMoose::FakeMeta::ISA='Moose::Meta::Method::Meta'}sub maybe_reinject_fake_metaclass_for {my ($name)=@_;our%DID_INJECT;if (delete$DID_INJECT{$name}){unless ($Moo::Role::INFO{$name}){Moo->_constructor_maker_for($name)->install_delayed}inject_fake_metaclass_for($name)}}sub inject_fake_metaclass_for {my ($name)=@_;require Class::MOP;require Moo::HandleMoose::FakeMetaClass;Class::MOP::store_metaclass_by_name($name,bless({name=>$name },'Moo::HandleMoose::FakeMetaClass'));require Moose::Util::TypeConstraints;if ($Moo::Role::INFO{$name}){Moose::Util::TypeConstraints::find_or_create_does_type_constraint($name)}else {Moose::Util::TypeConstraints::find_or_create_isa_type_constraint($name)}}{package Moo::HandleMoose::FakeConstructor;sub _uninlined_body {\&Moose::Object::new}}sub inject_real_metaclass_for {my ($name)=@_;our%DID_INJECT;return Class::MOP::get_metaclass_by_name($name)if$DID_INJECT{$name};require Moose;require Moo;require Moo::Role;require Scalar::Util;require Sub::Defer;Class::MOP::remove_metaclass_by_name($name);my ($am_role,$am_class,$meta,$attr_specs,$attr_order)=do {if (my$info=$Moo::Role::INFO{$name}){my@attr_info=@{$info->{attributes}||[]};(1,0,Moose::Meta::Role->initialize($name),{@attr_info },[@attr_info[grep!($_ % 2),0..$#attr_info]])}elsif (my$cmaker=Moo->_constructor_maker_for($name)){my$specs=$cmaker->all_attribute_specs;(0,1,Moose::Meta::Class->initialize($name),$specs,[sort {$specs->{$a}{index}<=> $specs->{$b}{index}}keys %$specs ])}else {(0,0,Moose::Meta::Class->initialize($name),{},[])}};{local$DID_INJECT{$name}=1;for my$spec (values %$attr_specs){if (my$inflators=delete$spec->{moosify}){$_->($spec)for @$inflators}}my%methods =%{($am_role ? 'Moo::Role' : 'Moo')->_concrete_methods_of($name)};if (my$info=$Moo::Role::INFO{$name}){delete$info->{methods}}$methods{$_}=Sub::Defer::undefer_sub($methods{$_})for grep $_ ne 'new',keys%methods;my@attrs;{local @{_getstash($name)}{keys%methods};my%seen_name;for my$attr_name (@$attr_order){$seen_name{$attr_name}=1;my%spec=%{$attr_specs->{$attr_name}};my%spec_map=(map {$_->name=>$_->init_arg||$_->name}((grep {$_->has_init_arg}$meta->attribute_metaclass->meta->get_all_attributes),grep {exists($_->{init_arg})? defined($_->init_arg): 1}map {my$meta=Moose::Util::resolve_metatrait_alias('Attribute',$_)->meta;map$meta->get_attribute($_),$meta->get_attribute_list}@{$spec{traits}||[]}));$spec_map{traits}||= 'traits';$spec{is}='ro' if$spec{is}eq 'lazy' or $spec{is}eq 'rwp';my$coerce=$spec{coerce};if (my$isa=$spec{isa}){my$tc=$spec{isa}=do {if (my$mapped=$TYPE_MAP{$isa}){my$type=$mapped->();unless (Scalar::Util::blessed($type)&& $type->isa("Moose::Meta::TypeConstraint")){croak "error inflating attribute '$attr_name' for package '$name': " ."\$TYPE_MAP{$isa} did not return a valid type constraint'"}$coerce ? $type->create_child_type(name=>$type->name): $type}else {Moose::Meta::TypeConstraint->new(constraint=>sub {eval {&$isa;1}})}};if ($coerce){$tc->coercion(Moose::Meta::TypeCoercion->new)->_compiled_type_coercion($coerce);$spec{coerce}=1}}elsif ($coerce){my$attr=quotify($attr_name);my$tc=Moose::Meta::TypeConstraint->new(constraint=>sub {die "This is not going to work"},inlined=>sub {'my $r = $_[42]{'.$attr.'}; $_[42]{'.$attr.'} = 1; $r'},);$tc->coercion(Moose::Meta::TypeCoercion->new)->_compiled_type_coercion($coerce);$spec{isa}=$tc;$spec{coerce}=1}%spec=map {$spec_map{$_}=>$spec{$_}}grep {exists$spec_map{$_}}keys%spec;push@attrs,$meta->add_attribute($attr_name=>%spec)}for my$mouse (do {our%MOUSE;@{$MOUSE{$name}||[]}}){for my$attr ($mouse->get_all_attributes){my%spec=%{$attr};delete@spec{qw(associated_class associated_methods __METACLASS__ provides curries)};my$attr_name=delete$spec{name};next if$seen_name{$attr_name}++;push@attrs,$meta->add_attribute($attr_name=>%spec)}}}for my$meth_name (keys%methods){my$meth_code=$methods{$meth_name};$meta->add_method($meth_name,$meth_code)}if ($am_role){my$info=$Moo::Role::INFO{$name};$meta->add_required_methods(@{$info->{requires}});for my$modifier (@{$info->{modifiers}}){my ($type,@args)=@$modifier;my$code=pop@args;$meta->${\"add_${type}_method_modifier"}($_,$code)for@args}}elsif ($am_class){for my$attr (@attrs){for my$method (@{$attr->associated_methods}){$method->{body}=$name->can($method->name)}}bless($meta->find_method_by_name('new'),'Moo::HandleMoose::FakeConstructor',);my$meta_meth;if ($meta_meth=$meta->find_method_by_name('meta')and $meta_meth->body==\&Moo::Object::meta){bless($meta_meth,'Moo::HandleMoose::FakeMeta')}require Method::Generate::DemolishAll}$meta->add_role(Class::MOP::class_of($_))for grep!/\|/ && $_ ne $name,keys %{$Moo::Role::APPLIED_TO{$name}}}$DID_INJECT{$name}=1;$meta}1;
MOO_HANDLEMOOSE

$fatpacked{"Moo/HandleMoose/FakeMetaClass.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOO_HANDLEMOOSE_FAKEMETACLASS';
  package Moo::HandleMoose::FakeMetaClass;use Moo::_strictures;use Carp ();BEGIN {our@CARP_NOT=qw(Moo::HandleMoose)}sub DESTROY {}sub AUTOLOAD {my ($meth)=(our$AUTOLOAD =~ /([^:]+)$/);my$self=shift;Carp::croak "Can't call $meth without object instance" if!ref$self;Carp::croak "Can't inflate Moose metaclass with Moo::sification disabled" if$Moo::sification::disabled;require Moo::HandleMoose;Moo::HandleMoose::inject_real_metaclass_for($self->{name})->$meth(@_)}sub can {my$self=shift;return$self->SUPER::can(@_)if!ref$self or $Moo::sification::disabled;require Moo::HandleMoose;Moo::HandleMoose::inject_real_metaclass_for($self->{name})->can(@_)}sub isa {my$self=shift;return$self->SUPER::isa(@_)if!ref$self or $Moo::sification::disabled;return!!0 if @_==1 && $_[0]eq 'Exception::Class::Base';require Moo::HandleMoose;Moo::HandleMoose::inject_real_metaclass_for($self->{name})->isa(@_)}sub make_immutable {$_[0]}1;
MOO_HANDLEMOOSE_FAKEMETACLASS

$fatpacked{"Moo/HandleMoose/_TypeMap.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOO_HANDLEMOOSE__TYPEMAP';
  package Moo::HandleMoose::_TypeMap;use Moo::_strictures;package Moo::HandleMoose;our%TYPE_MAP;package Moo::HandleMoose::_TypeMap;use Scalar::Util ();use Config ();BEGIN {*_OVERLOAD_ON_REF="$]" < 5.010000 ? sub(){1}: sub(){0}}our%WEAK_TYPES;sub _str_to_ref {my$in=shift;return$in if ref$in;if ($in =~ /(?:^|=)([A-Z]+)\(0x([0-9a-zA-Z]+)\)$/){my$type=$1;my$id=do {no warnings 'portable';hex "$2"};require B;my$sv=bless \$id,'B::SV';my$ref=eval {$sv->object_2svref};if (!defined$ref or Scalar::Util::reftype($ref)ne $type){die <<'END_ERROR'}if (_OVERLOAD_ON_REF and my$class=Scalar::Util::blessed($ref)){bless$ref,$class}return$ref}return$in}sub TIEHASH {bless {},$_[0]}sub STORE {my ($self,$key,$value)=@_;my$type=_str_to_ref($key);$key="$type";$WEAK_TYPES{$key}=$type;Scalar::Util::weaken($WEAK_TYPES{$key})if ref$type;$self->{$key}=$value}sub FETCH {$_[0]->{$_[1]}}sub FIRSTKEY {my$a=scalar keys %{$_[0]};each %{$_[0]}}sub NEXTKEY {each %{$_[0]}}sub EXISTS {exists $_[0]->{$_[1]}}sub DELETE {delete $_[0]->{$_[1]}}sub CLEAR {%{$_[0]}=()}sub SCALAR {scalar %{$_[0]}}sub CLONE {my@types=map {defined$WEAK_TYPES{$_}? ($WEAK_TYPES{$_}=>$TYPE_MAP{$_}): ()}keys%TYPE_MAP;%WEAK_TYPES=();%TYPE_MAP=@types}sub DESTROY {my%types=%{$_[0]};untie%TYPE_MAP;%TYPE_MAP=%types}if ($Config::Config{useithreads}){my@types=%TYPE_MAP;tie%TYPE_MAP,__PACKAGE__;%TYPE_MAP=@types}1;
  Moo initialization encountered types defined in a parent thread - ensure that
  Moo is require()d before any further thread spawns following a type definition.
  END_ERROR
MOO_HANDLEMOOSE__TYPEMAP

$fatpacked{"Moo/Object.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOO_OBJECT';
  package Moo::Object;use Moo::_strictures;use Carp ();our%NO_BUILD;our%NO_DEMOLISH;our$BUILD_MAKER;our$DEMOLISH_MAKER;sub new {my$class=shift;unless (exists$NO_DEMOLISH{$class}){unless ($NO_DEMOLISH{$class}=!$class->can('DEMOLISH')){($DEMOLISH_MAKER ||= do {require Method::Generate::DemolishAll;Method::Generate::DemolishAll->new})->generate_method($class)}}my$proto=$class->BUILDARGS(@_);$NO_BUILD{$class}and return bless({},$class);$NO_BUILD{$class}=!$class->can('BUILD')unless exists$NO_BUILD{$class};$NO_BUILD{$class}? bless({},$class): bless({},$class)->BUILDALL($proto)}sub BUILDARGS {my$class=shift;scalar @_==1 ? ref $_[0]eq 'HASH' ? {%{$_[0]}}: Carp::croak("Single parameters to new() must be a HASH ref" ." data => ".$_[0]): @_ % 2 ? Carp::croak("The new() method for $class expects a hash reference or a" ." key/value list. You passed an odd number of arguments"): {@_}}sub BUILDALL {my$self=shift;$self->${\(($BUILD_MAKER ||= do {require Method::Generate::BuildAll;Method::Generate::BuildAll->new})->generate_method(ref($self)))}(@_)}sub DEMOLISHALL {my$self=shift;$self->${\(($DEMOLISH_MAKER ||= do {require Method::Generate::DemolishAll;Method::Generate::DemolishAll->new})->generate_method(ref($self)))}(@_)}sub does {return!!0 unless ($INC{'Moose/Role.pm'}|| $INC{'Role/Tiny.pm'});require Moo::Role;my$does=Moo::Role->can("does_role");{no warnings 'redefine';*does=$does}goto &$does}sub meta {require Moo::HandleMoose::FakeMetaClass;my$class=ref($_[0])||$_[0];bless({name=>$class },'Moo::HandleMoose::FakeMetaClass')}1;
MOO_OBJECT

$fatpacked{"Moo/Role.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOO_ROLE';
  package Moo::Role;use Moo::_strictures;use Moo::_Utils qw(_check_tracked _getglob _getstash _install_coderef _install_modifier _install_tracked _load_module _name_coderef _set_loaded _unimport_coderefs);use Carp qw(croak);use Role::Tiny ();BEGIN {our@ISA=qw(Role::Tiny)}BEGIN {our@CARP_NOT=qw(Method::Generate::Accessor Method::Generate::Constructor Moo::sification Moo::_Utils)}our$VERSION='2.004000';$VERSION =~ tr/_//d;require Moo::sification;Moo::sification->import;BEGIN {*INFO=\%Role::Tiny::INFO;*APPLIED_TO=\%Role::Tiny::APPLIED_TO;*COMPOSED=\%Role::Tiny::COMPOSED;*ON_ROLE_CREATE=\@Role::Tiny::ON_ROLE_CREATE}our%INFO;our%APPLIED_TO;our%APPLY_DEFAULTS;our%COMPOSED;our@ON_ROLE_CREATE;sub import {my$target=caller;if ($Moo::MAKERS{$target}and $Moo::MAKERS{$target}{is_class}){croak "Cannot import Moo::Role into a Moo class"}_set_loaded(caller);goto&Role::Tiny::import}sub _accessor_maker_for {my ($class,$target)=@_;($INFO{$target}{accessor_maker}||= do {require Method::Generate::Accessor;Method::Generate::Accessor->new})}sub _install_subs {my ($me,$target)=@_;my%install=$me->_gen_subs($target);_install_tracked$target=>$_=>$install{$_}for sort keys%install;*{_getglob("${target}::meta")}=$me->can('meta');return}sub _gen_subs {my ($me,$target)=@_;return (has=>sub {my$name_proto=shift;my@name_proto=ref$name_proto eq 'ARRAY' ? @$name_proto : $name_proto;if (@_ % 2!=0){croak("Invalid options for " .join(', ',map "'$_'",@name_proto)." attribute(s): even number of arguments expected, got " .scalar @_)}my%spec=@_;for my$name (@name_proto){my$spec_ref=@name_proto > 1 ? +{%spec}: \%spec;$me->_accessor_maker_for($target)->generate_method($target,$name,$spec_ref);push @{$INFO{$target}{attributes}||=[]},$name,$spec_ref;$me->_maybe_reset_handlemoose($target)}},(map {my$type=$_;($type=>sub {push @{$INFO{$target}{modifiers}||=[]},[$type=>@_ ];$me->_maybe_reset_handlemoose($target)},)}qw(before after around)),requires=>sub {push @{$INFO{$target}{requires}||=[]},@_;$me->_maybe_reset_handlemoose($target)},with=>sub {$me->apply_roles_to_package($target,@_);$me->_maybe_reset_handlemoose($target)},)}push@ON_ROLE_CREATE,sub {my$target=shift;if ($INC{'Moo/HandleMoose.pm'}&&!$Moo::sification::disabled){Moo::HandleMoose::inject_fake_metaclass_for($target)}};sub meta {require Moo::HandleMoose::FakeMetaClass;my$class=ref($_[0])||$_[0];bless({name=>$class },'Moo::HandleMoose::FakeMetaClass')}sub unimport {my$target=caller;_unimport_coderefs($target)}sub _maybe_reset_handlemoose {my ($class,$target)=@_;if ($INC{'Moo/HandleMoose.pm'}&&!$Moo::sification::disabled){Moo::HandleMoose::maybe_reinject_fake_metaclass_for($target)}}sub _non_methods {my$self=shift;my ($role)=@_;my$non_methods=$self->SUPER::_non_methods(@_);my$all_subs=$self->_all_subs($role);$non_methods->{$_}=$all_subs->{$_}for _check_tracked($role,[keys %$all_subs ]);return$non_methods}sub methods_provided_by {my ($self,$role)=@_;_load_module($role);$self->_inhale_if_moose($role);croak "${role} is not a Moo::Role" unless$self->is_role($role);return$self->SUPER::methods_provided_by($role)}sub is_role {my ($self,$role)=@_;$self->_inhale_if_moose($role);$self->SUPER::is_role($role)}sub _inhale_if_moose {my ($self,$role)=@_;my$meta;if (!$self->SUPER::is_role($role)and ($INC{"Moose.pm"}and $meta=Class::MOP::class_of($role)and ref$meta ne 'Moo::HandleMoose::FakeMetaClass' and $meta->isa('Moose::Meta::Role'))or (Mouse::Util->can('find_meta')and $meta=Mouse::Util::find_meta($role)and $meta->isa('Mouse::Meta::Role'))){my$is_mouse=$meta->isa('Mouse::Meta::Role');$INFO{$role}{methods}={map +($_=>$role->can($_)),grep$role->can($_),grep!($is_mouse && $_ eq 'meta'),grep!$meta->get_method($_)->isa('Class::MOP::Method::Meta'),$meta->get_method_list };$APPLIED_TO{$role}={map +($_->name=>1),$meta->calculate_all_roles };$INFO{$role}{requires}=[$meta->get_required_method_list ];$INFO{$role}{attributes}=[map +($_=>do {my$attr=$meta->get_attribute($_);my$spec={%{$is_mouse ? $attr : $attr->original_options}};if ($spec->{isa}){require Sub::Quote;my$get_constraint=do {my$pkg=$is_mouse ? 'Mouse::Util::TypeConstraints' : 'Moose::Util::TypeConstraints';_load_module($pkg);$pkg->can('find_or_create_isa_type_constraint')};my$tc=$get_constraint->($spec->{isa});my$check=$tc->_compiled_type_constraint;my$tc_var='$_check_for_'.Sub::Quote::sanitize_identifier($tc->name);$spec->{isa}=Sub::Quote::quote_sub(qq{
                &${tc_var} or Carp::croak "Type constraint failed for \$_[0]"
              },{$tc_var=>\$check },{package=>$role,},);if ($spec->{coerce}){$spec->{coerce}=$tc->${\($tc->can('coercion')||sub {$_[0]})}->_compiled_type_coercion}}$spec}),$meta->get_attribute_list ];my$mods=$INFO{$role}{modifiers}=[];for my$type (qw(before after around)){my$map=$meta->${\($meta->can("get_${type}_method_modifiers_map")or sub {shift->{"${type}_method_modifiers"}})};for my$method (keys %$map){for my$mod (@{$map->{$method}}){push @$mods,[$type=>$method=>$mod ]}}}$INFO{$role}{inhaled_from_moose}=1;$INFO{$role}{is_role}=1}}sub _maybe_make_accessors {my ($self,$target,$role)=@_;my$m;if ($INFO{$role}&& $INFO{$role}{inhaled_from_moose}or $INC{"Moo.pm"}and $m=Moo->_accessor_maker_for($target)and ref($m)ne 'Method::Generate::Accessor'){$self->_make_accessors($target,$role)}}sub _make_accessors_if_moose {my ($self,$target,$role)=@_;if ($INFO{$role}&& $INFO{$role}{inhaled_from_moose}){$self->_make_accessors($target,$role)}}sub _make_accessors {my ($self,$target,$role)=@_;my$acc_gen=($Moo::MAKERS{$target}{accessor}||= do {require Method::Generate::Accessor;Method::Generate::Accessor->new});my$con_gen=$Moo::MAKERS{$target}{constructor};my@attrs=@{$INFO{$role}{attributes}||[]};while (my ($name,$spec)=splice@attrs,0,2){if ($con_gen){$spec=$con_gen->all_attribute_specs->{$name}}$acc_gen->generate_method($target,$name,$spec)}}sub _undefer_subs {my ($self,$target,$role)=@_;if ($INC{'Sub/Defer.pm'}){Sub::Defer::undefer_package($role)}}sub role_application_steps {qw(_handle_constructor _undefer_subs _maybe_make_accessors),$_[0]->SUPER::role_application_steps}sub apply_roles_to_package {my ($me,$to,@roles)=@_;for my$role (@roles){_load_module($role);$me->_inhale_if_moose($role);croak "${role} is not a Moo::Role" unless$me->is_role($role)}$me->SUPER::apply_roles_to_package($to,@roles)}sub apply_single_role_to_package {my ($me,$to,$role)=@_;_load_module($role);$me->_inhale_if_moose($role);croak "${role} is not a Moo::Role" unless$me->is_role($role);$me->SUPER::apply_single_role_to_package($to,$role)}sub create_class_with_roles {my ($me,$superclass,@roles)=@_;my ($new_name,$compose_name)=$me->_composite_name($superclass,@roles);return$new_name if$COMPOSED{class}{$new_name};for my$role (@roles){_load_module($role);$me->_inhale_if_moose($role);croak "${role} is not a Moo::Role" unless$me->is_role($role)}my$m;if ($INC{"Moo.pm"}and $m=Moo->_accessor_maker_for($superclass)and ref($m)ne 'Method::Generate::Accessor'){@{*{_getglob("${new_name}::ISA")}{ARRAY}}=($superclass);$Moo::MAKERS{$new_name}={is_class=>1};$me->apply_roles_to_package($new_name,@roles)}else {$me->SUPER::create_class_with_roles($superclass,@roles);$Moo::MAKERS{$new_name}={is_class=>1};$me->_handle_constructor($new_name,$_)for@roles}if ($INC{'Moo/HandleMoose.pm'}&&!$Moo::sification::disabled){Moo::HandleMoose::inject_fake_metaclass_for($new_name)}$COMPOSED{class}{$new_name}=1;_set_loaded($new_name,(caller)[1]);return$new_name}sub apply_roles_to_object {my ($me,$object,@roles)=@_;my$new=$me->SUPER::apply_roles_to_object($object,@roles);my$class=ref$new;_set_loaded($class,(caller)[1]);my$apply_defaults=exists$APPLY_DEFAULTS{$class}? $APPLY_DEFAULTS{$class}: $APPLY_DEFAULTS{$class}=do {my%attrs=map {@{$INFO{$_}{attributes}||[]}}@roles;if ($INC{'Moo.pm'}and keys%attrs and my$con_gen=Moo->_constructor_maker_for($class)and my$m=Moo->_accessor_maker_for($class)){my$specs=$con_gen->all_attribute_specs;my%captures;my$code=join('',(map {my$name=$_;my$spec=$specs->{$name};if ($m->has_eager_default($name,$spec)){my ($has,$has_cap)=$m->generate_simple_has('$_[0]',$name,$spec);my ($set,$pop_cap)=$m->generate_use_default('$_[0]',$name,$spec,$has);@captures{keys %$has_cap,keys %$pop_cap}=(values %$has_cap,values %$pop_cap);"($set),"}else {()}}sort keys%attrs),);if ($code){require Sub::Quote;Sub::Quote::quote_sub("${class}::_apply_defaults","no warnings 'void';\n$code",\%captures,{package=>$class,no_install=>1,})}else {0}}else {0}};if ($apply_defaults){local$Carp::Internal{+__PACKAGE__}=1;local$Carp::Internal{$class}=1;$new->$apply_defaults}return$new}sub _composable_package_for {my ($self,$role)=@_;my$composed_name='Role::Tiny::_COMPOSABLE::'.$role;return$composed_name if$COMPOSED{role}{$composed_name};$self->_make_accessors_if_moose($composed_name,$role);$self->SUPER::_composable_package_for($role)}sub _install_single_modifier {my ($me,@args)=@_;_install_modifier(@args)}sub _install_does {my ($me,$to)=@_;my$new=$me->SUPER::_install_does($to)or return;return _name_coderef("${to}::DOES",$new)}sub does_role {my ($proto,$role)=@_;return 1 if Role::Tiny::does_role($proto,$role);my$meta;if ($INC{'Moose.pm'}and $meta=Class::MOP::class_of($proto)and ref$meta ne 'Moo::HandleMoose::FakeMetaClass' and $meta->can('does_role')){return$meta->does_role($role)}return 0}sub _handle_constructor {my ($me,$to,$role)=@_;my$attr_info=$INFO{$role}&& $INFO{$role}{attributes};return unless$attr_info && @$attr_info;my$info=$INFO{$to};my$con=$INC{"Moo.pm"}&& Moo->_constructor_maker_for($to);my%existing =$info ? @{$info->{attributes}|| []}: $con ? %{$con->all_attribute_specs || {}}: ();my@attr_info=map {@{$attr_info}[$_,$_+1]}grep {!$existing{$attr_info->[$_]}}map {2 * $_}0..@$attr_info/2-1;if ($info){push @{$info->{attributes}||=[]},@attr_info}elsif ($con){$con->register_attribute_specs(map ref()? {%$_ }: $_,@attr_info)}}1;
MOO_ROLE

$fatpacked{"Moo/_Utils.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOO__UTILS';
  package Moo::_Utils;use Moo::_strictures;{no strict 'refs';sub _getglob {\*{$_[0]}}sub _getstash {\%{"$_[0]::"}}}BEGIN {my ($su,$sn);$su=$INC{'Sub/Util.pm'}&& defined&Sub::Util::set_subname or $sn=$INC{'Sub/Name.pm'}or $su=eval {require Sub::Util}&& defined&Sub::Util::set_subname or $sn=eval {require Sub::Name};*_subname=$su ? \&Sub::Util::set_subname : $sn ? \&Sub::Name::subname : sub {$_[1]};*_CAN_SUBNAME=($su || $sn)? sub(){1}: sub(){0}}use Module::Runtime qw(use_package_optimistically module_notional_filename);use Exporter qw(import);use Config;use Scalar::Util qw(weaken);use Carp qw(croak);our@EXPORT=qw(_install_coderef _load_module);our@EXPORT_OK=qw(_check_tracked _getglob _getstash _install_coderef _install_modifier _install_tracked _load_module _maybe_load_module _name_coderef _set_loaded _unimport_coderefs);my%EXPORTS;sub _install_modifier {my$target=$_[0];my$type=$_[1];my$code=$_[-1];my@names=@_[2 .. $#_ - 1];@names=@{$names[0]}if ref($names[0])eq 'ARRAY';my@tracked=_check_tracked($target,\@names);if ($INC{'Sub/Defer.pm'}){for my$name (@names){if (my$to_modify=$target->can($name)){Sub::Defer::undefer_sub($to_modify)}}}require Class::Method::Modifiers;Class::Method::Modifiers::install_modifier(@_);if (@tracked){my$exports=$EXPORTS{$target};weaken($exports->{$_}=$target->can($_))for@tracked}return}sub _install_tracked {my ($target,$name,$code)=@_;my$from=caller;weaken($EXPORTS{$target}{$name}=$code);_install_coderef("${target}::${name}","${from}::${name}",$code)}sub _load_module {my$module=$_[0];my$file=eval {module_notional_filename($module)}or croak $@;use_package_optimistically($module);return 1 if$INC{$file};my$error=$@ || "Can't locate $file";my$stash=_getstash($module)||{};return 1 if grep +(ref($_)|| *$_{CODE}),values %$stash;return 1 if$INC{"Moose.pm"}&& Class::MOP::class_of($module)or Mouse::Util->can('find_meta')&& Mouse::Util::find_meta($module);croak$error}our%MAYBE_LOADED;sub _maybe_load_module {my$module=$_[0];return$MAYBE_LOADED{$module}if exists$MAYBE_LOADED{$module};if(!eval {use_package_optimistically($module)}){warn "$module exists but failed to load with error: $@"}elsif ($INC{module_notional_filename($module)}){return$MAYBE_LOADED{$module}=1}return$MAYBE_LOADED{$module}=0}sub _set_loaded {$INC{Module::Runtime::module_notional_filename($_[0])}||= $_[1]}sub _install_coderef {my ($glob,$code)=(_getglob($_[0]),_name_coderef(@_));no warnings 'redefine';if (*{$glob}{CODE}){*{$glob}=$code}else {no warnings 'prototype';*{$glob}=$code}}sub _name_coderef {shift if @_ > 2;_CAN_SUBNAME ? _subname(@_): $_[1]}sub _check_tracked {my ($target,$names)=@_;my$stash=_getstash($target);my$exports=$EXPORTS{$target}or return;$names=[keys %$exports]if!$names;my%rev=map +($exports->{$_}=>$_),grep defined$exports->{$_},keys %$exports;return grep {my$g=$stash->{$_};$g && defined &$g && exists$rev{\&$g}}@$names}sub _unimport_coderefs {my ($target)=@_;my$stash=_getstash($target);my@exports=_check_tracked($target);for my$name (@exports){my$old=delete$stash->{$name};my$full_name=join('::',$target,$name);for my$type (qw(SCALAR HASH ARRAY IO)){next unless defined(*{$old}{$type});no strict 'refs';*$full_name=*{$old}{$type}}}}if ($Config{useithreads}){require Moo::HandleMoose::_TypeMap}1;
MOO__UTILS

$fatpacked{"Moo/_mro.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOO__MRO';
  package Moo::_mro;use Moo::_strictures;if ("$]" >= 5.010_000){require mro}else {require MRO::Compat}1;
MOO__MRO

$fatpacked{"Moo/_strictures.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOO__STRICTURES';
  package Moo::_strictures;use strict;use warnings;sub import {if ($ENV{MOO_FATAL_WARNINGS}){require strictures;strictures->VERSION(2);@_=('strictures');goto&strictures::import}else {strict->import;warnings->import;warnings->unimport('once')}}1;
MOO__STRICTURES

$fatpacked{"Moo/sification.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOO_SIFICATION';
  package Moo::sification;use Moo::_strictures;no warnings 'once';BEGIN {*_USE_DGD="$]" < 5.014 ? sub(){1}: sub(){0};require Devel::GlobalDestruction if _USE_DGD()}use Carp qw(croak);BEGIN {our@CARP_NOT=qw(Moo::HandleMoose)}sub unimport {croak "Can't disable Moo::sification after inflation has been done" if$Moo::HandleMoose::SETUP_DONE;our$disabled=1}sub Moo::HandleMoose::AuthorityHack::DESTROY {unless (our$disabled or _USE_DGD ? Devel::GlobalDestruction::in_global_destruction(): ${^GLOBAL_PHASE} eq 'DESTRUCT'){require Moo::HandleMoose;Moo::HandleMoose->import}}sub import {return if our$setup_done;if ($INC{"Moose.pm"}){require Moo::HandleMoose;Moo::HandleMoose->import}else {$Moose::AUTHORITY=bless({},'Moo::HandleMoose::AuthorityHack')}$setup_done=1}1;
MOO_SIFICATION

$fatpacked{"Package/Stash.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PACKAGE_STASH';
  package Package::Stash;use strict;use warnings;use 5.008001;our$VERSION='0.38';our$IMPLEMENTATION;use Module::Implementation 0.06;BEGIN {local$ENV{PACKAGE_STASH_IMPLEMENTATION}=$IMPLEMENTATION if ($IMPLEMENTATION and not $ENV{PACKAGE_STASH_IMPLEMENTATION});Module::Implementation::build_loader_sub(implementations=>['XS','PP' ],symbols=>[qw(new name namespace add_symbol remove_glob has_symbol get_symbol get_or_add_symbol remove_symbol list_all_symbols get_all_symbols)],)->();$IMPLEMENTATION=Module::Implementation::implementation_for(__PACKAGE__)}1;
PACKAGE_STASH

$fatpacked{"Package/Stash/Conflicts.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PACKAGE_STASH_CONFLICTS';
  package Package::Stash::Conflicts;use strict;use warnings;use Dist::CheckConflicts -dist=>'Package::Stash',-conflicts=>{'Class::MOP'=>'1.08','MooseX::Method::Signatures'=>'0.36','MooseX::Role::WithOverloading'=>'0.08','namespace::clean'=>'0.18',},-also=>[qw(B Carp Dist::CheckConflicts Getopt::Long Module::Implementation Scalar::Util Symbol constant strict warnings) ],;1;
PACKAGE_STASH_CONFLICTS

$fatpacked{"Package/Stash/PP.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PACKAGE_STASH_PP';
  package Package::Stash::PP;use strict;use warnings;our$VERSION='0.38';use B;use Carp qw(confess);use Scalar::Util qw(blessed reftype weaken);use Symbol;use constant BROKEN_ISA_ASSIGNMENT=>($] < 5.012);use constant BROKEN_WEAK_STASH=>($] < 5.010);use constant BROKEN_SCALAR_INITIALIZATION=>($] < 5.010);use constant BROKEN_GLOB_ASSIGNMENT=>($] < 5.013004);use constant HAS_ISA_CACHE=>($] < 5.010);sub new {my$class=shift;my ($package)=@_;if (!defined($package)|| (ref($package)&& reftype($package)ne 'HASH')){confess "Package::Stash->new must be passed the name of the " ."package to access"}elsif (ref($package)&& reftype($package)eq 'HASH'){confess "The PP implementation of Package::Stash does not support " ."anonymous stashes before perl 5.14" if BROKEN_GLOB_ASSIGNMENT;return bless {'namespace'=>$package,},$class}elsif ($package =~ /\A[0-9A-Z_a-z]+(?:::[0-9A-Z_a-z]+)*\z/){return bless {'package'=>$package,},$class}else {confess "$package is not a module name"}}sub name {confess "Can't call name as a class method" unless blessed($_[0]);confess "Can't get the name of an anonymous package" unless defined($_[0]->{package});return $_[0]->{package}}sub namespace {confess "Can't call namespace as a class method" unless blessed($_[0]);if (BROKEN_WEAK_STASH){no strict 'refs';return \%{$_[0]->name .'::'}}else {return $_[0]->{namespace}if defined $_[0]->{namespace};{no strict 'refs';$_[0]->{namespace}=\%{$_[0]->name .'::'}}weaken($_[0]->{namespace});return $_[0]->{namespace}}}{my%SIGIL_MAP=('$'=>'SCALAR','@'=>'ARRAY','%'=>'HASH','&'=>'CODE',''=>'IO',);sub _deconstruct_variable_name {my ($variable)=@_;my@ret;if (ref($variable)eq 'HASH'){@ret=@{$variable}{qw[name sigil type]}}else {(defined$variable && length$variable)|| confess "You must pass a variable name";my$sigil=substr($variable,0,1,'');if (exists$SIGIL_MAP{$sigil}){@ret=($variable,$sigil,$SIGIL_MAP{$sigil})}else {@ret=("${sigil}${variable}",'',$SIGIL_MAP{''})}}($ret[0]!~ /::/)|| confess "Variable names may not contain ::";return@ret}}sub _valid_for_type {my ($value,$type)=@_;if ($type eq 'HASH' || $type eq 'ARRAY' || $type eq 'IO' || $type eq 'CODE'){return reftype($value)eq $type}else {my$ref=reftype($value);return!defined($ref)|| $ref eq 'SCALAR' || $ref eq 'REF' || $ref eq 'LVALUE' || $ref eq 'REGEXP' || $ref eq 'VSTRING'}}sub add_symbol {my ($self,$variable,$initial_value,%opts)=@_;my ($name,$sigil,$type)=_deconstruct_variable_name($variable);if (@_ > 2){_valid_for_type($initial_value,$type)|| confess "$initial_value is not of type $type";if ($^P and $^P & 0x10 && $sigil eq '&'){my$filename=$opts{filename};my$first_line_num=$opts{first_line_num};(undef,$filename,$first_line_num)=caller if not defined$filename;my$last_line_num=$opts{last_line_num}|| ($first_line_num ||= 0);$DB::sub{$self->name .'::' .$name}="$filename:$first_line_num-$last_line_num"}}if (BROKEN_GLOB_ASSIGNMENT){if (@_ > 2){no strict 'refs';no warnings 'redefine';*{$self->name .'::' .$name}=ref$initial_value ? $initial_value : \$initial_value}else {no strict 'refs';if (BROKEN_ISA_ASSIGNMENT && $name eq 'ISA'){*{$self->name .'::' .$name}}else {my$undef=_undef_ref_for_type($type);*{$self->name .'::' .$name}=$undef}}}else {my$namespace=$self->namespace;{local*__ANON__::=$namespace;no strict 'refs';no warnings 'void';no warnings 'once';*{"__ANON__::$name"}}if (@_ > 2){no warnings 'redefine';*{$namespace->{$name}}=ref$initial_value ? $initial_value : \$initial_value}else {return if BROKEN_ISA_ASSIGNMENT && $name eq 'ISA';*{$namespace->{$name}}=_undef_ref_for_type($type)}}}sub _undef_ref_for_type {my ($type)=@_;if ($type eq 'ARRAY'){return []}elsif ($type eq 'HASH'){return {}}elsif ($type eq 'SCALAR'){return \undef}elsif ($type eq 'IO'){return Symbol::geniosym}elsif ($type eq 'CODE'){confess "Don't know how to vivify CODE variables"}else {confess "Unknown type $type in vivication"}}sub remove_glob {my ($self,$name)=@_;delete$self->namespace->{$name}}sub has_symbol {my ($self,$variable)=@_;my ($name,$sigil,$type)=_deconstruct_variable_name($variable);my$namespace=$self->namespace;return unless exists$namespace->{$name};my$entry_ref=\$namespace->{$name};if (reftype($entry_ref)eq 'GLOB'){if ($type eq 'SCALAR'){if (BROKEN_SCALAR_INITIALIZATION){return defined ${*{$entry_ref}{$type}}}else {my$sv=B::svref_2object($entry_ref)->SV;return$sv->isa('B::SV')|| ($sv->isa('B::SPECIAL')&& $B::specialsv_name[$$sv]ne 'Nullsv')}}else {return defined *{$entry_ref}{$type}}}else {return$type eq 'CODE'}}sub get_symbol {my ($self,$variable,%opts)=@_;my ($name,$sigil,$type)=_deconstruct_variable_name($variable);my$namespace=$self->namespace;if (!exists$namespace->{$name}){if ($opts{vivify}){$self->add_symbol($variable)}else {return undef}}my$entry_ref=\$namespace->{$name};if (ref($entry_ref)eq 'GLOB'){return *{$entry_ref}{$type}}else {if ($type eq 'CODE'){if (BROKEN_GLOB_ASSIGNMENT || defined($self->{package})){no strict 'refs';return \&{$self->name .'::' .$name}}if (blessed($namespace)&& $namespace->isa('Package::Anon')){$namespace->bless(\(my$foo))->can($name)}else {confess "Don't know how to inflate a " .ref($entry_ref)." into a full coderef (perhaps you could use" ." Package::Anon instead of a bare stash?)"}return *{$namespace->{$name}}{CODE}}else {return undef}}}sub get_or_add_symbol {my$self=shift;$self->get_symbol(@_,vivify=>1)}sub remove_symbol {my ($self,$variable)=@_;my ($name,$sigil,$type)=_deconstruct_variable_name($variable);my%desc=(SCALAR=>{sigil=>'$',type=>'SCALAR',name=>$name },ARRAY=>{sigil=>'@',type=>'ARRAY',name=>$name },HASH=>{sigil=>'%',type=>'HASH',name=>$name },CODE=>{sigil=>'&',type=>'CODE',name=>$name },IO=>{sigil=>'',type=>'IO',name=>$name },);confess "This should never ever ever happen" if!$desc{$type};my@types_to_store=grep {$type ne $_ && $self->has_symbol($desc{$_})}keys%desc;my%values=map {$_,$self->get_symbol($desc{$_})}@types_to_store;$values{SCALAR}=$self->get_symbol($desc{SCALAR})if!defined$values{SCALAR}&& $type ne 'SCALAR' && BROKEN_SCALAR_INITIALIZATION;$self->remove_glob($name);$self->add_symbol($desc{$_}=>$values{$_})for grep {defined$values{$_}}keys%values}sub list_all_symbols {my ($self,$type_filter)=@_;my$namespace=$self->namespace;if (HAS_ISA_CACHE){return grep {$_ ne '::ISA::CACHE::'}keys %{$namespace}unless defined$type_filter}else {return keys %{$namespace}unless defined$type_filter}if ($type_filter eq 'CODE'){return grep {ref(\$namespace->{$_})ne 'GLOB' || defined(*{$namespace->{$_}}{CODE})}keys %{$namespace}}elsif ($type_filter eq 'SCALAR'){return grep {!(HAS_ISA_CACHE && $_ eq '::ISA::CACHE::')&& (BROKEN_SCALAR_INITIALIZATION ? (ref(\$namespace->{$_})eq 'GLOB' && defined(${*{$namespace->{$_}}{'SCALAR'}})): (do {my$entry=\$namespace->{$_};ref($entry)eq 'GLOB' && B::svref_2object($entry)->SV->isa('B::SV')}))}keys %{$namespace}}else {return grep {ref(\$namespace->{$_})eq 'GLOB' && defined(*{$namespace->{$_}}{$type_filter})}keys %{$namespace}}}sub get_all_symbols {my ($self,$type_filter)=@_;my$namespace=$self->namespace;return {%{$namespace}}unless defined$type_filter;return {map {$_=>$self->get_symbol({name=>$_,type=>$type_filter})}$self->list_all_symbols($type_filter)}}1;
PACKAGE_STASH_PP

$fatpacked{"Params/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PARAMS_UTIL';
  package Params::Util;use 5.00503;use strict;require overload;require Exporter;require Scalar::Util;require DynaLoader;use vars qw{$VERSION @ISA @EXPORT_OK %EXPORT_TAGS};$VERSION='1.07';@ISA=qw{Exporter DynaLoader};@EXPORT_OK=qw{_STRING _IDENTIFIER _CLASS _CLASSISA _SUBCLASS _DRIVER _CLASSDOES _NUMBER _POSINT _NONNEGINT _SCALAR _SCALAR0 _ARRAY _ARRAY0 _ARRAYLIKE _HASH _HASH0 _HASHLIKE _CODE _CODELIKE _INVOCANT _REGEX _INSTANCE _INSTANCEDOES _SET _SET0 _HANDLE};%EXPORT_TAGS=(ALL=>\@EXPORT_OK);eval {local$ENV{PERL_DL_NONLAZY}=0 if$ENV{PERL_DL_NONLAZY};bootstrap Params::Util$VERSION;1}unless$ENV{PERL_PARAMS_UTIL_PP};my$SU=eval "$Scalar::Util::VERSION" || 0;if ($SU >= 1.18){Scalar::Util->import('looks_like_number')}else {eval <<'END_PERL'}eval <<'END_PERL' unless defined&_STRING;eval <<'END_PERL' unless defined&_IDENTIFIER;eval <<'END_PERL' unless defined&_CLASS;eval <<'END_PERL' unless defined&_CLASSISA;eval <<'END_PERL' unless defined&_CLASSDOES;eval <<'END_PERL' unless defined&_SUBCLASS;eval <<'END_PERL' unless defined&_NUMBER;eval <<'END_PERL' unless defined&_POSINT;eval <<'END_PERL' unless defined&_NONNEGINT;eval <<'END_PERL' unless defined&_SCALAR;eval <<'END_PERL' unless defined&_SCALAR0;eval <<'END_PERL' unless defined&_ARRAY;eval <<'END_PERL' unless defined&_ARRAY0;eval <<'END_PERL' unless defined&_ARRAYLIKE;eval <<'END_PERL' unless defined&_HASH;eval <<'END_PERL' unless defined&_HASH0;eval <<'END_PERL' unless defined&_HASHLIKE;eval <<'END_PERL' unless defined&_CODE;eval <<'END_PERL' unless defined&_CODELIKE;eval <<'END_PERL' unless defined&_INVOCANT;eval <<'END_PERL' unless defined&_INSTANCE;eval <<'END_PERL' unless defined&_INSTANCEDOES;eval <<'END_PERL' unless defined&_REGEX;eval <<'END_PERL' unless defined&_SET;eval <<'END_PERL' unless defined&_SET0;eval <<'END_PERL' unless defined&_HANDLE;eval <<'END_PERL' unless defined&_DRIVER;1;
  sub looks_like_number {
  	local $_ = shift;
  
  	# checks from perlfaq4
  	return 0 if !defined($_);
  	if (ref($_)) {
  		return overload::Overloaded($_) ? defined(0 + $_) : 0;
  	}
  	return 1 if (/^[+-]?[0-9]+$/); # is a +/- integer
  	return 1 if (/^([+-]?)(?=[0-9]|\.[0-9])[0-9]*(\.[0-9]*)?([Ee]([+-]?[0-9]+))?$/); # a C float
  	return 1 if ($] >= 5.008 and /^(Inf(inity)?|NaN)$/i) or ($] >= 5.006001 and /^Inf$/i);
  
  	0;
  }
  END_PERL
  sub _STRING ($) {
  	(defined $_[0] and ! ref $_[0] and length($_[0])) ? $_[0] : undef;
  }
  END_PERL
  sub _IDENTIFIER ($) {
  	(defined $_[0] and ! ref $_[0] and $_[0] =~ m/^[^\W\d]\w*\z/s) ? $_[0] : undef;
  }
  END_PERL
  sub _CLASS ($) {
  	(defined $_[0] and ! ref $_[0] and $_[0] =~ m/^[^\W\d]\w*(?:::\w+)*\z/s) ? $_[0] : undef;
  }
  END_PERL
  sub _CLASSISA ($$) {
  	(defined $_[0] and ! ref $_[0] and $_[0] =~ m/^[^\W\d]\w*(?:::\w+)*\z/s and $_[0]->isa($_[1])) ? $_[0] : undef;
  }
  END_PERL
  sub _CLASSDOES ($$) {
  	(defined $_[0] and ! ref $_[0] and $_[0] =~ m/^[^\W\d]\w*(?:::\w+)*\z/s and $_[0]->DOES($_[1])) ? $_[0] : undef;
  }
  END_PERL
  sub _SUBCLASS ($$) {
  	(defined $_[0] and ! ref $_[0] and $_[0] =~ m/^[^\W\d]\w*(?:::\w+)*\z/s and $_[0] ne $_[1] and $_[0]->isa($_[1])) ? $_[0] : undef;
  }
  END_PERL
  sub _NUMBER ($) {
  	( defined $_[0] and ! ref $_[0] and looks_like_number($_[0]) )
  	? $_[0]
  	: undef;
  }
  END_PERL
  sub _POSINT ($) {
  	(defined $_[0] and ! ref $_[0] and $_[0] =~ m/^[1-9]\d*$/) ? $_[0] : undef;
  }
  END_PERL
  sub _NONNEGINT ($) {
  	(defined $_[0] and ! ref $_[0] and $_[0] =~ m/^(?:0|[1-9]\d*)$/) ? $_[0] : undef;
  }
  END_PERL
  sub _SCALAR ($) {
  	(ref $_[0] eq 'SCALAR' and defined ${$_[0]} and ${$_[0]} ne '') ? $_[0] : undef;
  }
  END_PERL
  sub _SCALAR0 ($) {
  	ref $_[0] eq 'SCALAR' ? $_[0] : undef;
  }
  END_PERL
  sub _ARRAY ($) {
  	(ref $_[0] eq 'ARRAY' and @{$_[0]}) ? $_[0] : undef;
  }
  END_PERL
  sub _ARRAY0 ($) {
  	ref $_[0] eq 'ARRAY' ? $_[0] : undef;
  }
  END_PERL
  sub _ARRAYLIKE {
  	(defined $_[0] and ref $_[0] and (
  		(Scalar::Util::reftype($_[0]) eq 'ARRAY')
  		or
  		overload::Method($_[0], '@{}')
  	)) ? $_[0] : undef;
  }
  END_PERL
  sub _HASH ($) {
  	(ref $_[0] eq 'HASH' and scalar %{$_[0]}) ? $_[0] : undef;
  }
  END_PERL
  sub _HASH0 ($) {
  	ref $_[0] eq 'HASH' ? $_[0] : undef;
  }
  END_PERL
  sub _HASHLIKE {
  	(defined $_[0] and ref $_[0] and (
  		(Scalar::Util::reftype($_[0]) eq 'HASH')
  		or
  		overload::Method($_[0], '%{}')
  	)) ? $_[0] : undef;
  }
  END_PERL
  sub _CODE ($) {
  	ref $_[0] eq 'CODE' ? $_[0] : undef;
  }
  END_PERL
  sub _CODELIKE($) {
  	(
  		(Scalar::Util::reftype($_[0])||'') eq 'CODE'
  		or
  		Scalar::Util::blessed($_[0]) and overload::Method($_[0],'&{}')
  	)
  	? $_[0] : undef;
  }
  END_PERL
  sub _INVOCANT($) {
  	(defined $_[0] and
  		(defined Scalar::Util::blessed($_[0])
  		or      
  		# We used to check for stash definedness, but any class-like name is a
  		# valid invocant for UNIVERSAL methods, so we stopped. -- rjbs, 2006-07-02
  		Params::Util::_CLASS($_[0]))
  	) ? $_[0] : undef;
  }
  END_PERL
  sub _INSTANCE ($$) {
  	(Scalar::Util::blessed($_[0]) and $_[0]->isa($_[1])) ? $_[0] : undef;
  }
  END_PERL
  sub _INSTANCEDOES ($$) {
  	(Scalar::Util::blessed($_[0]) and $_[0]->DOES($_[1])) ? $_[0] : undef;
  }
  END_PERL
  sub _REGEX ($) {
  	(defined $_[0] and 'Regexp' eq ref($_[0])) ? $_[0] : undef;
  }
  END_PERL
  sub _SET ($$) {
  	my $set = shift;
  	_ARRAY($set) or return undef;
  	foreach my $item ( @$set ) {
  		_INSTANCE($item,$_[0]) or return undef;
  	}
  	$set;
  }
  END_PERL
  sub _SET0 ($$) {
  	my $set = shift;
  	_ARRAY0($set) or return undef;
  	foreach my $item ( @$set ) {
  		_INSTANCE($item,$_[0]) or return undef;
  	}
  	$set;
  }
  END_PERL
  sub _HANDLE {
  	my $it = shift;
  
  	# It has to be defined, of course
  	unless ( defined $it ) {
  		return undef;
  	}
  
  	# Normal globs are considered to be file handles
  	if ( ref $it eq 'GLOB' ) {
  		return $it;
  	}
  
  	# Check for a normal tied filehandle
  	# Side Note: 5.5.4's tied() and can() doesn't like getting undef
  	if ( tied($it) and tied($it)->can('TIEHANDLE') ) {
  		return $it;
  	}
  
  	# There are no other non-object handles that we support
  	unless ( Scalar::Util::blessed($it) ) {
  		return undef;
  	}
  
  	# Check for a common base classes for conventional IO::Handle object
  	if ( $it->isa('IO::Handle') ) {
  		return $it;
  	}
  
  
  	# Check for tied file handles using Tie::Handle
  	if ( $it->isa('Tie::Handle') ) {
  		return $it;
  	}
  
  	# IO::Scalar is not a proper seekable, but it is valid is a
  	# regular file handle
  	if ( $it->isa('IO::Scalar') ) {
  		return $it;
  	}
  
  	# Yet another special case for IO::String, which refuses (for now
  	# anyway) to become a subclass of IO::Handle.
  	if ( $it->isa('IO::String') ) {
  		return $it;
  	}
  
  	# This is not any sort of object we know about
  	return undef;
  }
  END_PERL
  sub _DRIVER ($$) {
  	(defined _CLASS($_[0]) and eval "require $_[0];" and ! $@ and $_[0]->isa($_[1]) and $_[0] ne $_[1]) ? $_[0] : undef;
  }
  END_PERL
PARAMS_UTIL

$fatpacked{"Params/Validate.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PARAMS_VALIDATE';
  package Params::Validate;use 5.008001;use strict;use warnings;our$VERSION='1.29';use Exporter;use Module::Implementation;use Params::Validate::Constants;use vars qw($NO_VALIDATION %OPTIONS $options);our@ISA='Exporter';my@types=qw(SCALAR ARRAYREF HASHREF CODEREF GLOB GLOBREF SCALARREF HANDLE BOOLEAN UNDEF OBJECT);our%EXPORT_TAGS=('all'=>[qw(validate validate_pos validation_options validate_with),@types ],types=>\@types,);our@EXPORT_OK=(@{$EXPORT_TAGS{all}},'set_options');our@EXPORT=qw(validate validate_pos);$NO_VALIDATION=$ENV{PERL_NO_VALIDATION};{my$loader=Module::Implementation::build_loader_sub(implementations=>['XS','PP' ],symbols=>[qw(validate validate_pos validate_with validation_options set_options),],);$ENV{PARAMS_VALIDATE_IMPLEMENTATION}='PP' if$ENV{PV_TEST_PERL};$loader->()}1;
PARAMS_VALIDATE

$fatpacked{"Params/Validate/Constants.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PARAMS_VALIDATE_CONSTANTS';
  package Params::Validate::Constants;use strict;use warnings;our$VERSION='1.29';our@ISA='Exporter';our@EXPORT=qw(SCALAR ARRAYREF HASHREF CODEREF GLOB GLOBREF SCALARREF HANDLE BOOLEAN UNDEF OBJECT UNKNOWN);sub SCALAR () {1}sub ARRAYREF () {2}sub HASHREF () {4}sub CODEREF () {8}sub GLOB () {16}sub GLOBREF () {32}sub SCALARREF () {64}sub UNKNOWN () {128}sub UNDEF () {256}sub OBJECT () {512}sub HANDLE () {16 | 32}sub BOOLEAN () {1 | 256}1;
PARAMS_VALIDATE_CONSTANTS

$fatpacked{"Params/Validate/PP.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PARAMS_VALIDATE_PP';
  package Params::Validate::PP;use strict;use warnings;our$VERSION='1.29';use Params::Validate::Constants;use Scalar::Util 1.10 ();our$options;sub validate_pos (\@@) {return if$Params::Validate::NO_VALIDATION &&!defined wantarray;my$p=shift;my@specs=@_;my@p=@$p;if ($Params::Validate::NO_VALIDATION){for (my$x=$#p + 1;$x <= $#specs;$x++ ){$p[$x]=$specs[$x]->{default}if ref$specs[$x]&& exists$specs[$x]->{default}}return wantarray ? @p : \@p}local$options ||= _get_options((caller(0))[0])unless defined$options;my$min=0;while (1){last unless (ref$specs[$min]?!(exists$specs[$min]->{default}|| $specs[$min]->{optional}): $specs[$min]);$min++}my$max=scalar@specs;my$actual=scalar@p;unless ($actual >= $min && ($options->{allow_extra}|| $actual <= $max)){my$minmax=($options->{allow_extra}? "at least $min" : ($min!=$max ? "$min - $max" : $max));my$val=$options->{allow_extra}? $min : $max;$minmax .= $val!=1 ? ' were' : ' was';my$called=_get_called();$options->{on_fail}->("$actual parameter" .($actual!=1 ? 's' : '')." " .($actual!=1 ? 'were' : 'was')." passed to $called but $minmax expected\n")}my$bigger=$#p > $#specs ? $#p : $#specs;for (0 .. $bigger){my$spec=$specs[$_];next unless ref$spec;if ($_ <= $#p){_validate_one_param($p[$_],\@p,$spec,'Parameter #' .($_ + 1).' (%s)')}$p[$_]=$spec->{default}if $_ > $#p && exists$spec->{default}}_validate_pos_depends(\@p,\@specs);for (grep {defined$p[$_]&&!ref$p[$_]&& ref$specs[$_]&& $specs[$_]{untaint}}0 .. $bigger){($p[$_])=$p[$_]=~ /(.+)/}return wantarray ? @p : \@p}sub _validate_pos_depends {my ($p,$specs)=@_;for my$p_idx (0 .. $#$p){my$spec=$specs->[$p_idx];next unless$spec && UNIVERSAL::isa($spec,'HASH')&& exists$spec->{depends};my$depends=$spec->{depends};if (ref$depends){require Carp;local$Carp::CarpLevel=2;Carp::croak("Arguments to 'depends' for validate_pos() must be a scalar")}my$p_size=scalar @$p;if ($p_size < $depends - 1){my$error =("Parameter #" .($p_idx + 1)." depends on parameter #" .$depends .", which was not given");$options->{on_fail}->($error)}}return 1}sub _validate_named_depends {my ($p,$specs)=@_;for my$pname (keys %$p){my$spec=$specs->{$pname};next unless$spec && UNIVERSAL::isa($spec,'HASH')&& $spec->{depends};unless (UNIVERSAL::isa($spec->{depends},'ARRAY')||!ref$spec->{depends}){require Carp;local$Carp::CarpLevel=2;Carp::croak("Arguments to 'depends' must be a scalar or arrayref")}for my$depends_name (ref$spec->{depends}? @{$spec->{depends}}: $spec->{depends}){unless (exists$p->{$depends_name}){my$error =("Parameter '$pname' depends on parameter '" .$depends_name ."', which was not given");$options->{on_fail}->($error)}}}}sub validate (\@$) {return if$Params::Validate::NO_VALIDATION &&!defined wantarray;my$p=$_[0];my$specs=$_[1];local$options=_get_options((caller(0))[0])unless defined$options;if (ref$p eq 'ARRAY'){if (ref$p->[0]){$p={%{$p->[0]}}}elsif (@$p % 2){my$called=_get_called();$options->{on_fail}->("Odd number of parameters in call to $called " ."when named parameters were expected\n")}else {$p={@$p}}}if ($options->{normalize_keys}){$specs=_normalize_callback($specs,$options->{normalize_keys});$p=_normalize_callback($p,$options->{normalize_keys})}elsif ($options->{ignore_case}|| $options->{strip_leading}){$specs=_normalize_named($specs);$p=_normalize_named($p)}if ($Params::Validate::NO_VALIDATION){return (wantarray ? ((map {$_=>$specs->{$_}->{default}}grep {ref$specs->{$_}&& exists$specs->{$_}->{default}}keys %$specs),(ref$p eq 'ARRAY' ? (ref$p->[0]? %{$p->[0]}: @$p): %$p)): do {my$ref=(ref$p eq 'ARRAY' ? (ref$p->[0]? $p->[0]: {@$p}): $p);for (grep {ref$specs->{$_}&& exists$specs->{$_}->{default}}keys %$specs){$ref->{$_}=$specs->{$_}->{default}unless exists$ref->{$_}}return$ref})}_validate_named_depends($p,$specs);unless ($options->{allow_extra}){if (my@unmentioned=grep {!exists$specs->{$_}}keys %$p){my$called=_get_called();$options->{on_fail}->("The following parameter" .(@unmentioned > 1 ? 's were' : ' was')." passed in the call to $called but " .(@unmentioned > 1 ? 'were' : 'was')." not listed in the validation options: @unmentioned\n")}}my@missing;keys %$specs;OUTER: while (my ($key,$spec)=each %$specs){if (!exists$p->{$key}&& (ref$spec ?!(do {if (exists$spec->{default}){$p->{$key}=$spec->{default};next OUTER}}|| do {next OUTER if$spec->{optional}}): $spec)){push@missing,$key}elsif (ref$spec){my$value=defined$p->{$key}? qq|"$p->{$key}"| : 'undef';_validate_one_param($p->{$key},$p,$spec,qq{The '$key' parameter (%s)})}}if (@missing){my$called=_get_called();my$missing=join ', ',map {"'$_'"}sort@missing;$options->{on_fail}->("Mandatory parameter" .(@missing > 1 ? 's' : '')." $missing missing in call to $called\n")}for my$key (grep {defined$p->{$_}&&!ref$p->{$_}&& ref$specs->{$_}&& $specs->{$_}{untaint}}keys %$p){($p->{$key})=$p->{$key}=~ /(.+)/}return wantarray ? %$p : $p}sub validate_with {return if$Params::Validate::NO_VALIDATION &&!defined wantarray;my%p=@_;local$options=_get_options((caller(0))[0],%p);unless ($Params::Validate::NO_VALIDATION){unless (exists$options->{called}){$options->{called}=(caller($options->{stack_skip}))[3]}}if (UNIVERSAL::isa($p{spec},'ARRAY')){return validate_pos(@{$p{params}},@{$p{spec}})}else {return&validate($p{params},$p{spec})}}sub _normalize_callback {my ($p,$func)=@_;my%new;for my$key (keys %$p){my$new_key=$func->($key);unless (defined$new_key){die "The normalize_keys callback did not return a defined value when normalizing the key '$key'"}if (exists$new{$new_key}){die "The normalize_keys callback returned a key that already exists, '$new_key', when normalizing the key '$key'"}$new{$new_key}=$p->{$key}}return \%new}sub _normalize_named {my%h=(ref $_[0])=~ /ARRAY/ ? @{$_[0]}: %{$_[0]};if ($options->{ignore_case}){$h{lc $_ }=delete$h{$_}for keys%h}if ($options->{strip_leading}){for my$key (keys%h){my$new;($new=$key)=~ s/^\Q$options->{strip_leading}\E//;$h{$new}=delete$h{$key}}}return \%h}my%Valid=map {$_=>1}qw(callbacks can default depends isa optional regex type untaint);sub _validate_one_param {my ($value,$params,$spec,$id)=@_;if (exists$spec->{type}){unless (defined$spec->{type}&& Scalar::Util::looks_like_number($spec->{type})&& $spec->{type}> 0){my$msg ="$id has a type specification which is not a number. It is ";if (defined$spec->{type}){$msg .= "a string - $spec->{type}"}else {$msg .= "undef"}$msg .= ".\n Use the constants exported by Params::Validate to declare types.";$options->{on_fail}->(sprintf($msg,_stringify($value)))}unless (_get_type($value)& $spec->{type}){my$type=_get_type($value);my@is=_typemask_to_strings($type);my@allowed=_typemask_to_strings($spec->{type});my$article=$is[0]=~ /^[aeiou]/i ? 'an' : 'a';my$called=_get_called(1);$options->{on_fail}->(sprintf("$id to $called was $article '@is', which " ."is not one of the allowed types: @allowed\n",_stringify($value)))}}return unless ($spec->{isa}|| $spec->{can}|| $spec->{callbacks}|| $spec->{regex});if (exists$spec->{isa}){for (ref$spec->{isa}? @{$spec->{isa}}: $spec->{isa}){unless (do {local $@=q{};eval {$value->isa($_)}}){my$is=ref$value ? ref$value : 'plain scalar';my$article1=$_ =~ /^[aeiou]/i ? 'an' : 'a';my$article2=$is =~ /^[aeiou]/i ? 'an' : 'a';my$called=_get_called(1);$options->{on_fail}->(sprintf("$id to $called was not $article1 '$_' " ."(it is $article2 $is)\n",_stringify($value)))}}}if (exists$spec->{can}){for (ref$spec->{can}? @{$spec->{can}}: $spec->{can}){unless (do {local $@=q{};eval {$value->can($_)}}){my$called=_get_called(1);$options->{on_fail}->(sprintf("$id to $called does not have the method: '$_'\n",_stringify($value)))}}}if ($spec->{callbacks}){unless (UNIVERSAL::isa($spec->{callbacks},'HASH')){my$called=_get_called(1);$options->{on_fail}->("'callbacks' validation parameter for $called must be a hash reference\n")}for (keys %{$spec->{callbacks}}){unless (UNIVERSAL::isa($spec->{callbacks}{$_},'CODE')){my$called=_get_called(1);$options->{on_fail}->("callback '$_' for $called is not a subroutine reference\n")}my$ok;my$e=do {local $@=q{};local$SIG{__DIE__};$ok=eval {$spec->{callbacks}{$_}->($value,$params)};$@};if (!$ok){my$called=_get_called(1);if (ref$e){$options->{on_fail}->($e)}else {my$msg="$id to $called did not pass the '$_' callback";$msg .= ": $e" if length$e;$msg .= "\n";$options->{on_fail}->(sprintf($msg,_stringify($value)))}}}}if (exists$spec->{regex}){unless ((defined$value ? $value : '')=~ /$spec->{regex}/){my$called=_get_called(1);$options->{on_fail}->(sprintf("$id to $called did not pass regex check\n",_stringify($value)))}}}{my%isas=('ARRAY'=>ARRAYREF,'HASH'=>HASHREF,'CODE'=>CODEREF,'GLOB'=>GLOBREF,'SCALAR'=>SCALARREF,'REGEXP'=>SCALARREF,);my%simple_refs=map {$_=>1}keys%isas;sub _get_type {return UNDEF unless defined $_[0];my$ref=ref $_[0];unless ($ref){return GLOB if UNIVERSAL::isa(\$_[0],'GLOB');return SCALAR}return$isas{$ref}if$simple_refs{$ref};for (keys%isas){return$isas{$_}| OBJECT if UNIVERSAL::isa($_[0],$_)}return UNKNOWN}}{my%type_to_string=(SCALAR()=>'scalar',ARRAYREF()=>'arrayref',HASHREF()=>'hashref',CODEREF()=>'coderef',GLOB()=>'glob',GLOBREF()=>'globref',SCALARREF()=>'scalarref',UNDEF()=>'undef',OBJECT()=>'object',UNKNOWN()=>'unknown',);sub _typemask_to_strings {my$mask=shift;my@types;for (SCALAR,ARRAYREF,HASHREF,CODEREF,GLOB,GLOBREF,SCALARREF,UNDEF,OBJECT,UNKNOWN){push@types,$type_to_string{$_}if$mask & $_}return@types ? @types : ('unknown')}}{my%defaults=(ignore_case=>0,strip_leading=>0,allow_extra=>0,on_fail=>sub {require Carp;Carp::croak($_[0])},stack_skip=>1,normalize_keys=>undef,);*set_options=\&validation_options;sub validation_options {my%opts=@_;my$caller=caller;for (keys%defaults){$opts{$_}=$defaults{$_}unless exists$opts{$_}}$Params::Validate::OPTIONS{$caller}=\%opts}sub _get_options {my$caller=shift;if (@_){return ($Params::Validate::OPTIONS{$caller}? {%{$Params::Validate::OPTIONS{$caller}},@_ }: {%defaults,@_ })}else {return (exists$Params::Validate::OPTIONS{$caller}? $Params::Validate::OPTIONS{$caller}: \%defaults)}}}sub _get_called {my$extra_skip=$_[0]|| 0;$extra_skip++;my$called=(exists$options->{called}? $options->{called}: (caller($options->{stack_skip}+ $extra_skip))[3]);$called='(unknown)' unless defined$called;return$called}sub _stringify {return defined $_[0]? qq{"$_[0]"} : 'undef'}1;
PARAMS_VALIDATE_PP

$fatpacked{"Params/Validate/XS.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PARAMS_VALIDATE_XS';
  package Params::Validate::XS;use strict;use warnings;our$VERSION='1.29';use Carp;my$default_fail=sub {Carp::confess($_[0])};{my%defaults=(ignore_case=>0,strip_leading=>0,allow_extra=>0,on_fail=>$default_fail,stack_skip=>1,normalize_keys=>undef,);*set_options=\&validation_options;sub validation_options {my%opts=@_;my$caller=caller;for (keys%defaults){$opts{$_}=$defaults{$_}unless exists$opts{$_}}$Params::Validate::OPTIONS{$caller}=\%opts}use XSLoader;XSLoader::load(__PACKAGE__,exists$Params::Validate::XS::{VERSION}? ${$Params::Validate::XS::{VERSION}}: (),)}sub _check_regex_from_xs {return (defined $_[0]? $_[0]: '')=~ /$_[1]/ ? 1 : 0}1;
PARAMS_VALIDATE_XS

$fatpacked{"Params/ValidatePP.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PARAMS_VALIDATEPP';
  package Params::Validate;our$VERSION='1.29';BEGIN {$ENV{PARAMS_VALIDATE_IMPLEMENTATION}='PP'}use Params::Validate;1;
PARAMS_VALIDATEPP

$fatpacked{"Params/ValidateXS.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PARAMS_VALIDATEXS';
  package Params::Validate;our$VERSION='1.29';BEGIN {$ENV{PARAMS_VALIDATE_IMPLEMENTATION}='XS'}use Params::Validate;1;
PARAMS_VALIDATEXS

$fatpacked{"Regexp/Common.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'REGEXP_COMMON';
  package Regexp::Common;use 5.10.0;use strict;use warnings;no warnings 'syntax';our$VERSION='2017060201';our%RE;our%sub_interface;our$AUTOLOAD;sub _croak {require Carp;goto&Carp::croak}sub _carp {require Carp;goto&Carp::carp}sub new {my ($class,@data)=@_;my%self;tie%self,$class,@data;return \%self}sub TIEHASH {my ($class,@data)=@_;bless \@data,$class}sub FETCH {my ($self,$extra)=@_;return bless ref($self)->new(@$self,$extra),ref($self)}my%imports=map {$_=>"Regexp::Common::$_"}qw /balanced CC comment delimited lingua list net number profanity SEN URI whitespace zip/;sub import {shift;tie%RE,__PACKAGE__;{no strict 'refs';*{caller()."::RE"}=\%RE}my$saw_import;my$no_defaults;my%exclude;for my$entry (grep {!/^RE_/}@_){if ($entry eq 'pattern'){no strict 'refs';*{caller()."::pattern"}=\&pattern;next}if ($entry eq 'clean'){next}if ($entry eq 'no_defaults'){$no_defaults ++;next}if (my$module=$imports {$entry}){$saw_import ++;eval "require $module;";die $@ if $@;next}if ($entry =~ /^!(.*)/ && $imports {$1}){$exclude {$1}++;next}my$module=$entry =~ /^Regexp::Common/ ? $entry : "Regexp::Common::" .$entry;eval "require $module;";die $@ if $@}unless ($saw_import || $no_defaults){for my$module (values%imports){next if$exclude {$module};eval "require $module;";die $@ if $@}}my%exported;for my$entry (grep {/^RE_/}@_){if ($entry =~ /^RE_(\w+_)?ALL$/){my$m=defined $1 ? $1 : "";my$re=qr /^RE_${m}.*$/;while (my ($sub,$interface)=each%sub_interface){next if$exported {$sub};next unless$sub =~ /$re/;{no strict 'refs';*{caller()."::$sub"}=$interface}$exported {$sub}++}}else {next if$exported {$entry};_croak "Can't export unknown subroutine &$entry" unless$sub_interface {$entry};{no strict 'refs';*{caller()."::$entry"}=$sub_interface {$entry}}$exported {$entry}++}}}sub AUTOLOAD {_croak "Can't $AUTOLOAD"}sub DESTROY {}my%cache;my$fpat=qr/^(-\w+)/;sub _decache {my@args=@{tied %{$_[0]}};my@nonflags=grep {!/$fpat/}@args;my$cache=get_cache(@nonflags);_croak "Can't create unknown regex: \$RE{" .join("}{",@args)."}" unless exists$cache->{__VAL__};_croak "Perl $] does not support the pattern " ."\$RE{" .join("}{",@args)."}.\nYou need Perl $cache->{__VAL__}{version} or later" unless ($cache->{__VAL__}{version}||0)<= $];my%flags=(%{$cache->{__VAL__}{default}},map {/$fpat\Q$;\E(.*)/ ? ($1=>$2): /$fpat/ ? ($1=>undef): ()}@args);$cache->{__VAL__}->_clone_with(\@args,\%flags)}use overload q{""}=>\&_decache;sub get_cache {my$cache=\%cache;for (@_){$cache=$cache->{$_}|| ($cache->{$_}={})}return$cache}sub croak_version {my ($entry,@args)=@_}sub pattern {my%spec=@_;_croak 'pattern() requires argument: name => [ @list ]' unless$spec{name}&& ref$spec{name}eq 'ARRAY';_croak 'pattern() requires argument: create => $sub_ref_or_string' unless$spec{create};if (ref$spec{create}ne "CODE"){my$fixed_str="$spec{create}";$spec{create}=sub {$fixed_str}}my@nonflags;my%default;for (@{$spec{name}}){if (/$fpat=(.*)/){$default{$1}=$2}elsif (/$fpat\s*$/){$default{$1}=undef}else {push@nonflags,$_}}my$entry=get_cache(@nonflags);if ($entry->{__VAL__}){_carp "Overriding \$RE{" .join("}{",@nonflags)."}"}$entry->{__VAL__}=bless {create=>$spec{create},match=>$spec{match}|| \&generic_match,subs=>$spec{subs}|| \&generic_subs,version=>$spec{version},default=>\%default,},'Regexp::Common::Entry';for (@nonflags){s/\W/X/g}my$subname="RE_" .join ("_",@nonflags);$sub_interface{$subname}=sub {push @_=>undef if @_ % 2;my%flags=@_;my$pat=$spec{create}->($entry->{__VAL__},{%default,%flags},\@nonflags);if (exists$flags{-keep}){$pat =~ s/\Q(?k:/(/g}else {$pat =~ s/\Q(?k:/(?:/g}return exists$flags {-i}? qr /(?i:$pat)/ : qr/$pat/};return 1}sub generic_match {$_ [1]=~ /$_[0]/}sub generic_subs {$_ [1]=~ s/$_[0]/$_[2]/}sub matches {my ($self,$str)=@_;my$entry=$self -> _decache;$entry -> {match}-> ($entry,$str)}sub subs {my ($self,$str,$newstr)=@_;my$entry=$self -> _decache;$entry -> {subs}-> ($entry,$str,$newstr);return$str}package Regexp::Common::Entry;use overload q{""}=>sub {my ($self)=@_;my$pat=$self->{create}->($self,$self->{flags},$self->{args});if (exists$self->{flags}{-keep}){$pat =~ s/\Q(?k:/(/g}else {$pat =~ s/\Q(?k:/(?:/g}if (exists$self->{flags}{-i}){$pat="(?i)$pat"}return$pat};sub _clone_with {my ($self,$args,$flags)=@_;bless {%$self,args=>$args,flags=>$flags },ref$self}1;
REGEXP_COMMON

$fatpacked{"Regexp/Common/CC.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'REGEXP_COMMON_CC';
  package Regexp::Common::CC;use 5.10.0;use strict;use warnings;no warnings 'syntax';use Regexp::Common qw /pattern clean no_defaults/;use Regexp::Common::_support qw /luhn/;our$VERSION='2017060201';my@cards=([Mastercard=>'5[1-5]',16,1],[Visa=>'4',[13,16],1],[Amex=>'3[47]',15,1],['Diners Club'=>'3(?:0[0-5]|[68])',14,1],[Discover=>'6011',16,1],[enRoute=>'2(?:014|149)',15,0],[JCB=>[['3',16,1],['2131|1800',15,1]]],);for my$card (@cards){my ($name,$prefix,$length,$mod)=@$card;next if ref$prefix || ref$length;next unless$mod;my$times=$length + $mod;pattern name=>[CC=>$name],create=>sub {use re 'eval';qr <((?=($prefix))[0-9]{$length})
                      (?(?{Regexp::Common::_support::luhn $1})|(?!))>x}}1;
REGEXP_COMMON_CC

$fatpacked{"Regexp/Common/SEN.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'REGEXP_COMMON_SEN';
  package Regexp::Common::SEN;use 5.10.0;use strict;use warnings;no warnings 'syntax';use Regexp::Common qw /pattern clean no_defaults/;our$VERSION='2017060201';pattern name=>[qw /SEN USA SSN -sep=-/],create=>sub {my$sep=$_ [1]{-sep};"(?k:(?k:[1-9][0-9][0-9]|0[1-9][0-9]|00[1-9])$sep" ."(?k:[1-9][0-9]|0[1-9])$sep" ."(?k:[1-9][0-9][0-9][0-9]|0[1-9][0-9][0-9]|" ."00[1-9][0-9]|000[1-9]))"},;1;
REGEXP_COMMON_SEN

$fatpacked{"Regexp/Common/URI.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'REGEXP_COMMON_URI';
  package Regexp::Common::URI;use 5.10.0;use strict;use warnings;no warnings 'syntax';use Exporter ();our@ISA=qw /Exporter/;our@EXPORT_OK=qw /register_uri/;use Regexp::Common qw /pattern clean no_defaults/;our$VERSION='2017060201';my@uris=qw /fax file ftp gopher http pop prospero news tel telnet tv wais/;for my$uri (@uris){eval "require Regexp::Common::URI::$uri";die $@ if $@}my%uris;sub register_uri {my ($scheme,$uri)=@_;$uris {$scheme}=$uri}pattern name=>[qw (URI)],create=>sub {my$uri=join '|'=>values%uris;$uri =~ s/\(\?k:/(?:/g;"(?k:$uri)"},;1;
REGEXP_COMMON_URI

$fatpacked{"Regexp/Common/URI/RFC1035.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'REGEXP_COMMON_URI_RFC1035';
  package Regexp::Common::URI::RFC1035;use Regexp::Common qw /pattern clean no_defaults/;use strict;use warnings;use vars qw /$VERSION/;$VERSION='2017060201';use vars qw /@EXPORT @EXPORT_OK %EXPORT_TAGS @ISA/;use Exporter ();@ISA=qw /Exporter/;my%vars;BEGIN {$vars {low}=[qw /$digit $letter $let_dig $let_dig_hyp $ldh_str/];$vars {parts}=[qw /$label $subdomain/];$vars {domain}=[qw /$domain/]}use vars map {@$_}values%vars;@EXPORT=qw /$host/;@EXPORT_OK=map {@$_}values%vars;%EXPORT_TAGS=(%vars,ALL=>[@EXPORT_OK]);$digit="[0-9]";$letter="[A-Za-z]";$let_dig="[A-Za-z0-9]";$let_dig_hyp="[-A-Za-z0-9]";$ldh_str="(?:[-A-Za-z0-9]+)";$label="(?:$letter(?:(?:$ldh_str){0,61}$let_dig)?)";$subdomain="(?:$label(?:[.]$label)*)";$domain="(?: |(?:$subdomain))";1;
REGEXP_COMMON_URI_RFC1035

$fatpacked{"Regexp/Common/URI/RFC1738.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'REGEXP_COMMON_URI_RFC1738';
  package Regexp::Common::URI::RFC1738;use Regexp::Common qw /pattern clean no_defaults/;use strict;use warnings;use vars qw /$VERSION/;$VERSION='2017060201';use vars qw /@EXPORT @EXPORT_OK %EXPORT_TAGS @ISA/;use Exporter ();@ISA=qw /Exporter/;my%vars;BEGIN {$vars {low}=[qw /$digit $digits $hialpha $lowalpha $alpha $alphadigit $safe $extra $national $punctuation $unreserved $unreserved_range $reserved $uchar $uchars $xchar $xchars $hex $escape/];$vars {connect}=[qw /$port $hostnumber $toplabel $domainlabel $hostname $host $hostport $user $password $login/];$vars {parts}=[qw /$fsegment $fpath $group $article $grouppart $search $database $wtype $wpath $psegment $fieldname $fieldvalue $fieldspec $ppath/]}use vars map {@$_}values%vars;@EXPORT=qw /$host/;@EXPORT_OK=map {@$_}values%vars;%EXPORT_TAGS=(%vars,ALL=>[@EXPORT_OK]);$digit='[0-9]';$digits='[0-9]+';$hialpha='[A-Z]';$lowalpha='[a-z]';$alpha='[a-zA-Z]';$alphadigit='[a-zA-Z0-9]';$safe='[-$_.+]';$extra="[!*'(),]";$national='[][{}|\\^~`]';$punctuation='[<>#%"]';$unreserved_range=q [-a-zA-Z0-9$_.+!*'(),];$unreserved="[$unreserved_range]";$reserved='[;/?:@&=]';$hex='[a-fA-F0-9]';$escape="(?:%$hex$hex)";$uchar="(?:$unreserved|$escape)";$uchars="(?:(?:$unreserved|$escape)*)";$xchar="(?:[$unreserved_range;/?:\@&=]|$escape)";$xchars="(?:(?:[$unreserved_range;/?:\@&=]|$escape)*)";$port="(?:$digits)";$hostnumber="(?:$digits\[.]$digits\[.]$digits\[.]$digits)";$toplabel="(?:$alpha\[-a-zA-Z0-9]*$alphadigit|$alpha)";$domainlabel="(?:(?:$alphadigit\[-a-zA-Z0-9]*)?$alphadigit)";$hostname="(?:(?:$domainlabel\[.])*$toplabel)";$host="(?:$hostname|$hostnumber)";$hostport="(?:$host(?::$port)?)";$user="(?:(?:[$unreserved_range;?&=]|$escape)*)";$password="(?:(?:[$unreserved_range;?&=]|$escape)*)";$login="(?:(?:$user(?::$password)?\@)?$hostport)";$fsegment="(?:(?:[$unreserved_range:\@&=]|$escape)*)";$fpath="(?:$fsegment(?:/$fsegment)*)";$group="(?:$alpha\[-A-Za-z0-9.+_]*)";$article="(?:(?:[$unreserved_range;/?:&=]|$escape)+" .'@' ."$host)";$grouppart="(?:[*]|$article|$group)";$search="(?:(?:[$unreserved_range;:\@&=]|$escape)*)";$database=$uchars;$wtype=$uchars;$wpath=$uchars;$psegment="(?:(?:[$unreserved_range?:\@&=]|$escape)*)";$fieldname="(?:(?:[$unreserved_range?:\@&]|$escape)*)";$fieldvalue="(?:(?:[$unreserved_range?:\@&]|$escape)*)";$fieldspec="(?:;$fieldname=$fieldvalue)";$ppath="(?:$psegment(?:/$psegment)*)";1;
REGEXP_COMMON_URI_RFC1738

$fatpacked{"Regexp/Common/URI/RFC1808.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'REGEXP_COMMON_URI_RFC1808';
  package Regexp::Common::URI::RFC1808;BEGIN {if ($] < 5.006 &&!exists$INC {"warnings.pm"}){$INC {"warnings.pm"}=1;no strict 'refs';*{"warnings::unimport"}=sub {0}}}use strict;use warnings;use vars qw /$VERSION/;$VERSION='2017060201';use vars qw /@EXPORT @EXPORT_OK %EXPORT_TAGS @ISA/;use Exporter ();@ISA=qw /Exporter/;my%vars;BEGIN {$vars {low}=[qw /$punctuation $reserved_range $reserved $national $extra $safe $digit $digits $hialpha $lowalpha $alpha $alphadigit $hex $escape $unreserved_range $unreserved $uchar $uchars $pchar_range $pchar $pchars/],$vars {parts}=[qw /$fragment $query $param $params $segment $fsegment $path $net_loc $scheme $rel_path $abs_path $net_path $relativeURL $generic_RL $absoluteURL $URL/],}use vars map {@$_}values%vars;@EXPORT=qw /$host/;@EXPORT_OK=map {@$_}values%vars;%EXPORT_TAGS=(%vars,ALL=>[@EXPORT_OK]);$punctuation='[<>#%"]';$reserved_range=q [;/?:@&=];$reserved="[$reserved_range]";$national='[][{}|\\^~`]';$extra="[!*'(),]";$safe='[-$_.+]';$digit='[0-9]';$digits='[0-9]+';$hialpha='[A-Z]';$lowalpha='[a-z]';$alpha='[a-zA-Z]';$alphadigit='[a-zA-Z0-9]';$hex='[a-fA-F0-9]';$escape="(?:%$hex$hex)";$unreserved_range=q [-a-zA-Z0-9$_.+!*'(),];$unreserved="[$unreserved_range]";$uchar="(?:$unreserved|$escape)";$uchars="(?:(?:$unreserved+|$escape)*)";$pchar_range=qq [$unreserved_range:\@&=];$pchar="(?:[$pchar_range]|$escape)";$pchars="(?:(?:[$pchar_range]+|$escape)*)";$fragment="(?:(?:[$unreserved_range$reserved_range]+|$escape)*)";$query="(?:(?:[$unreserved_range$reserved_range]+|$escape)*)";$param="(?:(?:[$pchar_range/]+|$escape)*)";$params="(?:$param(?:;$param)*)";$segment="(?:(?:[$pchar_range]+|$escape)*)";$fsegment="(?:(?:[$pchar_range]+|$escape)+)";$path="(?:$fsegment(?:/$segment)*)";$net_loc="(?:(?:[$pchar_range;?]+|$escape)*)";$scheme="(?:(?:[-a-zA-Z0-9+.]+|$escape)+)";$rel_path="(?:$path?(?:;$params)?(?:?$query)?)";$abs_path="(?:/$rel_path)";$net_path="(?://$net_loc$abs_path?)";$relativeURL="(?:$net_path|$abs_path|$rel_path)";$generic_RL="(?:$scheme:$relativeURL)";$absoluteURL="(?:$generic_RL|" ."(?:$scheme:(?:[$unreserved_range$reserved_range]+|$escape)*))";$URL="(?:(?:$absoluteURL|$relativeURL)(?:#$fragment)?)";1;
REGEXP_COMMON_URI_RFC1808

$fatpacked{"Regexp/Common/URI/RFC2384.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'REGEXP_COMMON_URI_RFC2384';
  package Regexp::Common::URI::RFC2384;use Regexp::Common qw /pattern clean no_defaults/;use Regexp::Common::URI::RFC1738 qw /$unreserved_range $escape $hostport/;use strict;use warnings;use vars qw /$VERSION/;$VERSION='2017060201';use vars qw /@EXPORT @EXPORT_OK %EXPORT_TAGS @ISA/;use Exporter ();@ISA=qw /Exporter/;my%vars;BEGIN {$vars {low}=[qw /$achar_range $achar $achars $achar_more/];$vars {connect}=[qw /$enc_sasl $enc_user $enc_ext $enc_auth_type $auth $user_auth $server/];$vars {parts}=[qw /$pop_url/]}use vars map {@$_}values%vars;@EXPORT=qw /$host/;@EXPORT_OK=map {@$_}values%vars;%EXPORT_TAGS=(%vars,ALL=>[@EXPORT_OK]);$achar_range="$unreserved_range&=~";$achar="(?:[$achar_range]|$escape)";$achars="(?:(?:[$achar_range]+|$escape)*)";$achar_more="(?:(?:[$achar_range]+|$escape)+)";$enc_sasl=$achar_more;$enc_user=$achar_more;$enc_ext="(?:[+](?:APOP|$achar_more))";$enc_auth_type="(?:$enc_sasl|$enc_ext)";$auth="(?:;AUTH=(?:[*]|$enc_auth_type))";$user_auth="(?:$enc_user$auth?)";$server="(?:(?:$user_auth\@)?$hostport)";$pop_url="(?:pop://$server)";1;
REGEXP_COMMON_URI_RFC2384

$fatpacked{"Regexp/Common/URI/RFC2396.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'REGEXP_COMMON_URI_RFC2396';
  package Regexp::Common::URI::RFC2396;use Regexp::Common qw /pattern clean no_defaults/;use strict;use warnings;use vars qw /$VERSION/;$VERSION='2017060201';use vars qw /@EXPORT @EXPORT_OK %EXPORT_TAGS @ISA/;use Exporter ();@ISA=qw /Exporter/;my%vars;BEGIN {$vars {low}=[qw /$digit $upalpha $lowalpha $alpha $alphanum $hex $escaped $mark $unreserved $reserved $pchar $uric $urics $userinfo $userinfo_no_colon $uric_no_slash/];$vars {parts}=[qw /$query $fragment $param $segment $path_segments $ftp_segments $rel_segment $abs_path $rel_path $path/];$vars {connect}=[qw /$port $IPv4address $toplabel $domainlabel $hostname $host $hostport $server $reg_name $authority/];$vars {URI}=[qw /$scheme $net_path $opaque_part $hier_part $relativeURI $absoluteURI $URI_reference/]}use vars map {@$_}values%vars;@EXPORT=();@EXPORT_OK=map {@$_}values%vars;%EXPORT_TAGS=(%vars,ALL=>[@EXPORT_OK]);$digit='[0-9]';$upalpha='[A-Z]';$lowalpha='[a-z]';$alpha='[a-zA-Z]';$alphanum='[a-zA-Z0-9]';$hex='[a-fA-F0-9]';$escaped="(?:%$hex$hex)";$mark="[\\-_.!~*'()]";$unreserved="[a-zA-Z0-9\\-_.!~*'()]";$reserved="[;/?:@&=+\$,]";$pchar="(?:[a-zA-Z0-9\\-_.!~*'():\@&=+\$,]|$escaped)";$uric="(?:[;/?:\@&=+\$,a-zA-Z0-9\\-_.!~*'()]|$escaped)";$urics="(?:(?:[;/?:\@&=+\$,a-zA-Z0-9\\-_.!~*'()]+|" ."$escaped)*)";$query=$urics;$fragment=$urics;$param="(?:(?:[a-zA-Z0-9\\-_.!~*'():\@&=+\$,]+|$escaped)*)";$segment="(?:$param(?:;$param)*)";$path_segments="(?:$segment(?:/$segment)*)";$ftp_segments="(?:$param(?:/$param)*)";$rel_segment="(?:(?:[a-zA-Z0-9\\-_.!~*'();\@&=+\$,]*|$escaped)+)";$abs_path="(?:/$path_segments)";$rel_path="(?:$rel_segment(?:$abs_path)?)";$path="(?:(?:$abs_path|$rel_path)?)";$port="(?:$digit*)";$IPv4address="(?:$digit+[.]$digit+[.]$digit+[.]$digit+)";$toplabel="(?:$alpha"."[-a-zA-Z0-9]*$alphanum|$alpha)";$domainlabel="(?:(?:$alphanum"."[-a-zA-Z0-9]*)?$alphanum)";$hostname="(?:(?:$domainlabel\[.])*$toplabel\[.]?)";$host="(?:$hostname|$IPv4address)";$hostport="(?:$host(?::$port)?)";$userinfo="(?:(?:[a-zA-Z0-9\\-_.!~*'();:&=+\$,]+|$escaped)*)";$userinfo_no_colon="(?:(?:[a-zA-Z0-9\\-_.!~*'();&=+\$,]+|$escaped)*)";$server="(?:(?:$userinfo\@)?$hostport)";$reg_name="(?:(?:[a-zA-Z0-9\\-_.!~*'()\$,;:\@&=+]*|$escaped)+)";$authority="(?:$server|$reg_name)";$scheme="(?:$alpha"."[a-zA-Z0-9+\\-.]*)";$net_path="(?://$authority$abs_path?)";$uric_no_slash="(?:[a-zA-Z0-9\\-_.!~*'();?:\@&=+\$,]|$escaped)";$opaque_part="(?:$uric_no_slash$urics)";$hier_part="(?:(?:$net_path|$abs_path)(?:[?]$query)?)";$relativeURI="(?:(?:$net_path|$abs_path|$rel_path)(?:[?]$query)?";$absoluteURI="(?:$scheme:(?:$hier_part|$opaque_part))";$URI_reference="(?:(?:$absoluteURI|$relativeURI)?(?:#$fragment)?)";1;
REGEXP_COMMON_URI_RFC2396

$fatpacked{"Regexp/Common/URI/RFC2806.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'REGEXP_COMMON_URI_RFC2806';
  package Regexp::Common::URI::RFC2806;use Regexp::Common::URI::RFC1035 qw /$domain/;use Regexp::Common::URI::RFC2396 qw /$unreserved $escaped $hex/;use strict;use warnings;use vars qw /$VERSION/;$VERSION='2017060201';use vars qw /@EXPORT @EXPORT_OK %EXPORT_TAGS @ISA/;use Exporter ();@ISA=qw /Exporter/;my%vars;BEGIN {$vars {low}=[qw /$dtmf_digit $wait_for_dial_tone $one_second_pause $pause_character $visual_separator $phonedigit $escaped_no_dquote $quoted_string $token_char $token_chars/];$vars {parts}=[qw /$future_extension/];$vars {connect}=[qw /$provider_hostname $provider_tag $service_provider $private_prefix $local_network_prefix $global_network_prefix $network_prefix/];$vars {phone}=[qw /$phone_context_ident $phone_context_tag $area_specifier $post_dial $isdn_subaddress $t33_subaddress $local_phone_number $local_phone_number_no_future $base_phone_number $global_phone_number $global_phone_number_no_future $telephone_subscriber $telephone_subscriber_no_future/];$vars {fax}=[qw /$fax_local_phone $fax_local_phone_no_future $fax_global_phone $fax_global_phone_no_future $fax_subscriber $fax_subscriber_no_future/];$vars {modem}=[qw //]}use vars map {@$_}values%vars;@EXPORT=();@EXPORT_OK=map {@$_}values%vars;%EXPORT_TAGS=(%vars,ALL=>[@EXPORT_OK]);$dtmf_digit="(?:[*#ABCD])";$wait_for_dial_tone="(?:w)";$one_second_pause="(?:p)";$pause_character="(?:[wp])";$visual_separator="(?:[\\-.()])";$phonedigit="(?:[0-9\\-.()])";$escaped_no_dquote="(?:%(?:[01]$hex)|2[013-9A-Fa-f]|[3-9A-Fa-f]$hex)";$quoted_string="(?:%22(?:(?:%5C(?:$unreserved|$escaped))|" ."$unreserved+|$escaped_no_dquote)*%22)";$token_char="(?:[!'*\\-.0-9A-Z_a-z~]|" ."%(?:2[13-7ABDEabde]|3[0-9]|4[1-9A-Fa-f]|" ."5[AEFaef]|6[0-9A-Fa-f]|7[0-9ACEace]))";$token_chars="(?:(?:[!'*\\-.0-9A-Z_a-z~]+|" ."%(?:2[13-7ABDEabde]|3[0-9]|4[1-9A-Fa-f]|" ."5[AEFaef]|6[0-9A-Fa-f]|7[0-9ACEace]))*)";$future_extension="(?:;$token_chars" ."(?:=(?:(?:$token_chars(?:[?]$token_chars)?)|" ."$quoted_string))?)";$provider_hostname=$domain;$provider_tag="(?:tsp)";$service_provider="(?:;$provider_tag=$provider_hostname)";$private_prefix="(?:(?:[!'E-OQ-VX-Z_e-oq-vx-z~]|" ."(?:%(?:2[124-7CFcf]|3[AC-Fac-f]|4[05-9A-Fa-f]|" ."5[1-689A-Fa-f]|6[05-9A-Fa-f]|" ."7[1-689A-Ea-e])))" ."(?:[!'()*\\-.0-9A-Z_a-z~]+|" ."(?:%(?:2[1-9A-Fa-f]|3[AC-Fac-f]|" ."[4-6][0-9A-Fa-f]|7[0-9A-Ea-e])))*)";$local_network_prefix ="(?:[0-9\\-.()*#ABCDwp]+)";$global_network_prefix ="(?:[+][0-9\\-.()]+)";$network_prefix="(?:$global_network_prefix|$local_network_prefix)";$phone_context_ident ="(?:$network_prefix|$private_prefix)";$phone_context_tag="(?:phone-context)";$area_specifier="(?:;$phone_context_tag=$phone_context_ident)";$post_dial="(?:;postd=[0-9\\-.()*#ABCDwp]+)";$isdn_subaddress="(?:;isub=[0-9\\-.()]+)";$t33_subaddress="(?:;tsub=[0-9\\-.()]+)";$local_phone_number="(?:[0-9\\-.()*#ABCDwp]+$isdn_subaddress?" ."$post_dial?$area_specifier" ."(?:$area_specifier|$service_provider|" ."$future_extension)*)";$local_phone_number_no_future ="(?:[0-9\\-.()*#ABCDwp]+$isdn_subaddress?" ."$post_dial?$area_specifier" ."(?:$area_specifier|$service_provider)*)";$fax_local_phone="(?:[0-9\\-.()*#ABCDwp]+$isdn_subaddress?" ."$t33_subaddress?$post_dial?$area_specifier" ."(?:$area_specifier|$service_provider|" ."$future_extension)*)";$fax_local_phone_no_future ="(?:[0-9\\-.()*#ABCDwp]+$isdn_subaddress?" ."$t33_subaddress?$post_dial?$area_specifier" ."(?:$area_specifier|$service_provider)*)";$base_phone_number="(?:[0-9\\-.()]+)";$global_phone_number ="(?:[+]$base_phone_number$isdn_subaddress?" ."$post_dial?" ."(?:$area_specifier|$service_provider|" ."$future_extension)*)";$global_phone_number_no_future ="(?:[+]$base_phone_number$isdn_subaddress?" ."$post_dial?" ."(?:$area_specifier|$service_provider)*)";$fax_global_phone="(?:[+]$base_phone_number$isdn_subaddress?" ."$t33_subaddress?$post_dial?" ."(?:$area_specifier|$service_provider|" ."$future_extension)*)";$fax_global_phone_no_future ="(?:[+]$base_phone_number$isdn_subaddress?" ."$t33_subaddress?$post_dial?" ."(?:$area_specifier|$service_provider)*)";$telephone_subscriber ="(?:$global_phone_number|$local_phone_number)";$telephone_subscriber_no_future ="(?:$global_phone_number_no_future|" ."$local_phone_number_no_future)";$fax_subscriber="(?:$fax_global_phone|$fax_local_phone)";$fax_subscriber_no_future ="(?:$fax_global_phone_no_future|" ."$fax_local_phone_no_future)";1;
REGEXP_COMMON_URI_RFC2806

$fatpacked{"Regexp/Common/URI/fax.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'REGEXP_COMMON_URI_FAX';
  package Regexp::Common::URI::fax;use Regexp::Common qw /pattern clean no_defaults/;use Regexp::Common::URI qw /register_uri/;use Regexp::Common::URI::RFC2806 qw /$fax_subscriber $fax_subscriber_no_future/;use strict;use warnings;use vars qw /$VERSION/;$VERSION='2017060201';my$fax_scheme='fax';my$fax_uri="(?k:(?k:$fax_scheme):(?k:$fax_subscriber))";my$fax_uri_nf="(?k:(?k:$fax_scheme):(?k:$fax_subscriber_no_future))";register_uri$fax_scheme=>$fax_uri;pattern name=>[qw (URI fax)],create=>$fax_uri ;pattern name=>[qw (URI fax nofuture)],create=>$fax_uri_nf ;1;
REGEXP_COMMON_URI_FAX

$fatpacked{"Regexp/Common/URI/file.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'REGEXP_COMMON_URI_FILE';
  package Regexp::Common::URI::file;use Regexp::Common qw /pattern clean no_defaults/;use Regexp::Common::URI qw /register_uri/;use Regexp::Common::URI::RFC1738 qw /$host $fpath/;use strict;use warnings;use vars qw /$VERSION/;$VERSION='2017060201';my$scheme='file';my$uri="(?k:(?k:$scheme)://(?k:(?k:(?:$host|localhost)?)" ."(?k:/(?k:$fpath))))";register_uri$scheme=>$uri;pattern name=>[qw (URI file)],create=>$uri,;1;
REGEXP_COMMON_URI_FILE

$fatpacked{"Regexp/Common/URI/ftp.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'REGEXP_COMMON_URI_FTP';
  package Regexp::Common::URI::ftp;use Regexp::Common qw /pattern clean no_defaults/;use Regexp::Common::URI qw /register_uri/;use Regexp::Common::URI::RFC2396 qw /$host $port $ftp_segments $userinfo $userinfo_no_colon/;use strict;use warnings;use vars qw /$VERSION/;$VERSION='2017060201';my$ftp_uri="(?k:(?k:ftp)://(?:(?k:$userinfo)(?k:)\@)?(?k:$host)" ."(?::(?k:$port))?(?k:/(?k:(?k:$ftp_segments)" ."(?:;type=(?k:[AIai]))?))?)";my$ftp_uri_password="(?k:(?k:ftp)://(?:(?k:$userinfo_no_colon)" ."(?::(?k:$userinfo_no_colon))?\@)?(?k:$host)" ."(?::(?k:$port))?(?k:/(?k:(?k:$ftp_segments)" ."(?:;type=(?k:[AIai]))?))?)";register_uri FTP=>$ftp_uri;pattern name=>[qw (URI FTP),"-type=[AIai]","-password="],create=>sub {my$uri=exists $_ [1]-> {-password}&& !defined $_ [1]-> {-password}? $ftp_uri_password : $ftp_uri;my$type=$_ [1]-> {-type};$uri =~ s/\[AIai\]/$type/;$uri};1;
REGEXP_COMMON_URI_FTP

$fatpacked{"Regexp/Common/URI/gopher.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'REGEXP_COMMON_URI_GOPHER';
  package Regexp::Common::URI::gopher;use Regexp::Common qw /pattern clean no_defaults/;use Regexp::Common::URI qw /register_uri/;use Regexp::Common::URI::RFC1738 qw /$host $port $uchars/;use Regexp::Common::URI::RFC1808 qw /$pchars $pchar_range/;use strict;use warnings;use vars qw /$VERSION/;$VERSION='2017060201';my$pchars_notab="(?:(?:[$pchar_range]+|" ."%(?:[1-9a-fA-F][0-9a-fA-F]|0[0-8a-fA-F]))*)";my$gopherplus_string=$pchars;my$search=$pchars;my$search_notab=$pchars_notab;my$selector=$pchars;my$selector_notab=$pchars_notab;my$gopher_type="(?:[0-9+IgT])";my$scheme="gopher";my$uri="(?k:(?k:$scheme)://(?k:$host)(?::(?k:$port))?" ."/(?k:(?k:$gopher_type)(?k:$selector)))";my$uri_notab="(?k:(?k:$scheme)://(?k:$host)(?::(?k:$port))?" ."/(?k:(?k:$gopher_type)(?k:$selector_notab)" ."(?:%09(?k:$search_notab)(?:%09(?k:$gopherplus_string))?)?))";register_uri$scheme=>$uri;pattern name=>[qw (URI gopher -notab=)],create=>sub {exists $_ [1]{-notab}&& !defined $_ [1]{-notab}? $uri_notab : $uri},;1;
REGEXP_COMMON_URI_GOPHER

$fatpacked{"Regexp/Common/URI/http.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'REGEXP_COMMON_URI_HTTP';
  package Regexp::Common::URI::http;use Regexp::Common qw /pattern clean no_defaults/;use Regexp::Common::URI qw /register_uri/;use Regexp::Common::URI::RFC2396 qw /$host $port $path_segments $query/;use strict;use warnings;use vars qw /$VERSION/;$VERSION='2017060201';my$http_uri="(?k:(?k:http)://(?k:$host)(?::(?k:$port))?" ."(?k:/(?k:(?k:$path_segments)(?:[?](?k:$query))?))?)";my$https_uri=$http_uri;$https_uri =~ s/http/https?/;register_uri HTTP=>$https_uri;pattern name=>[qw (URI HTTP),"-scheme=http"],create=>sub {my$scheme=$_ [1]-> {-scheme};my$uri=$http_uri;$uri =~ s/http/$scheme/;$uri};1;
REGEXP_COMMON_URI_HTTP

$fatpacked{"Regexp/Common/URI/news.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'REGEXP_COMMON_URI_NEWS';
  package Regexp::Common::URI::news;use Regexp::Common qw /pattern clean no_defaults/;use Regexp::Common::URI qw /register_uri/;use Regexp::Common::URI::RFC1738 qw /$grouppart $group $article $host $port $digits/;use strict;use warnings;use vars qw /$VERSION/;$VERSION='2017060201';my$news_scheme='news';my$news_uri="(?k:(?k:$news_scheme):(?k:$grouppart))";my$nntp_scheme='nntp';my$nntp_uri="(?k:(?k:$nntp_scheme)://(?k:(?k:(?k:$host)(?::(?k:$port))?)" ."/(?k:$group)(?:/(?k:$digits))?))";register_uri$news_scheme=>$news_uri;register_uri$nntp_scheme=>$nntp_uri;pattern name=>[qw (URI news)],create=>$news_uri,;pattern name=>[qw (URI NNTP)],create=>$nntp_uri,;1;
REGEXP_COMMON_URI_NEWS

$fatpacked{"Regexp/Common/URI/pop.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'REGEXP_COMMON_URI_POP';
  package Regexp::Common::URI::pop;use Regexp::Common qw /pattern clean no_defaults/;use Regexp::Common::URI qw /register_uri/;use Regexp::Common::URI::RFC1738 qw /$host $port/;use Regexp::Common::URI::RFC2384 qw /$enc_user $enc_auth_type/;use strict;use warnings;use vars qw /$VERSION/;$VERSION='2017060201';my$scheme="pop";my$uri="(?k:(?k:$scheme)://(?:(?k:$enc_user)" ."(?:;AUTH=(?k:[*]|$enc_auth_type))?\@)?" ."(?k:$host)(?::(?k:$port))?)";register_uri$scheme=>$uri;pattern name=>[qw (URI POP)],create=>$uri,;1;
REGEXP_COMMON_URI_POP

$fatpacked{"Regexp/Common/URI/prospero.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'REGEXP_COMMON_URI_PROSPERO';
  package Regexp::Common::URI::prospero;use Regexp::Common qw /pattern clean no_defaults/;use Regexp::Common::URI qw /register_uri/;use Regexp::Common::URI::RFC1738 qw /$host $port $ppath $fieldname $fieldvalue $fieldspec/;use strict;use warnings;use vars qw /$VERSION/;$VERSION='2017060201';my$scheme='prospero';my$uri="(?k:(?k:$scheme)://(?k:$host)(?::(?k:$port))?" ."/(?k:$ppath)(?k:$fieldspec*))";register_uri$scheme=>$uri;pattern name=>[qw (URI prospero)],create=>$uri,;1;
REGEXP_COMMON_URI_PROSPERO

$fatpacked{"Regexp/Common/URI/tel.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'REGEXP_COMMON_URI_TEL';
  package Regexp::Common::URI::tel;use Regexp::Common qw /pattern clean no_defaults/;use Regexp::Common::URI qw /register_uri/;use Regexp::Common::URI::RFC2806 qw /$telephone_subscriber $telephone_subscriber_no_future/;use strict;use warnings;use vars qw /$VERSION/;$VERSION='2017060201';my$tel_scheme='tel';my$tel_uri="(?k:(?k:$tel_scheme):(?k:$telephone_subscriber))";my$tel_uri_nf="(?k:(?k:$tel_scheme):(?k:$telephone_subscriber_no_future))";register_uri$tel_scheme=>$tel_uri;pattern name=>[qw (URI tel)],create=>$tel_uri ;pattern name=>[qw (URI tel nofuture)],create=>$tel_uri_nf ;1;
REGEXP_COMMON_URI_TEL

$fatpacked{"Regexp/Common/URI/telnet.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'REGEXP_COMMON_URI_TELNET';
  package Regexp::Common::URI::telnet;use Regexp::Common qw /pattern clean no_defaults/;use Regexp::Common::URI qw /register_uri/;use Regexp::Common::URI::RFC1738 qw /$user $password $host $port/;use strict;use warnings;use vars qw /$VERSION/;$VERSION='2017060201';my$telnet_uri="(?k:(?k:telnet)://(?:(?k:(?k:$user)(?::(?k:$password))?)\@)?" ."(?k:(?k:$host)(?::(?k:$port))?)(?k:/)?)";register_uri telnet=>$telnet_uri;pattern name=>[qw (URI telnet)],create=>$telnet_uri,;1;
REGEXP_COMMON_URI_TELNET

$fatpacked{"Regexp/Common/URI/tv.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'REGEXP_COMMON_URI_TV';
  package Regexp::Common::URI::tv;use Regexp::Common qw /pattern clean no_defaults/;use Regexp::Common::URI qw /register_uri/;use Regexp::Common::URI::RFC2396 qw /$hostname/;use strict;use warnings;use vars qw /$VERSION/;$VERSION='2017060201';my$tv_scheme='tv';my$tv_url="(?k:(?k:$tv_scheme):(?k:$hostname)?)";register_uri$tv_scheme=>$tv_url;pattern name=>[qw (URI tv)],create=>$tv_url,;1;
REGEXP_COMMON_URI_TV

$fatpacked{"Regexp/Common/URI/wais.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'REGEXP_COMMON_URI_WAIS';
  package Regexp::Common::URI::wais;use Regexp::Common qw /pattern clean no_defaults/;use Regexp::Common::URI qw /register_uri/;use Regexp::Common::URI::RFC1738 qw /$host $port $search $database $wtype $wpath/;use strict;use warnings;use vars qw /$VERSION/;$VERSION='2017060201';my$scheme='wais';my$uri="(?k:(?k:$scheme)://(?k:$host)(?::(?k:$port))?/(?k:(?k:$database)" ."(?k:[?](?k:$search)|/(?k:$wtype)/(?k:$wpath))?))";register_uri$scheme=>$uri;pattern name=>[qw (URI WAIS)],create=>$uri,;1;
REGEXP_COMMON_URI_WAIS

$fatpacked{"Regexp/Common/_support.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'REGEXP_COMMON__SUPPORT';
  package Regexp::Common::_support;use 5.10.0;use strict;use warnings;no warnings 'syntax';our$VERSION='2017060201';sub luhn {my$arg=shift;my$even=0;my$sum=0;while (length$arg){my$num=chop$arg;return if$num lt '0' || $num gt '9';if ($even && (($num *= 2)> 9)){$num=1 + ($num % 10)}$even=1 - $even;$sum += $num}!($sum % 10)}sub import {my$pack=shift;my$caller=caller;no strict 'refs';*{$caller ."::" .$_}=\&{$pack ."::" .$_}for @_}1;
REGEXP_COMMON__SUPPORT

$fatpacked{"Regexp/Common/balanced.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'REGEXP_COMMON_BALANCED';
  package Regexp::Common::balanced;{use 5.10.0;use strict;use warnings;no warnings 'syntax';use Regexp::Common qw /pattern clean no_defaults/;our$VERSION='2017060201';my%closer=('{'=>'}','('=>')','['=>']','<'=>'>');my%cache;sub nested {my ($start,$finish)=@_;return$cache {$start}{$finish}if exists$cache {$start}{$finish};my@starts=map {s/\\(.)/$1/g;$_}grep {length}$start =~ /([^|\\]+|\\.)+/gs;my@finishes=map {s/\\(.)/$1/g;$_}grep {length}$finish =~ /([^|\\]+|\\.)+/gs;push@finishes=>($finishes [-1])x (@starts - @finishes);my@re;local $"="|";for my$begin (@starts){my$end=shift@finishes;my$qb=quotemeta$begin;my$qe=quotemeta$end;my$fb=quotemeta substr$begin=>0,1;my$fe=quotemeta substr$end=>0,1;my$tb=quotemeta substr$begin=>1;my$te=quotemeta substr$end=>1;my$add;if ($fb eq $fe){push@re=>qq /(?:$qb(?:(?>[^$fb]+)|$fb(?!$tb)(?!$te)|(?-1))*$qe)/}else {my@clauses="(?>[^$fb$fe]+)";push@clauses=>"$fb(?!$tb)" if length$tb;push@clauses=>"$fe(?!$te)" if length$te;push@clauses=>"(?-1)";push@re=>qq /(?:$qb(?:@clauses)*$qe)/}}$cache {$start}{$finish}=qr /(@re)/}pattern name=>[qw /balanced -parens=() -begin= -end=/],create=>sub {my$flag=$_[1];unless (defined$flag -> {-begin}&& length$flag -> {-begin}&& defined$flag -> {-end}&& length$flag -> {-end}){my@open=grep {index ($flag->{-parens},$_)>= 0}('[','(','{','<');my@close=map {$closer {$_}}@open;$flag -> {-begin}=join "|"=>@open;$flag -> {-end}=join "|"=>@close}return nested @$flag {qw /-begin -end/}},}1;
REGEXP_COMMON_BALANCED

$fatpacked{"Regexp/Common/comment.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'REGEXP_COMMON_COMMENT';
  package Regexp::Common::comment;use 5.10.0;use strict;use warnings;no warnings 'syntax';use Regexp::Common qw /pattern clean no_defaults/;our$VERSION='2017060201';my@generic=({languages=>[qw /ABC Forth/],to_eol=>['\\\\']},{languages=>[qw /Ada Alan Eiffel lua/],to_eol=>['--']},{languages=>[qw /Advisor/],to_eol=>['#|//']},{languages=>[qw /Advsys CQL Lisp LOGO M MUMPS REBOL Scheme SMITH zonefile/],to_eol=>[';']},{languages=>['Algol 60'],from_to=>[[qw /comment ;/]]},{languages=>[qw {ALPACA B C C-- LPC PL/I}],from_to=>[[qw {/* */}]]},{languages=>[qw /awk fvwm2 Icon m4 mutt Perl Python QML R Ruby shell Tcl/],to_eol=>['#']},{languages=>[[BASIC=>'mvEnterprise']],to_eol=>['[*!]|REM']},{languages=>[qw /Befunge-98 Funge-98 Shelta/],id=>[';']},{languages=>['beta-Juliet','Crystal Report','Portia','Ubercode'],to_eol=>['//']},{languages=>['BML'],from_to=>[['<?_c','_c?>']],},{languages=>[qw /C++/,'C#',qw /Cg ECMAScript FPL Java JavaScript/],to_eol=>['//'],from_to=>[[qw {/* */}]]},{languages=>[qw /CLU LaTeX slrn TeX/],to_eol=>['%']},{languages=>[qw /False/],from_to=>[[qw !{ }!]]},{languages=>[qw /Fortran/],to_eol=>['!']},{languages=>[qw /Haifu/],id=>[',']},{languages=>[qw /ILLGOL/],to_eol=>['NB']},{languages=>[qw /INTERCAL/],to_eol=>[q{(?:(?:PLEASE(?:\s+DO)?|DO)\s+)?(?:NOT|N'T)}]},{languages=>[qw /J/],to_eol=>['NB[.]']},{languages=>[qw /JavaDoc/],from_to=>[[qw {/** */}]]},{languages=>[qw /Nickle/],to_eol=>['#'],from_to=>[[qw {/* */}]]},{languages=>[qw /Oberon/],from_to=>[[qw /(* *)/]]},{languages=>[[qw /Pascal Delphi/],[qw /Pascal Free/],[qw /Pascal GPC/]],to_eol=>['//'],from_to=>[[qw !{ }!],[qw !(* *)!]]},{languages=>[[qw /Pascal Workshop/]],id=>[qw /"/],from_to=>[[qw !{ }!],[qw !(* *)!],[qw !/* */!]]},{languages=>[qw /PEARL/],to_eol=>['!'],from_to=>[[qw {/* */}]]},{languages=>[qw /PHP/],to_eol=>['#','//'],from_to=>[[qw {/* */}]]},{languages=>[qw !PL/B!],to_eol=>['[.;]']},{languages=>[qw !PL/SQL!],to_eol=>['--'],from_to=>[[qw {/* */}]]},{languages=>[qw /Q-BAL/],to_eol=>['`']},{languages=>[qw /Smalltalk/],id=>['"']},{languages=>[qw /SQL/],to_eol=>['-{2,}']},{languages=>[qw /troff/],to_eol=>['\\\"']},{languages=>[qw /vi/],to_eol=>['"']},{languages=>[qw /*W/],from_to=>[[qw {|| !!}]]},{languages=>[qw /ZZT-OOP/],to_eol=>["'"]},);my@plain_or_nested=([Caml=>undef,"(*"=>"*)"],[Dylan=>"//","/*"=>"*/"],[Haskell=>"-{2,}","{-"=>"-}"],[Hugo=>"!(?!\\\\)","!\\"=>"\\!"],[SLIDE=>"#","(*"=>"*)"],['Modula-2'=>undef,"(*"=>"*)"],['Modula-3'=>undef,"(*"=>"*)"],);sub combine {local $_=join "|",@_;if (@_ > 1){s/\(\?k:/(?:/g;$_="(?k:$_)"}$_}sub to_eol ($) {"(?k:(?k:$_[0])(?k:[^\\n]*)(?k:\\n))"}sub id ($) {"(?k:(?k:$_[0])(?k:[^$_[0]]*)(?k:$_[0]))"}sub from_to {my ($begin,$end)=@_;my$qb=quotemeta$begin;my$qe=quotemeta$end;my$fe=quotemeta substr$end=>0,1;my$te=quotemeta substr$end=>1;"(?k:(?k:$qb)(?k:(?:[^$fe]+|$fe(?!$te))*)(?k:$qe))"}my$count=0;sub nested {my ($begin,$end)=@_;$count ++;my$r='(??{$Regexp::Common::comment ['.$count .']})';my$qb=quotemeta$begin;my$qe=quotemeta$end;my$fb=quotemeta substr$begin=>0,1;my$fe=quotemeta substr$end=>0,1;my$tb=quotemeta substr$begin=>1;my$te=quotemeta substr$end=>1;use re 'eval';my$re;if ($fb eq $fe){$re=qr /(?:$qb(?:(?>[^$fb]+)|$fb(?!$tb)(?!$te)|$r)*$qe)/}else {local $"="|";my@clauses="(?>[^$fb$fe]+)";push@clauses=>"$fb(?!$tb)" if length$tb;push@clauses=>"$fe(?!$te)" if length$te;push@clauses=>$r;$re=qr /(?:$qb(?:@clauses)*$qe)/}$Regexp::Common::comment [$count]=qr/$re/}for my$info (@plain_or_nested){my ($language,$mark,$begin,$end)=@$info;pattern name=>[comment=>$language],create=>sub {my$re=nested$begin=>$end;my$prefix=defined$mark ? $mark ."[^\n]*\n|" : "";exists $_ [1]-> {-keep}? qr /($prefix$re)/ : qr  /$prefix$re/},}for my$group (@generic){my$pattern=combine +(map {to_eol $_}@{$group -> {to_eol}}),(map {from_to @$_}@{$group -> {from_to}}),(map {id $_}@{$group -> {id}}),;for my$language (@{$group -> {languages}}){pattern name=>[comment=>ref$language ? @$language : $language],create=>$pattern,}}pattern name=>[qw /comment Pascal/],create=>'(?k:' .'(?k:[{]|[(][*])' .'(?k:[^}*]*(?:[*](?![)])[^}*]*)*)' .'(?k:[}]|[*][)])' .')' ;pattern name=>[qw /comment Pascal Alice/],create=>'(?k:(?k:[{])(?k:[^}\n]*)(?k:[}]))' ;pattern name=>[qw (comment),'Algol 68'],create=>q {(?k:(?:#[^#]*#)|} .q {(?:\bco\b(?:[^c]+|\Bc|\bc(?!o\b))*\bco\b)|} .q {(?:\bcomment\b(?:[^c]+|\Bc|\bc(?!omment\b))*\bcomment\b))} ;pattern name=>[qw (comment HTML)],create=>q {(?k:(?k:<!)(?k:(?:--(?k:[^-]*(?:-[^-]+)*)--\s*)*)(?k:>))},;pattern name=>[qw /comment SQL MySQL/],create=>q {(?k:(?:#|-- )[^\n]*\n|} .q {/\*(?:(?>[^*;"']+)|"[^"]*"|'[^']*'|\*(?!/))*(?:;|\*/))},;pattern name=>[qw /comment Brainfuck/],create=>'(?k:[^<>\[\]+\-.,]+)' ;pattern name=>[qw /comment Squeak/],create=>'(?k:(?k:")(?k:[^"]*(?:""[^"]*)*)(?k:"))' ;@Regexp::Common::comment::scores=(1,3,3,2,1,4,2,4,1,8,5,1,3,1,1,3,10,1,1,1,1,4,4,8,4,10);{my ($s,$x);pattern name=>[qw /comment Beatnik/],create=>sub {use re 'eval';my$re=qr {\b([A-Za-z]+)\b
                           (?(?{($s, $x) = (0, lc $^N);
                                $s += $Regexp::Common::comment::scores
                                      [ord (chop $x) - ord ('a')] while length $x;
                                $s  >= 5 && $s < 18})XXX|)}x;$re},}pattern name=>[qw /comment Fortran fixed/],create=>'(?k:(?k:(?:^[Cc*]|(?<!^.....)!))(?k:[^\n]*)(?k:\n))' ;pattern name=>[qw /comment COBOL/],create=>'(?<=^......)(?k:(?k:[*])(?k:[^\n]*)(?k:\n))',;1;
REGEXP_COMMON_COMMENT

$fatpacked{"Regexp/Common/delimited.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'REGEXP_COMMON_DELIMITED';
  package Regexp::Common::delimited;use 5.10.0;use strict;use warnings;no warnings 'syntax';use Regexp::Common qw /pattern clean no_defaults/;use charnames ':full';our$VERSION='2017060201';sub gen_delimited {my ($dels,$escs,$cdels)=@_;if (defined$escs && length$escs){$escs .= substr ($escs,-1)x (length ($dels)- length ($escs))}if (defined$cdels && length$cdels){$cdels .= substr ($cdels,-1)x (length ($dels)- length ($cdels))}else {$cdels=$dels}my@pat=();for (my$i=0;$i < length$dels;$i ++){my$del=quotemeta substr ($dels,$i,1);my$cdel=quotemeta substr ($cdels,$i,1);my$esc=defined$escs && length ($escs)? quotemeta substr ($escs,$i,1): "";if ($cdel eq $esc){push@pat=>"(?k:$del)(?k:[^$cdel]*(?:(?:$cdel$cdel)[^$cdel]*)*)(?k:$cdel)"}elsif (length$esc){push@pat=>"(?k:$del)(?k:[^$esc$cdel]*(?:$esc.[^$esc$cdel]*)*)(?k:$cdel)"}else {push@pat=>"(?k:$del)(?k:[^$cdel]*)(?k:$cdel)"}}my$pat=join '|',@pat;return "(?k:(?|$pat))"}sub _croak {require Carp;goto&Carp::croak}pattern name=>[qw(delimited -delim= -esc=\\ -cdelim=)],create=>sub {my$flags=$_[1];_croak 'Must specify delimiter in $RE{delimited}' unless length$flags->{-delim};return gen_delimited (@{$flags}{-delim,-esc,-cdelim})},;pattern name=>[qw(quoted -esc=\\)],create=>sub {my$flags=$_[1];return gen_delimited (q{"'`},$flags -> {-esc})},;my@bracket_pairs;if ($] >= 5.014){@bracket_pairs=map {ref $_ ? $_ : /!/ ? [(do {my$x=$_;$x =~ s/!/TOP/;$x},do {my$x=$_;$x =~ s/!/BOTTOM/;$x})]: [(do {my$x=$_;$x =~ s/\?/LEFT/;$x},do {my$x=$_;$x =~ s/\?/RIGHT/;$x})]}"? PARENTHESIS","? SQUARE BRACKET","? CURLY BRACKET","? DOUBLE QUOTATION MARK","? SINGLE QUOTATION MARK","SINGLE ?-POINTING ANGLE QUOTATION MARK","?-POINTING DOUBLE ANGLE QUOTATION MARK","FULLWIDTH ? PARENTHESIS","FULLWIDTH ? SQUARE BRACKET","FULLWIDTH ? CURLY BRACKET","FULLWIDTH ? WHITE PARENTHESIS","? WHITE PARENTHESIS","? WHITE SQUARE BRACKET","? WHITE CURLY BRACKET","? CORNER BRACKET","? ANGLE BRACKET","? DOUBLE ANGLE BRACKET","? BLACK LENTICULAR BRACKET","? TORTOISE SHELL BRACKET","? BLACK TORTOISE SHELL BRACKET","? WHITE CORNER BRACKET","? WHITE LENTICULAR BRACKET","? WHITE TORTOISE SHELL BRACKET","HALFWIDTH ? CORNER BRACKET","MATHEMATICAL ? WHITE SQUARE BRACKET","MATHEMATICAL ? ANGLE BRACKET","MATHEMATICAL ? DOUBLE ANGLE BRACKET","MATHEMATICAL ? FLATTENED PARENTHESIS","MATHEMATICAL ? WHITE TORTOISE SHELL BRACKET","? CEILING","? FLOOR","Z NOTATION ? IMAGE BRACKET","Z NOTATION ? BINDING BRACKET",["HEAVY SINGLE TURNED COMMA QUOTATION MARK ORNAMENT","HEAVY SINGLE " ."COMMA QUOTATION MARK ORNAMENT",],["HEAVY DOUBLE TURNED COMMA QUOTATION MARK ORNAMENT","HEAVY DOUBLE " ."COMMA QUOTATION MARK ORNAMENT",],"MEDIUM ? PARENTHESIS ORNAMENT","MEDIUM FLATTENED ? PARENTHESIS ORNAMENT","MEDIUM ? CURLY BRACKET ORNAMENT","MEDIUM ?-POINTING ANGLE BRACKET ORNAMENT","HEAVY ?-POINTING ANGLE QUOTATION MARK ORNAMENT","HEAVY ?-POINTING ANGLE BRACKET ORNAMENT","LIGHT ? TORTOISE SHELL BRACKET ORNAMENT","ORNATE ? PARENTHESIS","! PARENTHESIS","! SQUARE BRACKET","! CURLY BRACKET","! TORTOISE SHELL BRACKET","PRESENTATION FORM FOR VERTICAL ? CORNER BRACKET","PRESENTATION FORM FOR VERTICAL ? WHITE CORNER BRACKET","PRESENTATION FORM FOR VERTICAL ? TORTOISE SHELL BRACKET","PRESENTATION FORM FOR VERTICAL ? BLACK LENTICULAR BRACKET","PRESENTATION FORM FOR VERTICAL ? WHITE LENTICULAR BRACKET","PRESENTATION FORM FOR VERTICAL ? ANGLE BRACKET","PRESENTATION FORM FOR VERTICAL ? DOUBLE ANGLE BRACKET","PRESENTATION FORM FOR VERTICAL ? SQUARE BRACKET","PRESENTATION FORM FOR VERTICAL ? CURLY BRACKET","?-POINTING ANGLE BRACKET","? ANGLE BRACKET WITH DOT","?-POINTING CURVED ANGLE BRACKET","SMALL ? PARENTHESIS","SMALL ? CURLY BRACKET","SMALL ? TORTOISE SHELL BRACKET","SUPERSCRIPT ? PARENTHESIS","SUBSCRIPT ? PARENTHESIS","? SQUARE BRACKET WITH UNDERBAR",["LEFT SQUARE BRACKET WITH TICK IN TOP CORNER","RIGHT SQUARE BRACKET WITH TICK IN BOTTOM CORNER",],["LEFT SQUARE BRACKET WITH TICK IN BOTTOM CORNER","RIGHT SQUARE BRACKET WITH TICK IN TOP CORNER",],"? SQUARE BRACKET WITH QUILL","TOP ? HALF BRACKET","BOTTOM ? HALF BRACKET","? S-SHAPED BAG DELIMITER",["LEFT ARC LESS-THAN BRACKET","RIGHT ARC GREATER-THAN BRACKET",],["DOUBLE LEFT ARC GREATER-THAN BRACKET","DOUBLE RIGHT ARC LESS-THAN BRACKET",],"? SIDEWAYS U BRACKET","? DOUBLE PARENTHESIS","? WIGGLY FENCE","? DOUBLE WIGGLY FENCE","? LOW PARAPHRASE BRACKET","? RAISED OMISSION BRACKET","? SUBSTITUTION BRACKET","? DOTTED SUBSTITUTION BRACKET","? TRANSPOSITION BRACKET",["OGHAM FEATHER MARK","OGHAM REVERSED FEATHER MARK",],["TIBETAN MARK GUG RTAGS GYON","TIBETAN MARK GUG RTAGS GYAS",],["TIBETAN MARK ANG KHANG GYON","TIBETAN MARK ANG KHANG GYAS",],;@bracket_pairs=grep {defined charnames::string_vianame ($$_ [0])&& defined charnames::string_vianame ($$_ [1])}@bracket_pairs;if (@bracket_pairs){my$delims=join ""=>map {charnames::string_vianame ($$_ [0])}@bracket_pairs;my$cdelims=join ""=>map {charnames::string_vianame ($$_ [1])}@bracket_pairs;pattern name=>[qw (bquoted -esc=\\)],create=>sub {my$flags=$_ [1];return gen_delimited ($delims,$flags -> {-esc},$cdelims)},version=>5.014,}}sub bracket_pairs {@bracket_pairs}1;
REGEXP_COMMON_DELIMITED

$fatpacked{"Regexp/Common/lingua.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'REGEXP_COMMON_LINGUA';
  package Regexp::Common::lingua;use 5.10.0;use strict;use warnings;no warnings 'syntax';use Regexp::Common qw /pattern clean no_defaults/;our$VERSION='2017060201';pattern name=>[qw /lingua palindrome -chars=[A-Za-z]/],create=>sub {use re 'eval';my$keep=exists $_ [1]-> {-keep};my$ch=$_ [1]-> {-chars};my$idx=$keep ? "1:$ch" : "0:$ch";my$r="(??{\$Regexp::Common::lingua::pd{'" .$idx ."'}})";$Regexp::Common::lingua::pd {$idx}=$keep ? qr /($ch|($ch)($r)?\2)/ : qr  /$ch|($ch)($r)?\1/},;1;
REGEXP_COMMON_LINGUA

$fatpacked{"Regexp/Common/list.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'REGEXP_COMMON_LIST';
  package Regexp::Common::list;use 5.10.0;use strict;use warnings;no warnings 'syntax';use Regexp::Common qw /pattern clean no_defaults/;our$VERSION='2017060201';sub gen_list_pattern {my ($pat,$sep,$lsep)=@_;$lsep=$sep unless defined$lsep;return "(?k:(?:(?:$pat)(?:$sep))*(?:$pat)(?k:$lsep)(?:$pat))"}my$defpat='.*?\S';my$defsep='\s*,\s*';pattern name=>['list',"-pat=$defpat","-sep=$defsep",'-lastsep'],create=>sub {gen_list_pattern (@{$_[1]}{-pat,-sep,-lastsep})},;pattern name=>['list','conj','-word=(?:and|or)'],create=>sub {gen_list_pattern($defpat,$defsep,'\s*,?\s*'.$_[1]->{-word}.'\s*')},;pattern name=>['list','and'],create=>sub {gen_list_pattern ($defpat,$defsep,'\s*,?\s*and\s*')},;pattern name=>['list','or'],create=>sub {gen_list_pattern ($defpat,$defsep,'\s*,?\s*or\s*')},;1;
REGEXP_COMMON_LIST

$fatpacked{"Regexp/Common/net.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'REGEXP_COMMON_NET';
  package Regexp::Common::net;use 5.10.0;use strict;use warnings;no warnings 'syntax';use Regexp::Common qw /pattern clean no_defaults/;our$VERSION='2017060201';my%IPunit=(dec=>q{(?k:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})},oct=>q{(?k:[0-3]?[0-7]{1,2})},hex=>q{(?k:[0-9a-fA-F]{1,2})},bin=>q{(?k:[0-1]{1,8})},strict=>q{(?k:2(?:5[0-5]?|[0-4][0-9]?|[6-9]?)|1[0-9]{0,2}|[3-9][0-9]?|0)},);my%MACunit=(%IPunit,hex=>q{(?k:[0-9a-fA-F]{1,2})},);my%IPv6unit=(hex=>q {(?k:[0-9a-f]{1,4})},HEX=>q {(?k:[0-9A-F]{1,4})},HeX=>q {(?k:[0-9a-fA-F]{1,4})},);sub dec {$_};sub bin {oct "0b$_"}my$IPdefsep='[.]';my$MACdefsep=':';my$IPv6defsep=':';pattern name=>[qw (net IPv4)],create=>"(?k:$IPunit{dec}$IPdefsep$IPunit{dec}$IPdefsep" ."$IPunit{dec}$IPdefsep$IPunit{dec})",;pattern name=>[qw (net MAC)],create=>"(?k:" .join ($MACdefsep=>($MACunit{hex})x 6).")",subs=>sub {$_ [1]=join ":"=>map {sprintf "%02x"=>hex}split /$MACdefsep/=>$_ [1]if $_ [1]=~ /$_[0]/},;for my$type (qw /dec oct hex bin strict/){pattern name=>[qw (net IPv4),$type,"-sep=$IPdefsep"],create=>sub {my$sep=$_ [1]-> {-sep};"(?k:$IPunit{$type}$sep$IPunit{$type}$sep" ."$IPunit{$type}$sep$IPunit{$type})"},;pattern name=>[qw (net MAC),$type,"-sep=$MACdefsep"],create=>sub {my$sep=$_ [1]-> {-sep};"(?k:" .join ($sep=>($MACunit{$type})x 6).")",},subs=>sub {return if $] < 5.006 and $type eq 'bin';$_ [1]=join ":"=>map {sprintf "%02x"=>eval$type}$2,$3,$4,$5,$6,$7 if $_ [1]=~ $RE {net}{MAC}{$type}{-sep=>$_ [0]-> {flags}{-sep}}{-keep}},}my%cache6;pattern name=>[qw (net IPv6),"-sep=$IPv6defsep","-style=HeX"],create=>sub {my$style=$_ [1]{-style};my$sep=$_ [1]{-sep};return$cache6 {$style,$sep}if$cache6 {$style,$sep};my@re;die "Impossible style '$style'\n" unless exists$IPv6unit {$style};push@re=>join$sep=>($IPv6unit {$style})x 8;for (my$l=0;$l <= 6;$l ++){for (my$r=6 - $l;$r >= 0;$r --){my$m=8 - $l - $r;my$patl=$l ? ($IPv6unit {$style}.$sep)x $l : $sep;my$patr=$r ? ($sep .$IPv6unit {$style})x $r : $sep;my$patm="(?k:)" x $m;my$pat=$patl .$patm .$patr;push@re=>"(?:$pat)"}}local $"="|";$cache6 {$style,$sep}=qq /(?k:(?|@re))/},;my$letter="[A-Za-z]";my$let_dig="[A-Za-z0-9]";my$let_dig_hyp="[-A-Za-z0-9]";pattern name=>[qw (net domain -nospace= -rfc1101=)],create=>sub {my$rfc1101=exists $_ [1]{-rfc1101}&& !defined $_ [1]{-rfc1101};my$lead=$rfc1101 ? "(?!$RE{net}{IPv4}(?:[.]|\$))$let_dig" : $letter;if (exists $_ [1]{-nospace}&&!defined $_ [1]{-nospace}){return "(?k:$lead(?:(?:$let_dig_hyp){0,61}$let_dig)?" ."(?:\\.$lead(?:(?:$let_dig_hyp){0,61}$let_dig)?)*)"}else {return "(?k: |(?:$lead(?:(?:$let_dig_hyp){0,61}$let_dig)?" ."(?:\\.$lead(?:(?:$let_dig_hyp){0,61}$let_dig)?)*))"}},;1;
REGEXP_COMMON_NET

$fatpacked{"Regexp/Common/number.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'REGEXP_COMMON_NUMBER';
  package Regexp::Common::number;use 5.10.0;use strict;use warnings;no warnings 'syntax';use Config;use Regexp::Common qw /pattern clean no_defaults/;our$VERSION='2017060201';sub _croak {require Carp;goto&Carp::croak}my$digits=join ("",0 .. 9,"A" .. "Z");sub int_creator {my$flags=$_ [1];my ($sep,$group,$base,$places,$sign)=@{$flags}{qw /-sep -group -base -places -sign/};_croak "Base must be between 1 and 36" unless$base >= 1 && $base <= 36;my$chars=substr$digits,0,$base;$sep=',' if exists$flags -> {-sep}&&!defined$flags -> {-sep};my$max=$group;$max=$2 if$group =~ /^\s*(\d+)\s*,\s*(\d+)\s*$/;my$quant=$places ? "{$places}" : "+";return$sep ? qq {(?k:(?k:$sign)(?k:[$chars]{1,$max}} .qq {(?:$sep} .qq {[$chars]{$group})*))} : qq {(?k:(?k:$sign)(?k:[$chars]$quant))}}sub real_creator {my ($base,$places,$radix,$sep,$group,$expon,$sign)=@{$_[1]}{-base,-places,-radix,-sep,-group,-expon,-sign};_croak "Base must be between 1 and 36" unless$base >= 1 && $base <= 36;$sep=',' if exists $_[1]->{-sep}&&!defined $_[1]->{-sep};if ($base > 14 && $expon =~ /^[Ee]$/){$expon='G'}for ($radix,$sep,$expon){$_="[$_]" if 1==length}my$chars=substr$digits,0,$base;return$sep ? qq {(?k:(?i)(?k:$sign)(?k:(?=$radix?[$chars])} .qq {(?k:[$chars]{1,$group}(?:(?:$sep)[$chars]{$group})*)} .qq {(?:(?k:$radix)(?k:[$chars]{$places}))?)} .qq {(?:(?k:$expon)(?k:(?k:$sign)(?k:[$chars]+))|))} : qq {(?k:(?i)(?k:$sign)(?k:(?=$radix?[$chars])} .qq {(?k:[$chars]*)(?:(?k:$radix)(?k:[$chars]{$places}))?)} .qq {(?:(?k:$expon)(?k:(?k:$sign)(?k:[$chars]+))|))}}sub decimal_creator {my ($base,$places,$radix,$sep,$group,$sign)=@{$_[1]}{-base,-places,-radix,-sep,-group,-sign};_croak "Base must be between 1 and 36" unless$base >= 1 && $base <= 36;$sep=',' if exists $_[1]->{-sep}&&!defined $_[1]->{-sep};for ($radix,$sep){$_="[$_]" if 1==length}my$chars=substr$digits,0,$base;return$sep ? qq {(?k:(?i)(?k:$sign)(?k:(?=$radix?[$chars])} .qq {(?k:[$chars]{1,$group}(?:(?:$sep)[$chars]{$group})*)} .qq {(?:(?k:$radix)(?k:[$chars]{$places}))?))} : qq {(?k:(?i)(?k:$sign)(?k:(?=$radix?[$chars])} .qq {(?k:[$chars]*)(?:(?k:$radix)(?k:[$chars]{$places}))?))}}pattern name=>[qw (num int -sep= -base=10 -group=3 -sign=[-+]?)],create=>\&int_creator,;pattern name=>[qw (num real -base=10),'-places=0,',qw (-radix=[.] -sep= -group=3 -expon=E -sign=[-+]?)],create=>\&real_creator,;pattern name=>[qw (num decimal -base=10),'-places=0,',qw (-radix=[.] -sep= -group=3 -sign=[-+]?)],create=>\&decimal_creator,;sub real_synonym {my ($name,$base)=@_;pattern name=>['num',$name,'-places=0,','-radix=[.]','-sep=','-group=3','-expon=E','-sign=[-+]?'],create=>sub {my%flags=(%{$_[1]},-base=>$base);real_creator (undef,\%flags)}}real_synonym (hex=>16);real_synonym (dec=>10);real_synonym (oct=>8);real_synonym (bin=>2);pattern name=>[qw (num square)],create=>sub {use re 'eval';my$sixty_four_bits=$Config {use64bitint};my$num=$sixty_four_bits ? '0*(?:(?:9(?:[0-1][0-9]{17}' .'|2(?:[0-1][0-9]{16}' .'|2(?:[0-2][0-9]{15}' .'|3(?:[0-2][0-9]{14}' .'|3(?:[0-6][0-9]{13}' .'|7(?:[0-1][0-9]{12}' .'|20(?:[0-2][0-9]{10}' .'|3(?:[0-5][0-9]{9}' .'|6(?:[0-7][0-9]{8}' .'|8(?:[0-4][0-9]{7}' .'|5(?:[0-3][0-9]{6}' .'|4(?:[0-6][0-9]{5}' .'|7(?:[0-6][0-9]{4}' .'|7(?:[0-4][0-9]{3}' .'|5(?:[0-7][0-9]{2}' .'|80(?:[0-6])))))))))))))))))|[1-8]?[0-9]{0,18})' : '0*(?:2(?:[0-0][0-9]{8}' .'|1(?:[0-3][0-9]{7}' .'|4(?:[0-6][0-9]{6}' .'|7(?:[0-3][0-9]{5}' .'|4(?:[0-7][0-9]{4}' .'|8(?:[0-2][0-9]{3}' .'|3(?:[0-5][0-9]{2}' .'|6(?:[0-3][0-9]{1}' .'|4[0-7])))))))))|1?[0-9]{1,9}';qr {($num)(?(?{length $^N && sqrt ($^N) == int sqrt ($^N)})|(?!))}},;pattern name=>[qw (num roman)],create=>'(?xi)(?=[MDCLXVI])
                           (?k:M{0,4}
                              (?:C[DM]|D?C{0,4})?
                              (?:X[LC]|L?X{0,4})?
                              (?:I[VX]|V?I{0,4})?)' ;1;
REGEXP_COMMON_NUMBER

$fatpacked{"Regexp/Common/profanity.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'REGEXP_COMMON_PROFANITY';
  package Regexp::Common::profanity;use 5.10.0;use strict;use warnings;no warnings 'syntax';use Regexp::Common qw /pattern clean no_defaults/;our$VERSION='2017060201';my$profanity='(?:cvff(?:\\ gnxr|\\-gnxr|gnxr|r(?:ef|[feq])|vat|l)?|dhvzf?|fuvg(?:g(?:r(?:ef|[qe])|vat|l)|r(?:ef|[fqel])|vat|[fr])?|g(?:heqf?|jngf?)|jnax(?:r(?:ef|[eq])|vat|f)?|n(?:ef(?:r(?:\\ ubyr|\\-ubyr|ubyr|[fq])|vat|r)|ff(?:\\ ubyrf?|\\-ubyrf?|rq|ubyrf?|vat))|o(?:hyy(?:\\ fuvg(?:g(?:r(?:ef|[qe])|vat)|f)?|\\-fuvg(?:g(?:r(?:ef|[qe])|vat)|f)?|fuvg(?:g(?:r(?:ef|[qe])|vat)|f)?)|ybj(?:\\ wbof?|\\-wbof?|wbof?))|p(?:bpx(?:\\ fhpx(?:ref?|vat)|\\-fhpx(?:ref?|vat)|fhpx(?:ref?|vat))|enc(?:c(?:r(?:ef|[eq])|vat|l)|f)?|h(?:agf?|z(?:vat|zvat|f)))|qvpx(?:\\ urnq|\\-urnq|rq|urnq|vat|yrff|f)|s(?:hpx(?:rq|vat|f)?|neg(?:r[eq]|vat|[fl])?|rygpu(?:r(?:ef|[efq])|vat)?)|un(?:eq[\\-\\ ]?ba|ys(?:\\ n[fe]|\\-n[fe]|n[fe])frq)|z(?:bgure(?:\\ shpx(?:ref?|vat)|\\-shpx(?:ref?|vat)|shpx(?:ref?|vat))|hgu(?:n(?:\\ shpx(?:ref?|vat|[nnn])|\\-shpx(?:ref?|vat|[nnn])|shpx(?:ref?|vat|[nnn]))|re(?:\\ shpx(?:ref?|vat)|\\-shpx(?:ref?|vat)|shpx(?:ref?|vat)))|reqr?))';my$contextual='(?:c(?:bex|e(?:bax|vpxf?)|hff(?:vrf|l)|vff(?:\\ gnxr|\\-gnxr|gnxr|r(?:ef|[feq])|vat|l)?)|dhvzf?|ebbg(?:r(?:ef|[eq])|vat|f)?|f(?:bq(?:q(?:rq|vat)|f)?|chax|perj(?:rq|vat|f)?|u(?:nt(?:t(?:r(?:ef|[qe])|vat)|f)?|vg(?:g(?:r(?:ef|[qe])|vat|l)|r(?:ef|[fqel])|vat|[fr])?))|g(?:heqf?|jngf?|vgf?)|jnax(?:r(?:ef|[eq])|vat|f)?|n(?:ef(?:r(?:\\ ubyr|\\-ubyr|ubyr|[fq])|vat|r)|ff(?:\\ ubyrf?|\\-ubyrf?|rq|ubyrf?|vat))|o(?:ba(?:r(?:ef|[fe])|vat|r)|h(?:ttre|yy(?:\\ fuvg(?:g(?:r(?:ef|[qe])|vat)|f)?|\\-fuvg(?:g(?:r(?:ef|[qe])|vat)|f)?|fuvg(?:g(?:r(?:ef|[qe])|vat)|f)?))|n(?:fgneq|yy(?:r(?:ef|[qe])|vat|f)?)|yb(?:bql|j(?:\\ wbof?|\\-wbof?|wbof?)))|p(?:bpx(?:\\ fhpx(?:ref?|vat)|\\-fhpx(?:ref?|vat)|fhpx(?:ref?|vat)|f)?|enc(?:c(?:r(?:ef|[eq])|vat|l)|f)?|h(?:agf?|z(?:vat|zvat|f)))|q(?:batf?|vpx(?:\\ urnq|\\-urnq|rq|urnq|vat|yrff|f)?)|s(?:hpx(?:rq|vat|f)?|neg(?:r[eq]|vat|[fl])?|rygpu(?:r(?:ef|[efq])|vat)?)|u(?:hzc(?:r(?:ef|[eq])|vat|f)?|n(?:eq[\\-\\ ]?ba|ys(?:\\ n[fe]|\\-n[fe]|n[fe])frq))|z(?:bgure(?:\\ shpx(?:ref?|vat)|\\-shpx(?:ref?|vat)|shpx(?:ref?|vat))|hgu(?:n(?:\\ shpx(?:ref?|vat|[nnn])|\\-shpx(?:ref?|vat|[nnn])|shpx(?:ref?|vat|[nnn]))|re(?:\\ shpx(?:ref?|vat)|\\-shpx(?:ref?|vat)|shpx(?:ref?|vat)))|reqr?))';tr/A-Za-z/N-ZA-Mn-za-m/ foreach$profanity,$contextual;pattern name=>[qw (profanity)],create=>'(?:\b(?k:' .$profanity .')\b)',;pattern name=>[qw (profanity contextual)],create=>'(?:\b(?k:' .$contextual .')\b)',;1;
REGEXP_COMMON_PROFANITY

$fatpacked{"Regexp/Common/whitespace.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'REGEXP_COMMON_WHITESPACE';
  package Regexp::Common::whitespace;use 5.10.0;use strict;use warnings;no warnings 'syntax';use Regexp::Common qw /pattern clean no_defaults/;our$VERSION='2017060201';pattern name=>[qw (ws crop)],create=>'(?:^\s+|\s+$)',subs=>sub {$_[1]=~ s/^\s+//;$_[1]=~ s/\s+$//};1;
REGEXP_COMMON_WHITESPACE

$fatpacked{"Regexp/Common/zip.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'REGEXP_COMMON_ZIP';
  package Regexp::Common::zip;use 5.10.0;use strict;use warnings;no warnings 'syntax';use Regexp::Common qw /pattern clean no_defaults/;our$VERSION='2017060201';my%code=(Australia=>[qw /AUS? AU AUS/],Austria=>[qw /AU?T AT AUT/],Belgium=>[qw /BE? BE B/],Denmark=>[qw /DK DK DK/],France=>[qw /FR? FR F/],Germany=>[qw /DE? DE D/],Greenland=>[qw /GL GL GL/],Italy=>[qw /IT? IT I/],Liechtenstein=>[qw /LIE? LI LIE/],Luxembourg=>[qw /LU? LU L/],Monaco=>[qw /MC MC MC/],Netherlands=>[qw /NL NL NL/],Norway=>[qw /NO? NO N/],'San Marino'=>[qw /SM SM SM/],Spain=>[qw /ES? ES E/],Switzerland=>[qw /CH CH CH/],USA=>[qw /USA? US USA/],'Vatican City'=>[qw /VA VA VA/],);sub __ {defined $_ [0]? $_ [0]: ""}sub _t {if (defined $_ [0]){if ($_ [0]=~ /^y/i){return "{1,1}"}if ($_ [0]=~ /^n/i){return "{0,0}"}}"{0,1}"}sub _c {my ($name,$country)=@_;if (defined$country && $country ne ""){if ($country eq 'iso'){return$code {$name}[1]}if ($country eq 'cept'){return$code {$name}[2]}return$country}$code {$name}[0]}my%zip=(Austria=>"(?k:1(?:[0-8][0-9][0-9]|90[01])" ."|2(?:[0-3][0-9][0-9]|" ."4(?:0[0-9]|1[0-3]|2[1-5]|3[1-9]|[4-6][0-9]|7[0-5]|" ."8[1-9]|9[0-9])|" ."[5-7][0-9][0-9]|" ."8(?:[0-7][0-9]|8[01]))" ."|3(?:0(?:0[1-9]|[1-9][0-9])|" ."[12][0-9][0-9]|" ."3(?:[0-2][0-9]|3[0-5]|[4-9][0-9])|" ."[4-8][0-9][0-9]|" ."9(?:[0-6][0-9]|7[0-3]))" ."|4(?:[01][0-9][0-9]|" ."2(?:[0-8][0-9]|9[0-4])|" ."3(?:0[0-3]|[1-8][0-9]|9[0-2])|" ."4(?:[0-1][0-9]|2[01]|3[1-9]|[4-9][0-9])|" ."[5-8][0-9][0-9]|" ."9(?:[0-7][0-9]|8[0-5]))" ."|5(?:0[0-9][0-9]|" ."1(?:0[0-9]|1[0-4]|[23][0-9]|4[0-5]|5[1-9]|[6-9][0-9])|" ."2(?:0[0-5]|1[1-9]|[2-7][0-9]|8[0-3])|" ."3(?:0[0-3]|1[01]|2[1-9]|[34][0-9]|5[01]|60)|" ."[4-6][0-9][0-9]|" ."7(?:[0-6][0-9]|7[01]))" ."|6(?:[0-5][0-9][0-9]|" ."6(?:[0-8][0-9]|9[01])|" ."[78][0-9][0-9]|" ."9(?:[0-8][0-9]|9[0-3]))" ."|7(?:[0-3][0-9][0-9]|" ."4(?:0[0-9]|1[0-3]|2[1-9]|[3-9][0-9])|" ."5(?:[0-6][0-9]|7[0-3]))" ."|8(?:[0-2][0-9][0-9]|" ."3(?:[0-5][0-9]|6[0-3]|8[0-5])|" ."4(?:0[1-9]|[1-9][0-9])|" ."[5-8][0-9][0-9]|" ."9(?:[0-8][0-9]|9[0-3]))" ."|9(?:[0-6][0-9][0-9]|" ."7(?:[0-7][0-9]|8[0-2])|" ."8(?:[0-6][0-9]|7[0-3])|" ."9(?:[0-8][0-9]|9[0-2]))" .")",Belgium=>"(?k:1(?:0(?:0[05-9]|1[0-2]|20|3[01]|4[013-57-9]|50|60|70|8[0-3]|90)|" ."1(?:0[05]|10|20|30|40|50|60|70|80|90)|" ."2(?:0[01]|1[02])|" ."3(?:0[01]|1[05]|2[05]|3[0-2]|4[0-28]|5[07]|6[07]|70|80|90)|" ."4(?:0[0-24]|1[04]|2[018]|3[05]|40|5[07]|6[01]|" ."7[0-46]|80|9[05])|" ."5(?:0[0-2]|4[017]|60|70)|" ."6(?:0[0-2]|20|30|40|5[0-4]|7[0134])|" ."7(?:0[0-3]|3[01]|4[0-25]|5[05]|6[01]|70|8[05]|90)|" ."8(?:0[04]|18|20|3[01]|40|5[0-3]|6[01]|80)|" ."9(?:10|3[0-4]|50|70|8[0-2]))" ."|2(?:0(?:00|18|20|30|40|50|60|70)|" ."1(?:00|10|40|50|60|70|80)|" ."2(?:00|2[0-3]|3[05]|4[023]|50|60|7[05]|8[08]|90)|" ."3(?:00|10|2[0-38]|30|40|50|60|70|8[0-27]|90)|" ."4(?:00|3[01]|40|50|60|70|80|9[01])|" ."5(?:00|20|3[01]|4[07]|50|60|70|80|90)|" ."6(?:00|10|2[07]|30|40|50|60)|" ."8(?:0[01]|1[12]|20|30|4[05]|50|6[01]|70|80|90)|" ."9(?:00|10|20|30|40|50|60|70|80|90))" ."|3(?:0(?:0[01]|1[028]|20|40|5[0-4]|6[01]|7[018]|80|90)|" ."1(?:1[018]|2[08]|30|40|50|9[01])|" ."2(?:0[0-2]|1[0-2]|2[01]|7[0-2]|9[034])|" ."3(?:00|2[01]|50|60|70|8[014]|9[01])|" ."4(?:0[014]|40|5[04]|6[01]|7[0-3])|" ."5(?:0[01]|1[0-2]|20|30|4[05]|50|60|70|8[0-3]|90)|" ."6(?:00|2[01]|3[01]|40|50|6[058]|70|80|90)|" ."7(?:00|17|2[0-4]|3[02]|4[026]|70|9[0-38])|" ."8(?:0[036]|3[0-2]|40|50|70|9[01])|" ."9(?:00|10|20|30|4[015]|50|60|7[01]|80|90))" ."|4(?:0(?:00|20|3[0-2]|4[0-2]|5[0-3]|90)|" ."1(?:0[0-2]|2[0-2]|30|4[01]|51|6[0-3]|7[01]|8[01]|90)|" ."2(?:1[07-9]|5[02-47]|6[013]|8[07])|" ."3(?:00|17|4[027]|5[017]|6[07])|" ."4(?:00|20|3[0-2]|5[0-38]|60|70|80)|" ."5(?:00|20|3[07]|40|5[07]|60|7[07]|90)|" ."6(?:0[0-26-8]|10|2[0134]|3[0-3]|5[0-4]|7[0-2]|8[0-4]|90)|" ."7(?:0[01]|1[01]|2[018]|3[01]|50|6[01]|7[01]|8[02-4]|9[01])|" ."8(?:0[0-2]|2[01]|3[0147]|4[015]|5[0-2]|6[01]|7[07]|80|90)|" ."9(?:00|10|20|50|60|70|8[037]|90))" ."|5(?:0(?:0[0-4]|2[0-24]|3[0-2]|60|70|8[01])|" ."1(?:0[01]|40|50|70|90)|" ."3(?:00|10|3[02-46]|40|5[0-4]|6[0-4]|7[02467]|80)|" ."5(?:0[0-4]|2[0-4]|3[07]|4[0-4]|5[05]|6[0-4]|7[0-6]|80|90)|" ."6(?:00|2[01]|30|4[0146]|5[01]|60|70|80))" ."|6(?:0(?:0[01]|10|20|3[0-2]|4[0-4]|6[01])|" ."1(?:1[01]|20|4[0-2]|50|8[0-3])|" ."2(?:00|1[01]|2[0-4]|3[08]|40|50|80)|" ."4(?:4[01]|6[0-4]|70)|" ."5(?:00|11|3[0-46]|4[023]|6[07]|9[0-46])|" ."6(?:00|3[07]|4[02]|6[0-36]|7[0-4]|8[016-8]|9[028])|" ."7(?:0[046]|17|2[0134]|30|4[0-37]|50|6[0-279]|8[0-2]|9[0-2])|" ."8(?:00|1[0-3]|2[0134]|3[0-468]|40|5[0-36]|60|70|8[07]|90)|" ."9(?:00|2[0-2479]|4[01]|5[0-3]|60|7[0-2]|8[02-467]|9[07]))" ."|7(?:0(?:00|1[0-2]|2[0-24]|3[0-4]|4[01]|50|6[0-3]|70|80|90)|" ."1(?:00|10|20|3[0134]|4[01]|60|70|8[01]|9[01])|" ."3(?:0[01]|2[0-2]|3[0-4]|40|50|70|8[027]|90)|" ."5(?:0[0-46]|2[0-2]|3[0-468]|4[0238])|" ."6(?:0[0-48]|1[018]|2[0-4]|4[0-3])|" ."7(?:00|1[12]|30|4[023]|50|60|8[0-4])|" ."8(?:0[0-4]|1[0-2]|2[23]|30|50|6[0-46]|70|80|90)|" ."9(?:0[01346]|1[0-2]|4[0-3]|5[01]|7[0-3]))" ."|8(?:0(?:00|20)|" ."2(?:00|1[01])|" ."3(?:0[01]|10|40|7[07]|80)|" ."4(?:00|2[01]|3[0-4]|50|60|70|80|90)|" ."5(?:0[01]|1[01]|20|3[01]|40|5[0-4]|60|7[023]|8[0-37])|" ."6(?:00|10|20|30|4[07]|50|60|70|80|9[01])|" ."7(?:00|10|20|30|40|5[05]|60|70|80|9[0-3])|" ."8(?:00|10|20|30|40|5[01]|60|70|80|90)|" ."9(?:0[02468]|20|30|40|5[0-46-8]|7[028]|80))" ."|9(?:0(?:00|3[0-2]|4[0-2]|5[0-2]|60|70|80|90)|" ."1(?:00|1[12]|20|30|40|50|60|70|8[05]|90)|" ."2(?:00|20|30|40|5[05]|60|70|80|90)|" ."3(?:0[08]|10|20|40)|" ."4(?:0[0-46]|20|5[01]|7[023])|" ."5(?:0[06]|2[01]|5[0-2]|7[0-2])|" ."6(?:00|20|3[06]|6[017]|8[018]|90)|" ."7(?:00|50|7[0-2]|90)|" ."8(?:00|10|20|3[01]|40|50|60|70|8[01]|90)|" ."9(?:00|10|2[01]|3[0-2]|40|50|6[018]|7[01]|8[0-28]|9[0-2]))" .")",Denmark=>"(?k:0(?:800|" ."9(?:00|17|60|99))" ."|1(?:0(?:00|5[0-9]|6[0-9]|7[0-4]|9[2358])|" ."1(?:0[0-7]|1[0-9]|2[0-9]|3[01]|4[078]|5[0-9]|6[0-24-9]|" ."7[0-5])|" ."2(?:0[0-9]|1[013-9]|2[01]|40|5[013-79]|6[013-8]|7[01]|91)|" ."3(?:0[0-46-9]|1[0-9]|2[0-9]|5[02-9]|6[0-9]|7[01])|" ."4(?:0[0-36-9]|1[0-9]|2[0-9]|3[0-9]|4[018]|5[0-9]|" ."6[02-46-8]|7[0-2])|" ."5(?:00|13|3[23]|5[0-9]|6[0-46-9]|7[0-7]|9[29])|" ."6(?:0[0-46-9]|1[0-9]|2[0-4]|3[0-5]|5[0-9]|6[0-9]|7[0-7]|99)|" ."7(?:0[0-9]|1[0-24-9]|2[0-9]|3[0-9]|49|5[0-9]|6[0-6]|" ."7[0-57]|8[05-7]|9[09])|" ."8(?:0[0-9]|1[0-9]|2[02-9]|5[0-7]|6[0-8]|7[0-9])|" ."9(?:0[0-689]|1[0-7]|2[0-8]|5[0-9]|6[0-7]|7[0-4]))" ."|2(?:000|" ."1(?:00|50)|" ."200|" ."300|" ."4(?:00|50)|" ."500|" ."6(?:0[05]|10|2[05]|3[05]|40|50|6[05]|70|80|90)|" ."7(?:00|20|30|40|50|6[05]|70|91)|" ."8(?:00|20|30|40|50|60|70|80)|" ."9(?:00|20|30|42|50|60|70|80|90))" ."|3(?:0(?:00|50|60|70|80)|" ."1(?:00|20|40|50)|" ."2(?:00|10|20|30|50)|" ."3(?:00|10|20|30|60|70|90)|" ."4(?:00|50|60|80|90)|" ."5(?:00|20|40|50)|" ."6(?:00|30|50|60|70)|" ."7(?:00|20|30|40|51|60|70|82|90))" ."|4(?:0(?:00|30|40|50|60|70)|" ."1(?:00|30|40|60|7[134]|80|90)|" ."2(?:00|20|30|4[1-3]|50|6[12]|70|81|9[1356])|" ."3(?:00|20|30|40|50|60|70|90)|" ."4(?:00|20|40|50|60|70|80|90)|" ."5(?:00|20|3[24]|40|50|60|7[1-3]|8[13]|9[1-3])|" ."6(?:00|2[1-3]|32|40|5[2-4]|60|7[1-3]|8[1-4]|90)|" ."7(?:00|20|3[356]|50|60|7[1-3]|80|9[1-3])|" ."8(?:00|40|50|6[23]|7[1-4]|80|9[1245])|" ."9(?:00|1[23]|20|30|4[134]|5[1-3]|60|70|83|90))" ."|5(?:000|" ."2(?:00|10|20|30|40|50|60|70|90)|" ."3(?:00|20|30|50|70|80|90)|" ."4(?:00|50|6[2-46]|7[14]|85|9[12])|" ."5(?:00|40|50|60|80|9[12])|" ."6(?:00|10|20|31|42|72|83|90)|" ."7(?:00|50|62|7[12]|92)|" ."8(?:00|5[346]|63|7[14]|8[1-4]|92)|" ."9(?:00|3[25]|53|60|70|85))" ."|6(?:0(?:00|40|5[12]|64|70|9[1-4])|" ."100|" ."2(?:00|30|40|61|70|80)|" ."3(?:00|10|20|30|40|60|72|92)|" ."4(?:00|30|40|70)|" ."5(?:00|10|20|3[45]|41|60|80)|" ."6(?:00|2[1-3]|30|40|50|60|70|8[23]|90)|" ."7(?:0[05]|1[05]|20|31|40|5[23]|60|71|80|92)|" ."8(?:00|18|23|30|40|5[1-57]|62|70|80|93)|" ."9(?:00|20|33|40|50|60|7[13]|80|90))" ."|7(?:0(?:0[07]|80)|" ."1(?:00|20|30|40|50|60|7[13]|8[2-4]|90)|" ."2(?:00|50|60|70|80)|" ."3(?:00|2[13]|30|6[12])|" ."4(?:00|30|4[12]|51|70|80|90)|" ."5(?:00|40|50|60|70)|" ."6(?:00|20|50|60|73|80)|" ."7(?:00|30|4[12]|5[25]|60|70|90)|" ."8(?:00|30|40|50|60|70|84)|" ."9(?:00|50|60|70|80|90))" ."|8(?:000|" ."2(?:00|10|20|30|4[05]|50|60|70)|" ."3(?:0[05]|10|20|30|40|5[05]|6[12]|70|8[0-2])|" ."4(?:00|10|20|44|50|6[24]|7[12])|" ."5(?:00|20|30|4[134]|50|60|70|8[156]|92)|" ."6(?:00|20|32|4[13]|5[34]|60|70|80)|" ."7(?:00|2[1-3]|32|40|5[12]|6[2356]|8[13])|" ."8(?:00|3[0-2]|40|50|60|70|8[1-3])|" ."9(?:00|20|30|40|50|6[013]|70|8[13]|90))" ."|9(?:000|" ."2(?:00|10|20|30|40|60|70|80|93)|" ."3(?:00|10|20|30|40|52|62|70|8[0-2])|" ."4(?:00|30|40|60|80|9[023])|" ."5(?:00|10|20|30|41|50|60|7[45])|" ."6(?:00|10|20|3[12]|40|70|81|90)|" ."7(?:00|40|50|60)|" ."8(?:00|30|50|70|81)|" ."9(?:00|40|70|8[12]|90))" .")",France=>"(?k:0(?:1(?:0(?:0[0-9]|1[0-9]|20|59|6[019]|90)|1(?:0[0-9]|" ."1[0-25-7]|2[0-9]|30|40|5[0-58]|60|7[0-4]|90)|" ."2(?:0[0-468]|1[0-367]|20|30|40|50|60|70|80|90)|" ."3(?:0[0-36]|10|20|30|40|50|6[0569]|70|80|90)|4(?:00|" ."10|20|30|4[0-3]|50|60|70|80)|5(?:0[0-68]|10|40|50|60|" ."70|80|90)|6(?:0[0-46]|3[02378]|40|60|80)|7(?:0[0-8]|" ."10|50)|8(?:00|51)|9(?:21|60|90))|" ."2(?:0(?:0[0-9]|1[0-9]|2[05])|1(?:0[0-9]|10|20|30|40|5[01]|" ."60|70|90)|2(?:0[0-9]|10|20|30|40|50|60|70|90)|" ."3(?:0[0-39]|1[045]|2[0-79]|3[01]|40|50|60|70|80|90)|" ."4(?:0[0-79]|10|20|30|40|50|60|70|80|90)|5(?:00|10|20|" ."40|50|70|80|90)|6(?:0[0-49]|10|20|30|40|50|70|80|90)|" ."7(?:00|20|60|90)|8(?:00|10|20|30|40|50|60|70|80)|" ."93[09])|" ."3(?:0(?:0[03-8]|1[0-9]|21)|1(?:0[0-9]|10|20|30|40|50|60|" ."70|90)|2(?:0[0-9]|10|20|30|40|50|60|70|90)|" ."3(?:0[0-79]|1[01459]|2[019]|30|40|50|60|70|80|90)|" ."4(?:0[0-3569]|10|20|30|40|5[02]|60|70)|5(?:00|10)|" ."6(?:00|30)|700|800)|" ."4(?:0(?:0[0-69]|1[0-9]|29)|1(?:0[0-7]|1[09]|20|30|40|50|" ."60|70|80|90)|2(?:0[0-39]|10|20|30|40|50|60|70|80|90)|" ."3(?:0[01]|10|20|30|40|50|60|70|80)|4(?:00|10|20)|" ."5(?:00|10|30)|6(?:00|60)|700|8(?:00|50|60|70)|99[05])|" ."5(?:0(?:0[0-8]|1[0-24-69])|1(?:0[0-57]|10|20|30|40|50|60|" ."70|90)|2(?:0[0-289]|20|30|40|50|60|90)|3(?:00|10|20|" ."30|40|50|80)|4(?:00|60|70|80)|5(?:00|60)|600|700|800)|" ."6(?:0(?:0[0-9]|1[0-36]|3[2-6]|4[4-9]|5[03]|7[1389]|8[2-5]|" ."99)|1(?:0[0-35-9]|1[03-79]|2[156]|3[0-35-79]|4[0-3]|" ."5[0-7]|6[0-247]|7[0-357]|8[0-79]|90)|2(?:0[0-69]|" ."1[0-2]|2[0-9]|3[0-9]|4[0-2]|5[0-579]|60|7[0-2]|" ."8[1-46-9]|9[02-59])|3(?:0[0-69]|10|20|30|4[0-589]|" ."5[2-47-9]|6[049]|7[0-369]|80|9[0-2])|4(?:0[0-8]|1[04]|" ."20|30|40|50|60|70|80)|5(?:0[0-8]|1[013-8]|20|3[0-245]|" ."40|50|60|70|80|90)|6(?:0[0-79]|10|20|3[1-4]|40|50|" ."6[06]|70|90)|7(?:0[0-689]|10|2[13]|30|40|50|90)|" ."8(?:0[0-68]|10|2[569]|3[013]|50|91)|9(?:0[1-69]|" ."1[02-5]|2[12589]|50|99))|" ."7(?:00[0-7]|1(?:0[0-9]|10|20|3[0-9]|40|50|60|70|90)|" ."2(?:0[0-9]|10|20|30|40|50|60|70|90)|3(?:0[0-9]|10|20|" ."30|40|50|60|70|80)|4(?:0[0-9]|10|30|40|50|60|70)|" ."5(?:0[0-9]|10|20|30|60|70|80|90)|6(?:00|10|30|60|90)|" ."7(?:00|90)|800)|" ."8(?:0(?:0[0-6]|1[0134]|9[089])|1(?:0[1-79]|10|20|30|40|50|" ."60|70|90)|2(?:0[0-9]|10|20|30|40|50|60|70|90)|" ."3(?:0[02-5]|10|20|30|50|60|70|80|90)|4(?:00|10|30|40|" ."50|60)|500|600|700|800)|" ."9(?:0(?:0[0-47-9]|1[4-7])|1(?:0[0-59]|10|20|30|40|60|90)|" ."2(?:0[019]|10|20|30|40|50|70|90)|3(?:0[01]|10|20|30|" ."40|50|90)|4(?:0[01]|20|60)|500|600|700|800))" ."|1(?:0(?:0(?:0[0-9]|1[0-58]|2[56]|3[0-2]|42|8[0189]|9[126])|" ."1(?:0[0-5]|10|2[0-28]|30|40|5[0-4]|60|70|80|90)|" ."2(?:0[0-28]|10|20|30|40|50|60|70|80|90)|3(?:00|10|20|" ."30|40|5[0-35]|60|7[01]|80|90)|4(?:0[0-4]|10|20|3[0-3]|" ."40|50)|5(?:00|10)|60[0-356]|700|800|9(?:0[12]|10))|" ."1(?:0(?:0[0-579]|1[0-25-7]|2[0-29])|1(?:0[0-9]|10|20|30|" ."40|50|60|70|90)|2(?:0[0-589]|10|20|30|40|50|60|70|90)|" ."3(?:0[0134]|10|20|30|40|50|60|70|80|90)|4(?:0[0-29]|" ."10|20|30|40|5[1-3]|80|9[0-4])|5(?:00|10|40|60|70|80|" ."90)|6(?:00|10|20)|7(?:00|8[12459]|90)|8(?:0[0235-8]|" ."1[06]|23|3[3568]|48|5[05]|60|7[05-8]|8[05]|9[08]))|" ."2(?:0(?:0[0-357-9]|19|2[0-9]|3[0-59]|40)|1(?:0[0-4689]|10|" ."20|30|40|50|60|70|90)|2(?:0[0-4]|10|20|30|40|50|60|70|" ."90)|3(?:00|10|20|30|40|50|60|70|80|90)|4(?:0[0-2]|10|" ."20|30|40|50|60|70|80|90)|5(?:00|10|20|40|50|60|80)|" ."6(?:00|20|30|40)|7(?:00|20|40|80)|8(?:00|50))|" ."3(?:0(?:0[0-9]|1[0-6]|20|6[67]|8[0589]|9[0-9])|1(?:0[0-9]|" ."1[0-9]|2[0-46-9]|3[0-389]|4[0-289]|5[0-35-9]|" ."6[013-589]|7[078]|8[0-2]|9[0-26])|2(?:0[0-3579]|" ."1[013-9]|2[0-8]|3[0-69]|4[0-589]|5[0-9]|6[0-9]|7[0-9]|" ."8[0-24-9]|9[0-9])|3(?:0[0-46-9]|1[0-9]|2[0-8]|" ."3[0-589]|4[02-8]|5[0-24-79]|6[0-46-9]|7[0-24-9]|" ."8[0-9]|9[0-79])|4(?:0[0-46]|1[0-7]|2[014-68]|3[0-245]|" ."4[0-8]|5[0-8]|6[02-47]|7[0-48]|8[0-49]|9[03])|" ."5(?:0[0-3]|1[0-4689]|2[0-589]|3[0-389]|4[0-35-9]|" ."5[0-289]|6[06-8]|7[02]|8[013]|9[0-49])|6(?:0[0-9]|" ."1[0-24-79]|2[015-9]|3[0-357]|4[0-369]|5[0-689]|6[0-9]|" ."7[0-8]|8[013-57-9]|9[0-9])|7(?:0[0-589]|1[02-9]|" ."2[0-9]|3[0-3]|4[0-79]|5[0-257-9]|6[046]|7[0-9]|" ."8[0-59]|9[0-9])|8(?:0[0-9]|1[02-5]|2[0-589]|3[0-689]|" ."4[0-24-7]|5[0-9]|6[0-478]|70|8[01379]|9[05])|" ."9(?:0[024-8]|1[01]|2[0-4]|3[0-37]|4[0-2]|50|60|80|90))|" ."4(?:0(?:0[05-9]|1[0-9]|2[03-9]|3[0-9]|4[05-8]|5[0-489]|" ."6[1-7]|7[04-9]|8[1-69]|9[0-9])|1(?:0[0-9]|1[0-47]|" ."2[0135-8]|30|40|50|6[0-258]|70|90)|2(?:0[0-57-9]|10|" ."20|30|40|50|60|70|80|90)|3(?:10|20|30|40|50|60|70|80|" ."90)|4(?:0[0-9]|10|20|30|40|50|6[0-29]|70|80|90)|" ."5(?:0[0-589]|10|20|30|40|50|70|90)|6(?:0[0-3]|10|20|" ."30|40|5[0-49]|70|80|90)|7(?:00|10|30|40|50|60|70|80|" ."9[01])|8(?:0[0-9]|10|30|40|50|60|80)|9(?:0[1-9]|" ."1[0-69]|2[0-6]|3[0-4]|4[09]|50|60|70|80|90))|" ."5(?:0(?:0[0-8]|1[0-57-9])|1(?:0[0-79]|10|20|30|40|50|60|" ."70|90)|2(?:00|10|2[09]|30|40|50|60|70|90)|3(?:00|10|" ."20|40|50|80)|4(?:00|30)|5(?:00|90)|600|700|800)|" ."6(?:0(?:0[0-8]|1[0-9]|2[0-6])|1(?:0[0-9]|1[0-3]|2[01]|30|" ."40|50|60|70|90)|2(?:00|10|20|30|40|50|60|70|90)|" ."3(?:00|10|20|30|40|50|60|70|80|90)|4(?:00|10|20|30|40|" ."50|60|70|80|90)|5(?:00|10|60|70|90)|6(?:00|20)|7(?:00|" ."10|20|30)|800|9(?:0[1-9]|1[0-9]|2[09]|5[0-59]|99))|" ."7(?:0(?:0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-5]|5[1-6]|" ."7[1-689]|8[6-9])|1(?:0[0-9]|1[0-9]|2[013]|3[0236-9]|" ."40|50|60|70|8[0-9]|90)|2(?:0[0-9]|1[0145]|20|30|40|50|" ."60|70|8[1459]|90)|3(?:0[0-9]|1[0-4]|20|30|40|50|60|70|" ."80|90)|4(?:00|1[0-69]|20|30|4[0-69]|50|60|70|80|90)|" ."5(?:0[0-49]|10|20|30|40|50|60|70|80|90)|6(?:00|10|20|" ."30|40|50|70|90)|7(?:00|30|40|50|70|80)|8(?:00|10|40|" ."70|80|90)|9(?:20|40))|" ."8(?:0(?:0[0-7]|1[2-69]|2[0-9]|3[0-79])|1(?:0[0-9]|10|20|" ."30|40|50|60|70|90)|2(?:0[0-7]|10|20|30|40|50|60|70|" ."90)|3(?:00|10|20|30|40|50|60|70|80|90)|4(?:00|10)|" ."5(?:00|10|20|70)|600|700|800|9(?:1[01]|2[02-4]|3[459]|" ."4[015]|98))|" ."9(?:0(?:0[0-79]|1[1257-9]|33)|1(?:0[0-9]|1[01346-9]|20|30|" ."40|50|60|70|90)|2(?:0[0-489]|10|20|3[0-2]|40|50|60|70|" ."90)|3(?:00|1[0-9]|20|30|40|50|6[01]|70|80|90)|4(?:00|" ."10|30|50|60|70|90)|5(?:00|10|20|50|60)|600|700|800))" ."|2(?:0(?:0(?:00|90)|1(?:00|1[0-9]|2[1-9]|3[0-9]|4[0-8]|5[0-37]|" ."6[02-9]|7[0-9]|8[0-9]|9[0-57-9])|2(?:00|1[2-57-9]|" ."2[0-9]|3[0-9]|4[02-8]|5[0-369]|60|7[02569]|8[7-9]|" ."9[0-9])|3(?:0[2-69]|11)|4(?:0[1-35-9]|1[0-46-9])|" ."5(?:0[1-4]|3[78])|6(?:0[014]|11|20)|70[0-3]|900)|" ."1(?:0(?:0[0-9]|1[0-9]|2[1-9]|3[0-9]|4[0-9]|5[1-9]|" ."6[0-35-9]|7[0-9]|8[013-689]|9[2378])|1(?:10|2[01]|30|" ."40|50|60|70|90)|2(?:0[0-9]|1[09]|20|30|40|50|6[0-2]|" ."70|90)|3(?:0[0-59]|10|20|30|40|50|60|70|80|90)|" ."4(?:0[0-39]|10|20|30|40|50|60|70|90)|5(?:0[0-269]|10|" ."20|30|40|50|60|70|80|90)|6(?:0[0-49]|10|30|40|90)|" ."7(?:0[0-59]|19|60)|8(?:0[0-369]|20|50)|9(?:00|10|98))|" ."2(?:0(?:0[0-5]|1[4-7]|2[1-79]|3[1-5]|4[1-69]|7[09]|8[09]|" ."9[1-35689])|1(?:0[0-9]|1[01]|20|30|40|50|60|70|" ."9[0-69])|2(?:0[0-69]|10|20|30|40|50|60|70|90)|" ."3(?:0[0-9]|10|20|30|40|50|60|70|80|90)|4(?:0[02-59]|" ."10|20|30|40|50|60|70|80|90)|5(?:0[0-59]|10|20|30|40|" ."50|60|70|80|90)|6(?:0[02-79]|10|20|30|40|50|60|80|90)|" ."7(?:00|10|20|30|40|50|70|80)|8(?:00|10|20|30|60|70)|" ."9(?:30|40|50|60|70|80))|" ."3(?:0(?:0[0-9]|1[13-6]|20)|1(?:00|10|20|30|40|50|60|70|" ."90)|2(?:00|10|20|30|40|50|60|70|90)|3(?:00|20|40|50|" ."60|80)|4(?:00|20|30|50|60|80)|500|600|700|800)|" ."4(?:0(?:0[0-579]|1[0-79]|2[0249]|5[0-359]|60)|" ."1(?:0[0-24-9]|1[0-4]|2[0-2]|30|40|50|60|70|90)|" ."2(?:0[0-689]|1[02]|20|30|40|50|60|70|90)|3(?:00|10|20|" ."30|40|50|60|70|80|90)|4(?:00|10|20|30|40|50|60|70|80|" ."90)|5(?:00|10|20|30|40|50|60|70|80|90)|6(?:00|10|20|" ."30|40|50|60|80)|7(?:00|5[0-2589])|800|9(?:1[0235]|26))|" ."5(?:0(?:0[0-9]|1[0-9]|2[0-79]|3[0-9]|4[0-9]|5[0-246-9]|" ."6[0-389]|7[0-359]|8[02-79]|9[089])|1(?:1[0-9]|20|30|" ."40|50|60|70|90)|2(?:0[0-9]|1[0-9]|20|30|40|50|60|70|" ."90)|3(?:0[0-49]|10|20|30|40|50|60|70|80|90)|" ."4(?:0[0-69]|10|20|30|40|50|6[0-29]|7[09]|80|90)|" ."5(?:0[0-489]|10|20|30|50|60|70|80)|6(?:0[0-9]|10|20|" ."30|40|50|60|80|90)|7(?:0[0-26-9]|20|50|70|90)|8(?:00|" ."20|40|70)|9(?:09|20|3[0-3]|60))|" ."6(?:0(?:0[0-9]|1[0-5]|2[1-9]|3[0-2])|1(?:0[0-9]|1[019]|20|" ."3[01]|40|50|60|70|9[09])|2(?:0[0-9]|1[056]|20|30|" ."4[0-49]|50|60|70|90)|3(?:0[0-49]|10|20|30|40|50|80|" ."90)|4(?:0[0-29]|10|20|50|60|70)|5(?:0[0-49]|10|30|40|" ."60|70)|6(?:0[0-39]|20)|7(?:0[0-29]|30|40|50|6[01]|70|" ."80|90)|80[0-29]|9(?:0[1-79]|5[0-68]))|" ."7(?:0(?:0[0-9]|1[0235-9]|2[1-356]|3[0-9]|40|9[0-9])|" ."1(?:0[0-9]|10|2[0-27]|3[0-8]|40|50|60|70|80|90)|" ."2(?:0[0-9]|10|20|30|40|50|60|70|90)|3(?:0[0-9]|10|20|" ."30|40|50|60|70|80|90)|4(?:0[0-79]|10|20|30|40|50|60|" ."70|80|90)|5(?:0[0-9]|10|20|30|40|50|60|70|80|90)|" ."6(?:0[07]|10|20|30|40|50|60|70|80|90)|7(?:0[0-35]|10|" ."20|30|40|50|60|70|80|90)|8(?:00|10|20|30|50|60|70|90)|" ."9(?:09|1[014]|2[0489]|3[0-369]|4[09]|50))|" ."8(?:0(?:0[0-9]|1[189]|2[3-69]|3[3-9]|4[04]|8[08])|" ."1(?:0[0-689]|1[0-49]|20|3[0-3]|40|50|60|70|90)|" ."2(?:0[0-3579]|1[01]|20|3[0-24]|40|50|60|70|90)|" ."3(?:0[0-59]|10|20|30|40|50|60|80)|4(?:0[0-49]|10|" ."8[019])|50[01]|6(?:00|3[0-3679])|70[0-379]|800|9(?:01|" ."10|20|3[0-35]|44|50))|" ."9(?:0(?:00|18|80)|1(?:0[0-9]|2[0-59]|40|50|60|7[0-4679]|" ."8[0-79]|9[0-369])|2(?:0[06-9]|1[0-37-9]|2[0-57-9]|" ."3[138]|4[0-26]|5[0239]|60|70|8[029]|9[09])|3(?:00|10|" ."2[0-8]|3[0-7]|40|50|60|70|80|9[0-9])|4(?:0[0-4679]|" ."1[0-49]|20|30|40|5[05]|60|70|80|90)|5(?:00|10|20|30|" ."40|5[0-9]|6[013]|70|90)|6(?:0[0269]|10|20|30|40|50|60|" ."7[0-489]|8[0-2489]|90)|7(?:00|10|20|30|40|50|60|70|80|" ."90)|8(?:0[0-46-9]|10|2[0457]|3[03-79]|40|50|60|70|80|" ."90)|9(?:00|10|20|30|40|50|70|80|90)))" ."|3(?:0(?:0(?:0[0-36-9]|1[0-9]|2[0-589]|3[1-69]|4[04589]|" ."5[015])|1(?:0[0-79]|1[0-2459]|2[0-9]|3[0-49]|40|50|60|" ."70|90)|2(?:0[0-79]|10|20|30|40|5[0-35]|60|70|90)|" ."3(?:0[0-2]|1[01389]|20|30|40|50|60|80|90)|4(?:0[0-69]|" ."10|20|30|40|50|60|70|80|90)|5(?:00|10|20|30|40|60|70|" ."80)|6(?:00|10|20|30|40|50|60|70)|7(?:0[0-3]|20|30|40|" ."50|60|70)|8(?:00|20|40|70)|9(?:0[013-8]|1[0-48]|" ."2[0-59]|3[124-79]|4[0-37]|6[09]|7[125]|80))|" ."1(?:0(?:0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]|6[0-9]|" ."7[0-9]|8[0-24-689]|9[0-9])|1(?:0[0-4679]|1[02]|2[0-9]|" ."3[0-9]|4[0-29]|5[0-259]|60|70|8[09]|90)|2(?:0[013-5]|" ."10|20|30|4[0-59]|50|60|70|8[09]|90)|3(?:00|1[02-579]|" ."2[0-2569]|30|40|50|60|70|8[09]|90)|4(?:0[0-6]|10|20|" ."3[02]|40|50|60|70|8[09]|90)|5(?:0[03-7]|1[02]|" ."2[0-249]|30|40|50|60|70|8[09]|90)|6(?:0[0-689]|2[019]|" ."50|60|7[0-9]|8[1-359]|92)|7(?:0[0-9]|1[1256]|50|" ."7[0-4679]|80|90)|8(?:0[0-79]|10|20|3[0-29]|40|50|60|" ."70|80)|9(?:0[0-3]|31|4[57]|5[078]|6[02]|9[89]))|" ."2(?:0(?:0[0-57-9]|1[0-46-9]|2[0-2])|1(?:00|10|2[09]|30|40|" ."50|60|70|90)|2(?:0[019]|20|30|40|50|60|70|90)|3(?:00|" ."10|20|30|40|50|60|70|80|90)|4(?:00|10|20|30|40|50|60|" ."80|90)|5(?:0[0-259]|50)|600|7(?:00|20|30)|8(?:00|10))|" ."3(?:0(?:0[0-24-9]|1[0-259]|2[013-9]|3[0-8]|4[0-37-9]|" ."5[0-9]|6[0-9]|7[0-9]|8[0-9]|9[0-9])|1(?:00|1[02-6]|" ."2[013-7]|3[038]|4[018]|5[0-35]|6[04-79]|7[0-5]|" ."8[05-7]|9[0-3])|2(?:00|1[0-49]|20|30|40|50|60|" ."7[0-489]|9[0-5])|3(?:0[0569]|1[0-49]|2[0-4679]|3[05]|" ."4[01]|50|60|70|80|9[0-5])|4(?:0[0-59]|10|20|30|40|" ."5[0-2]|6[019]|70|80|9[0-25])|5(?:0[0-79]|1[05]|" ."2[0-79]|30|40|50|6[0-5]|70|80|90)|6(?:0[0-9]|1[0-5]|" ."2[015-79]|40|5[02]|60|70|8[089]|9[0-9])|7(?:0[0-9]|10|" ."20|3[0-9]|4[017]|50|60|70|80|90)|8(?:0[01]|10|20|30|" ."40|50|60|70|8[0-7]|90)|9(?:0[0-79]|1[0-589]|20|30|50|" ."70|80|9[08]))|" ."4(?:0(?:0[0-46-9]|1[0-2]|2[3-8]|3[02-57-9]|4[0-35689]|" ."5[13-68]|6[0-8]|7[0-9]|8[0235-79]|9[0-9])|1(?:1[0-9]|" ."20|3[0-27-9]|40|50|60|7[0-489]|8[13467]|9[0-9])|" ."2(?:0[0-479]|10|20|30|40|50|6[0-7]|7[04]|80|9[03-9])|" ."3(?:0[0-579]|10|20|30|40|50|60|70|80|9[0-46-9])|" ."4(?:0[0-49]|10|20|3[013-589]|40|50|60|7[037]|80|90)|" ."5(?:0[0-8]|1[03-8]|2[0-69]|3[04-79]|4[03-5]|50|6[04]|" ."70|90)|6(?:00|10|20|30|50|60|7[01]|80|90)|7(?:0[0-2]|" ."10|2[05]|30|4[0-27-9]|5[013]|60|70|90)|8(?:00|10|20|" ."30|50|7[1-5]|80)|9(?:00|2[0356]|3[2-57-9]|4[02-489]|" ."5[4-9]|6[0-2457]|7[02-57]|8[0-79]|90))|" ."5(?:0(?:0[0-9]|1[0-24-68]|2[0-46-9]|3[0-59]|4[02-79]|" ."5[0-57-9]|6[3-79]|7[013689]|8[0-9]|9[0-49])|" ."1(?:0[1-689]|1[134]|20|3[0-7]|40|50|6[0-469]|" ."7[0-24-7]|90)|2(?:0[0-57-9]|10|2[01]|3[056]|40|50|60|" ."70|90)|3(?:0[0-69]|10|20|30|4[0-259]|50|60|70|80|90)|" ."4(?:0[0-9]|1[0-9]|20|3[0-359]|40|50|60|70|80|90)|" ."5(?:0[0-79]|1[0-9]|2[01]|3[0-389]|40|50|60|7[1-46-9]|" ."80|90)|6(?:0[0-356]|10|20|30|40|5[0-39]|60|80|90)|" ."7(?:0[0-9]|11|20|30|4[0-46]|50|6[0-9]|7[0-2]|80)|" ."8(?:0[0-3]|3[0-3]|50|70|90)|9(?:0[0-9]|1[1-9]|2[01]|" ."60|98))|" ."6(?:0(?:0[0-9]|1[0-9]|2[0-9]|3[23])|1(?:0[0-579]|10|20|" ."3[01]|40|50|60|70|80|90)|2(?:00|10|20|30|40|5[05]|60|" ."70|90)|3(?:0[01]|10|20|30|40|50|60|70)|400|50[015]|" ."600|700|800|91[05])|" ."7(?:0(?:0[089]|1[0-9]|2[05-9]|3[2-589]|4[0-57-9]|5[89]|" ."6[01]|7[1-9]|8[0-29]|9[5-9])|1(?:00|10|20|30|40|5[02]|" ."60|7[0-59]|90)|2(?:0[04-69]|10|20|30|40|50|60|70|90)|" ."3(?:0[0-69]|10|2[01]|30|40|50|60|70|80|90)|" ."4(?:0[0-49]|20|60)|5(?:0[0-29]|10|2[01]|30|4[0-29]|" ."5[0-6])|60[0-29]|70[0-359]|800|9(?:1[0-357]|2[124-9]|" ."3[12]|4[12]))|" ."8(?:0(?:0[0-9]|1[0-9]|2[1-9]|3[0-79]|4[0-9]|5[0-4689]|" ."6[135-79]|7[047]|8[019]|9[0-36-9])|1(?:00|1[02-489]|" ."2[0-2]|3[048]|4[0246-8]|5[02-49]|6[0-59]|7[0-469]|80|" ."9[0167])|2(?:0[0-9]|1[016-9]|20|3[0-26]|4[0-469]|" ."5[06]|6[019]|70|80|9[0-35-79])|3(?:0[0-579]|1[1-579]|" ."2[0-2679]|3[0-4]|4[0-35-79]|5[0-46-9]|6[01]|70|80|90)|" ."4(?:0[0-9]|10|20|3[0-79]|40|50|60|70|80|90)|" ."5(?:0[0-9]|1[0169]|2[0-469]|30|40|5[0-79]|60|70|80|" ."9[01])|6(?:0[0-39]|10|20|30|40|50|60|70|80|90)|" ."7(?:0[0-26-9]|10|3[01]|40|50|6[01379]|70|8[0-249]|90)|" ."8(?:0[0-3]|1[67]|21|30|40|50|60|70|80|90)|9(?:00|13|" ."2[0167]|30|4[0134]|50|60|70|80))|" ."9(?:0(?:0[0-9]|1[056]|2[19]|3[0-9])|1(?:0[0-9]|10|20|30|" ."40|50|60|7[01]|8[019]|90)|2(?:0[0-9]|1[019]|20|30|40|" ."50|6[01]|70|90)|3(?:0[0-9]|10|20|30|50|60|70|80)|" ."4(?:0[0-9]|10|60)|5(?:0[0-2]|20|70)|60[0-359]|700|" ."80[0-9]))" ."|4(?:0(?:0(?:0[0-6]|1[1-35-9]|2[1-7]|90)|1(?:0[0-8]|1[058]|20|" ."30|4[01]|50|6[01]|70|80|90)|2(?:0[0-2]|10|20|3[0-259]|" ."40|50|60|70|8[0-26]|90)|3(?:0[0159]|10|20|30|50|60|70|" ."80|90)|4(?:00|10|20|30|40|6[05]|80)|5(?:0[0-2]|10|30|" ."50|60)|6(?:0[0-2]|30|60)|70[015]|80[015]|99[0-4])|" ."1(?:0(?:0[0-9]|1[0-35689]|2[0235689]|3[3-5]|4[23])|" ."1(?:0[0-3569]|10|2[0-2]|30|40|5[01]|60|70|90)|" ."2(?:0[0-7]|10|20|30|40|50|6[01]|70|90)|3(?:00|10|20|" ."30|5[03-57]|60|70)|40[0-26]|500|600|700|800|" ."9(?:0[13-689]|1[03-589]|2[145]|3[0-36]|4[1-3589]|" ."5[018]|6[03-8]|7[0-6]))|" ."2(?:0(?:0[0-9]|1[0-8]|2[1-9]|3[013]|4[1-357-9]|5[0589])|" ."1(?:00|1[014]|2[02-79]|3[01]|40|5[0235]|6[0-9]|" ."7[03469]|90)|2(?:10|20|30|40|60|7[0-35-79]|90)|" ."3(?:0[0-48]|1[0-58]|2[0-38]|3[02-59]|40|5[013-69]|60|" ."70|80|90)|4(?:0[0-9]|1[0-2]|20|30|40|50|60|70|8[0469]|" ."90)|5(?:0[0-359]|10|20|30|40|50|60|70|80|90)|" ."6(?:0[0-9]|10|20|30|40|5[013]|60|70|80)|7(?:0[0-579]|" ."20|40|50|80)|8(?:0[0-9]|10|20|30|40|90)|9(?:20|40|" ."5[0-589]|6[1-9]|90))|" ."3(?:0(?:0[0-689]|1[0-479])|1(?:0[0-3]|10|20|30|40|50|60|" ."70|90)|2(?:0[0-3]|10|20|30|40|50|60|70|90)|3(?:00|20|" ."30|40|50|60|70|80|90)|4(?:00|10|20|30|40|50|90)|" ."5(?:00|10|20|30|50|80|90)|6(?:00|20)|7(?:00|50|70)|" ."8(?:00|10))|" ."4(?:0(?:0[0-9]|1[0-9]|2[0-4]|3[2-68]|4[0-267]|9[02-579])|" ."1(?:0[0-79]|1[05-9]|2[0-469]|30|4[0-69]|5[0-9]|60|" ."7[069]|8[4-8]|9[0-689])|2(?:0[0-59]|1[0-79]|20|" ."3[0-69]|4[0-59]|50|6[0-358]|7[02-7]|90)|3(?:0[0-9]|" ."1[0-9]|2[0-9]|3[0-9]|4[0-69]|5[0-36-9]|60|7[0-39]|80|" ."90)|4(?:0[0-9]|1[02]|20|30|40|50|60|7[0-9]|8[0-4]|90)|" ."5(?:0[0-69]|10|2[0-2]|30|40|50|60|70|80|90)|" ."6(?:0[0-69]|1[0-8]|20|30|40|50|60|70|80|90)|" ."7(?:0[0-36-9]|10|20|30|40|50|60|70|80)|8(?:0[0-9]|" ."1[0-9]|2[1-49]|30|40|50|60|80)|9(?:00|1[1-9]|2[1-9]|" ."3[1-9]|4[124579]|5[1-9]|6[3-9]|7[1-8]|8[0-69]))|" ."5(?:0(?:0[0-9]|1[0-25-79]|2[13589]|3[0-58]|4[0-6]|" ."5[236-8]|6[0-57-9]|7[1-57-9]|8[1278])|1(?:00|10|" ."2[0-259]|30|4[0-79]|50|6[0-689]|70|90)|2(?:0[0-9]|" ."1[0-4]|20|30|40|50|60|70|90)|3(?:0[02-8]|1[02]|20|" ."3[01]|40|60|70|80|90)|4(?:0[0-469]|10|20|3[0-3]|50|60|" ."70|80|90)|5(?:0[0-4]|10|20|30|50|60|70|90)|6(?:00|20|" ."30|40|5[0156]|80)|7(?:0[0-29]|20|30|40|50|60|" ."7[01457])|8(?:0[0-9]|11)|9(?:00|1[0-35-9]|2[0-79]|" ."3[0-8]|4[3-9]|5[0-7]|6[0-9]|7[0-9]|80))|" ."6(?:0(?:0[0-589]|1[04-9]|2[0-3]|9[01])|1(?:0[0-36]|10|20|" ."30|40|50|60|70|90)|2(?:00|10|20|30|40|50|60|70)|" ."3(?:00|10|20|30|40|50|60)|400|500|600|700|800)|" ."7(?:0(?:0[02-8]|13|2[03]|3[0-29])|1(?:10|20|30|40|50|60|" ."70|80|90)|2(?:0[0-57-9]|1[013]|20|30|40|50|60|70|90)|" ."3(?:0[0-57-9]|10|20|30|40|50|60|70|80|90)|4(?:00|10|" ."20|30|40|50|70|80)|5(?:0[0-2]|10|20|5[0-359])|600|700|" ."800|9(?:0[19]|1[0-8]|2[0-59]|31))|" ."8(?:00[0-35-9]|1(?:00|10|20|30|40|50|60|70|90)|2(?:00|10|" ."20|30|40|50|60|70)|3(?:00|10|20|30|40|70)|400|500|600|" ."700|800)|" ."9(?:0(?:0[0-46-9]|1[014-8]|2[0-468]|3[2356]|4[13-79]|" ."5[1-359]|66|7[0-29]|80)|1(?:0[0-79]|1[0-25-79]|" ."2[02-5]|3[05-79]|40|50|60|70|8[0-4]|90)|2(?:20|30|" ."4[0-59]|50|60|70|80|90)|3(?:0[0-9]|1[0-249]|2[0157-9]|" ."30|40|50|60|70|80|90)|4(?:0[0-689]|1[0-578]|2[015-8]|" ."30|40|5[068]|60|8[0146]|90)|5(?:0[0-59]|10|20|30|40|" ."60|70|90)|6(?:0[0-29]|10|20|30|40|50|60|70|80|90)|" ."7(?:00|10|30|40|50|70)|80[0-59]|9(?:0[56]|1[1-39]|" ."2[57]|3[347-9]|4[19])))" ."|5(?:0(?:0(?:0[0-9]|1[0-6]|50)|1(?:0[0-9]|1[03-5]|20|3[01]|40|" ."50|60|70|80|90)|2(?:0[0-9]|1[01]|20|30|40|50|60|70|" ."90)|3(?:0[0-9]|10|20|30|40|50|60|70|80|90)|" ."4(?:0[0-79]|10|20|30|4[0-24-9]|50|60|70|80|90)|5(?:00|" ."10|20|30|40|50|60|70|80|90)|6(?:00|10|20|30|40|5[12]|" ."60|70|80|90)|7(?:00|10|20|30|40|50|60|70)|8(?:00|10|" ."40|50|60|70|80|90)|95[018])|" ."1(?:0(?:0[015-9]|1[0-367]|2[12]|3[5-9]|4[1-3]|5[1-9]|" ."6[0-9]|7[0-79]|8[0-46-9]|9[025-79])|1(?:00|10|2[0-2]|" ."30|40|50|60|70|90)|2(?:0[0-9]|10|20|30|40|50|60|70|" ."90)|3(?:0[0-689]|1[089]|20|3[0-4]|4[09]|50|6[01]|70|" ."80|90)|4(?:0[01]|20|3[0-5]|50|60|70|80|90)|5(?:00|10|" ."20|30|7[1-3])|6(?:0[01]|6[2-4]|7[357-9]|8[2-9])|" ."7(?:00|1[35]|2[1-36])|8(?:0[01]|7[13]|8[46])|90[024])|" ."2(?:0(?:0[0-8]|1[1246])|1(?:0[0-9]|1[0-35]|20|30|40|50|60|" ."70|90)|2(?:0[0-9]|10|20|30|40|50|60|70|90)|3(?:0[01]|" ."10|20|30|40|60|70)|4(?:00|10)|50[0-2]|600|700|800|" ."9(?:0[1-6]|1[579]|20))|" ."3(?:0(?:0[0-9]|1[02-69]|2[0-2]|3[0-2]|6[0-39]|73|8[0-9]|" ."9[013-589])|1(?:0[0-59]|10|20|40|50|60|70|90)|" ."2(?:0[0-5]|10|20|30|40|50|60|70|90)|3(?:00|20|40|50|" ."60|70|80|90)|4(?:00|10|20|40|70|80)|5(?:00|40)|" ."6(?:0[0-2]|40)|700|8(?:00|1[01])|9(?:4[0-2]|5[01]|60|" ."7[01]))|" ."4(?:0(?:0[0-9]|1[0-7]|2[0-39]|3[125-9]|4[1-35-9]|5[2-46]|" ."6[2-4]|7[1-46]|82|9[6-8])|1(?:00|1[0-689]|2[0-39]|" ."3[0-689]|40|5[0-49]|60|70|8[0-69]|90)|2(?:0[0-69]|" ."1[01]|20|30|40|50|6[0-3]|7[0-39]|80|90)|3(?:0[0-59]|" ."1[0-29]|20|30|40|50|60|70|8[05]|90)|4(?:0[0-69]|" ."1[0-4]|2[05]|30|40|50|60|70|80|90)|5(?:0[0-79]|" ."1[0-79]|2[0-9]|30|40|50|60|70|80|90)|6(?:0[0-389]|10|" ."20|30|40|50|60|70|80|90)|7(?:0[0-689]|1[0-69]|20|30|" ."40|50|60|70|80|90)|8(?:0[0-3]|10|20|30|40|50|60|70|80|" ."90)|9(?:00|10|20|3[01349]|4[01]|50|60|70|80|90))|" ."5(?:0(?:0[0-35-8]|1[2-5]|2[01])|1(?:0[0-9]|1[0239]|20|30|" ."40|50|60|70|90)|2(?:0[0-35]|10|2[01]|30|40|50|60|" ."7[01]|90)|3(?:00|10|20)|4(?:00|30)|500|600|700|8(?:00|" ."40))|" ."6(?:0(?:0[0-9]|1[06-9]|2[09]|3[46-9])|1(?:0[0-9]|10|20|30|" ."40|50|60|7[0-589]|90)|2(?:0[01479]|19|20|3[019]|40|50|" ."60|7[0-79]|90)|3(?:0[0-9]|1[0-279]|2[0-9]|30|4[0-39]|" ."50|60|70|8[0-3]|90)|4(?:0[0-79]|1[0139]|20|30|40|50|" ."60|70|80|90)|5(?:0[0-469]|10|20|3[0-2569]|40|50|60|70|" ."80|90)|6(?:0[0-379]|10|20|30|40|50|60|70|80|90)|" ."7(?:0[0-59]|30|40|50|60|70|80)|8(?:0[0-59]|40|5[045]|" ."60|70|80|9[0-369])|9(?:0[0-39]|10|20|30|5[014679]|" ."7[0379]|98))|" ."7(?:0(?:0[03-9]|1[0-9]|2[0138]|3[0-8]|4[014-69]|5[0-4679]|" ."6[1-3]|7[0-9]|8[1-4])|1(?:0[0-689]|19|2[05-9]|3[0-3]|" ."4[0146-9]|5[0-579]|6[0-49]|7[05]|8[015]|9[0-39])|" ."2(?:0[0-9]|1[124-9]|20|3[0-4]|4[05]|5[05]|60|70|" ."8[0-39]|9[0-29])|3(?:0[0-49]|10|20|30|40|5[0-249]|" ."6[0-359]|7[0-39]|8[0-35]|90)|4(?:0[0-59]|1[025]|20|30|" ."4[05]|5[05]|60|70|80|90)|5(?:0[0-9]|1[05]|2[05]|3[05]|" ."40|50|6[05]|70|80|90)|6(?:0[0-9]|1[09]|20|3[05]|4[05]|" ."5[05]|60|70|8[05]|90)|7(?:0[0-59]|10|20|3[019]|4[078]|" ."5[167]|7[02478]|80|90)|8(?:0[013-59]|1[05]|20|30|40|" ."5[05]|6[05]|70|80|90)|9(?:05|1[0-3569]|2[05]|3[05]|40|" ."5[0-57-9]|60|7[0-489]|80|90))|" ."8(?:0(?:0[0-9]|1[3-9]|2[02-9]|3[3469])|1(?:10|20|30|40|50|" ."60|70|80|90)|2(?:0[0-9]|10|20|30|40|50|60|70|90)|" ."3(?:0[0-2]|10|20|30|40|50|60|70|80|90)|4(?:0[0-5]|10|" ."20|30|40|50|60|70|90)|5(?:0[0-38]|30)|6(?:00|4[0-39]|" ."60)|700|800)|" ."9(?:0(?:0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[1-9]|" ."6[0-3569]|7[0-489]|8[0-46-8]|9[127])|1(?:0[08]|1[0-9]|" ."2[0-9]|3[0-9]|4[0-9]|5[0-9]|6[0-9]|7[0-9]|8[0-24-9]|" ."9[0-589])|2(?:0[0237-9]|1[0-9]|2[0-79]|3[0-9]|4[0-79]|" ."5[0-589]|6[0-9]|7[0-57-9]|8[0-8]|9[02-79])|3(?:0[0-9]|" ."1[0-9]|2[0-2689]|3[0-9]|4[1569]|5[0189]|6[0-5]|" ."7[03-9]|8[0-3569]|9[0-39])|4(?:0[0-9]|1[0-369]|" ."2[0-24-9]|3[0-35-7]|4[0-9]|5[0-35-8]|6[0-8]|7[0-689]|" ."8[0-35-7]|9[0-7])|5(?:0[0-9]|10|2[02-49]|3[0-25-7]|" ."4[0-4]|5[0-57-9]|6[0-47-9]|7[0-3]|8[0-46-9]|90)|" ."6(?:0[0-8]|1[0-38]|20|3[0579]|40|5[0-9]|6[0-79]|" ."7[0-37]|8[0-35-79]|90)|7(?:0[0-9]|1[0-9]|2[0-367]|" ."3[0-5]|40|50|60|7[079]|8[0-57-9]|9[0-2])|8(?:00|" ."1[0-8]|20|3[0-289]|4[057-9]|5[0-39]|6[0-9]|7[0-8]|" ."8[0-579]|9[0-9])|9(?:00|10|20|3[0-3]|4[0-48]|5[0-2]|" ."6[0-57]|7[0-2569]|8[014]|9[08])))" ."|6(?:0(?:0(?:0[024-9]|1[0-9]|2[1-9]|3[15])|1(?:0[0-9]|1[0-9]|" ."2[0-36-9]|3[0-248]|4[019]|5[0357]|6[02]|7[035]|" ."8[013-5]|90)|2(?:0[0-9]|10|20|30|40|5[0-2]|60|7[01]|" ."8[01]|9[0-39])|3(?:0[0-9]|1[0-9]|2[0139]|3[02]|40|50|" ."60|70|80|90)|4(?:0[0-369]|10|20|3[0-7]|40|51|60|7[67]|" ."80|90)|5(?:0[0134689]|10|20|30|4[0-4]|5[0-2]|60|70|80|" ."90)|6(?:0[0237-9]|1[0-27-9]|20|3[1-57-9]|4[036-9]|50|" ."60|7[1247]|80|90)|7(?:00|1[01]|2[1-39]|3[0-24]|" ."4[0-59]|5[01]|6[125]|7[12679]|90)|8(?:0[0-5]|10|20|" ."3[1-3]|40|50|60|7[0-2]|80|90)|9(?:0[2389]|1[12]|" ."2[1-4]|3[0-2]|40|50|60|81))|" ."1(?:0(?:0[0-9]|1[1-9]|2[1-4]|4[12]|51)|1(?:0[0-79]|10|20|" ."30|40|50|60|70|90)|2(?:0[0-689]|10|20|30|40|50|60|70|" ."90)|3(?:0[0-6]|10|20|30|40|50|60|70|80|90)|4(?:00|10|" ."20|3[08]|4[08]|5[08]|70|90)|5(?:00|50|60|70)|600|" ."7(?:00|90)|8(?:00|91)|9(?:61|84|9[24]))|" ."2(?:0(?:0[0-57-9]|1[0-9]|2[0-9]|3[0-46]|5[1-59]|6[0-79]|" ."7[0-29]|8[019]|9[0-2])|1(?:0[0-9]|1[0-46-9]|2[0-46-9]|" ."3[0-246-9]|4[0-579]|5[0-35-9]|6[0-24-69]|7[023569]|" ."8[02579]|9[0-469])|2(?:0[0-79]|1[0-357-9]|2[0-68]|" ."3[0-2]|4[025-9]|5[0-9]|60|70|80|90)|3(?:0[0-9]|1[01]|" ."2[0-257]|3[0-6]|40|50|6[01]|70|80|90)|4(?:0[0-8]|" ."1[0-289]|20|30|40|5[0-39]|60|70|80|90)|5(?:0[0-9]|10|" ."20|30|40|50|60|7[05]|80|90)|6(?:0[0-4689]|10|20|30|40|" ."50|60|70|80|90)|7(?:0[0-29]|10|20|30|40|50|60|70|80|" ."90)|8(?:0[0-69]|10|20|30|40|50|60|70|8[0-29]|90)|" ."9(?:0[1-9]|10|2[0-39]|30|40|5[0-5]|6[05-9]|7[0-8]|80|" ."90))|" ."3(?:0(?:0[0-9]|1[0-9]|2[0-489]|3[0-9]|4[02-69]|5[014-8]|" ."6[34])|1(?:00|1[0-9]|2[02]|30|40|50|60|7[0-578]|90)|" ."2(?:0[0-6]|10|20|30|40|50|60|70|90)|3(?:0[0-8]|10|20|" ."30|40|50|60|70|80|90)|4(?:0[0-9]|10|20|30|40|50|60|70|" ."80|90)|5(?:0[0-6]|10|20|30|40|50|60|70|80|90)|6(?:00|" ."10|20|30|40|50|60|70|80|90)|7(?:00|10|20|30|40|50|60|" ."70|80|90)|8(?:0[0-48]|10|20|30|40|50|70|80|90)|9(?:00|" ."10|20|30|40|5[09]|6[0-9]|7[02]|80|90))|" ."4(?:0(?:0[0-46-8]|1[0-35-9]|2[0-47-9]|3[0-9]|4[0-46]|" ."5[0-9]|6[0-24]|7[1589]|8[0-2679]|90)|1(?:0[0-9]|" ."1[0-356]|2[0-2]|30|4[0-35-8]|50|60|70|8[1-57]|90)|" ."2(?:0[0-68]|10|20|3[0-8]|40|50|60|70|90)|3(?:0[0-47]|" ."10|20|30|40|50|60|70|90)|4(?:0[0-4]|10|20|30|40|50|60|" ."70|80|90)|5(?:0[0-6]|1[01]|20|30|60|70)|6(?:0[0-5]|40|" ."60|80)|7(?:0[0-5]|80)|8(?:00|11|70)|990)|" ."5(?:0(?:0[0-9]|1[03-8]|2[0-5])|1(?:0[0-8]|1[0-267]|20|30|" ."40|50|7[01]|90)|2(?:0[0-4]|20|30|40|50|60|70|90)|" ."3(?:0[0-37-9]|1[0-2]|2[01]|30|50|60|70|80|90)|" ."4(?:0[0-2]|10|2[019]|30|40|60|90)|5(?:0[0-3]|10|60|" ."90)|6(?:0[01]|60|70|90)|7(?:0[016]|10)|80[01]|" ."9(?:0[1-57]|1[124578]|2[01]|30|5[01]))|" ."6(?:0(?:0[0-6]|1[1-57-9]|2[015-9]|3[0-49]|46|50|70)|" ."1(?:0[0-3]|1[0-3]|2[0-3]|30|4[0145]|50|6[0-25]|70|80|" ."90)|2(?:0[0-2]|10|20|30|40|50|60|70|80|90)|3(?:0[0-2]|" ."10|20|3[01459]|40|50|60|70|80|90)|4(?:0[0-3]|10|" ."2[0-3]|30|40|50|60|70|80|90)|5(?:0[0-29]|10|30|40|50|" ."60|70)|6(?:0[0-24-69]|10|20|5[0-29]|6[04]|70|80|90)|" ."7(?:0[0-4]|20|30|40|5[015]|60)|8(?:00|20|3[0-26]|45|" ."5[0346]|6[036]|70)|9(?:06|21|3[13]|4[015]|5[019]|" ."6[0-8]|87))|" ."7(?:0(?:0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[3-6]|59|6[01457-9]|" ."7[013-7]|8[0-9]|9[0-3689])|1(?:0[029]|1[02-8]|2[0-69]|" ."3[0-378]|4[0-6]|5[0-258]|6[0-35-79]|7[0-3]|90)|" ."2(?:0[0-79]|1[0-9]|20|3[0-2459]|4[0-39]|50|6[0-29]|70|" ."80|90)|3(?:0[0-8]|1[0-289]|20|30|40|50|60|70|8[0-2]|" ."90)|4(?:0[0-57-9]|1[0-2]|20|30|4[01]|5[0-9]|60|70|80|" ."90)|5(?:0[0-79]|10|2[01]|30|4[0-2]|50|60|70|80|90)|" ."6(?:0[0-9]|10|20|30|40|50|60|70|80|90)|7(?:0[0-9]|10|" ."2[0-8]|30|50|60|70|90)|8(?:0[0-479]|10|20|3[1-4689]|" ."4[0-3]|50|60|70|80|9[12])|9(?:0[05-79]|1[13]|" ."2[0-35-8]|3[0-3]|4[2-489]|5[2357-9]|6[0-79]|7[024-9]|" ."8[0-6]|9[09]))|" ."8(?:0(?:0[0-9]|1[02-9]|2[0-79]|40|5[0-9]|6[0-9]|7[0-467]|" ."8[2-6]|9[0-379])|1(?:00|1[068]|2[014-8]|3[0-49]|40|" ."5[0-39]|60|7[0-3]|80|90)|2(?:00|10|2[01]|30|40|50|" ."6[0-5]|7[0-4]|80|90)|3(?:0[0-9]|1[0-7]|20|3[0-3]|40|" ."50|60|70|80|9[0-39])|4(?:00|10|20|40|60|70|80|90)|" ."5(?:0[0-49]|10|20|30|40|50|60|70|80|90)|6(?:00|10|20|" ."30|40|50|60|80|90)|7(?:0[0-5]|20|30|40|50|60|70|80|" ."90)|8(?:0[0-2469]|20|30|40|50|70|90)|9(?:10|2[013579]|" ."4[13-57-9]|50|6[08]|70|80|90))|" ."9(?:0(?:0[1-9]|6[124])|1(?:00|1[05]|2[04-69]|3[0-2469]|" ."4[0-578]|5[0-49]|6[01]|7[0-3]|9[0-259])|2(?:0[0-9]|" ."1[0-9]|2[05-9]|3[0279]|4[0-7]|5[0-35-9]|6[0-9]|" ."7[0-2569]|8[0-9]|9[0-4])|3(?:0[0-379]|1[0679]|" ."2[0-26-9]|3[06-9]|4[0-9]|5[0-9]|6[0-79]|7[0-3679]|" ."8[0459]|9[0-9])|4(?:0[0-689]|1[0-9]|2[0-9]|3[0-9]|" ."4[0-9]|5[0-9]|6[013-9]|7[024-9]|8[0-9]|9[0-35])|" ."5(?:0[0-359]|1[0-9]|20|3[01]|4[0-4]|5[0-3]|6[013-59]|" ."7[0-4689]|8[0-3]|9[0-5])|6(?:0[0-9]|1[0-3569]|2[0-9]|" ."3[0-9]|4[0-9]|5[0-9]|6[014579]|7[0-79]|8[024-79]|" ."9[0-46])|7(?:0[0-29]|14|2[0679]|3[0-25]|4[0-79]|5[15]|" ."60|7[01]|80|9[0-5])|8(?:0[0-689]|1[1-4679]|2[02-49]|" ."3[0-36]|4[01]|50|60|70|8[1-39]|9[01])|9(?:0[0-8]|10|" ."2[1-6]|3[0-9]|4[25-9]|5[1-57]|6[0-489]|70|98)))" ."|7(?:0(?:0(?:0[0-7]|1[349]|2[0-2]|30)|1(?:0[0-4]|10|20|30|40|" ."50|60|70|80|90)|2(?:0[0-4]|10|20|30|40|50|70|80|90)|" ."3(?:0[0-46]|10|20|60)|4(?:00|40)|500|600|700|80[07])|" ."1(?:0(?:0[0-9]|1[0-27-9]|2[0-9]|31|4[09])|1(?:0[0-9]|" ."1[08]|20|30|40|50|60|70|90)|2(?:0[0-69]|10|20|30|40|" ."50|60|70|90)|3(?:0[0-9]|10|2[0-8]|3[0-79]|40|50|60|70|" ."80|90)|4(?:0[0-57-9]|10|20|30|40|50|60|70|80|90)|" ."5(?:0[0-39]|10|20|30|40|50|70|80|90)|6(?:0[0-49]|20|" ."40|70|80)|7(?:00|10|40|60)|8(?:00|50|70|80)|9(?:60|" ."90))|" ."2(?:0(?:0[0-9]|1[013-689]|2[14-9]|3[02-9]|4[0-57-9]|" ."5[12589]|7[0-359]|8[0-9]|9[1-356])|1(?:0[09]|10|20|30|" ."40|50|60|70|90)|2(?:0[0-3568]|10|20|3[0-4679]|40|50|" ."60|70|90)|3(?:0[0-589]|10|20|30|40|50|60|70|80|90)|" ."4(?:0[0-79]|30|40|50|60|70)|5(?:00|10|30|40|50|60)|" ."6(?:00|10|50)|70[02-5]|800|90[28])|" ."3(?:0(?:0[0-9]|1[014-9]|2[0-24-6]|31|65|7[39]|89|9[14])|" ."1(?:0[0-9]|10|2[0-479]|30|40|5[0-579]|60|70|9[0-39])|" ."2(?:0[0-9]|1[0-2469]|2[013-59]|3[0-259]|40|50|" ."6[01459]|7[067]|9[0-2459])|3(?:0[0-39]|10|2[0-29]|30|" ."40|50|60|7[0-9]|8[12]|90)|4(?:0[0-39]|10|20|40|50|60|" ."70|80|9[0-49])|5(?:00|20|30|40|50|7[0-39]|90)|" ."6(?:0[0-49]|10|20|30|40|60|70)|7(?:0[0-589]|10|20|30|" ."90)|8(?:0[0-24-9]|70))|" ."4(?:0(?:0[0-9]|1[0-6]|2[0145]|3[46]|4[01]|5[459])|" ."1(?:0[0-9]|1[0-3]|20|3[0-79]|40|5[0-9]|6[0-69]|70|90)|" ."2(?:0[0-9]|10|20|30|40|50|60|70|90)|3(?:0[0-57-9]|" ."1[014]|20|3[0-47-9]|40|50|60|7[0-4]|80|90)|" ."4(?:0[0-59]|10|20|30|40|50|60|70|80|90)|5(?:0[0-39]|" ."20|40|50|60|70|80)|6(?:0[0-79]|50|60)|7(?:0[0-469]|" ."40)|8(?:0[0-9]|90)|9(?:10|20|30|4[0-69]|5[0-4]|" ."6[0-469]|70|8[124-9]|9[013-9]))|" ."5(?:0(?:0[0-9]|1[0-9]|2[0134689]|3[0-689]|4[0-9]|5[1-689]|" ."6[0-9]|7[2-9]|8[0-9]|9[02-7])|1(?:0[0-9]|1[0-689]|" ."2[02-9]|3[01489]|4[0-24]|5[0-9]|6[1-9]|7[0-24679]|" ."8[0-24689]|9[124-8])|2(?:0[1-9]|1[0-9]|2[0-46-9]|" ."3[0-9]|4[01348]|5[0236]|6[0-69]|7[02589]|8[0-48]|" ."9[0-24589])|3(?:0[2-9]|1[0-57-9]|2[0-9]|3[0357-9]|" ."4[0-589]|5[0235-9]|6[0-7]|7[0-689]|8[0-9]|9[0-24-9])|" ."4(?:0[0-35-8]|1[0-35-9]|2[0-9]|3[0-24-9]|4[0-79]|" ."5[0-9]|6[02-8]|7[0-9]|8[0-8]|9[0-35-9])|5(?:0[2-9]|" ."1[0-2]|2[1-8]|3[3-8]|4[0-8]|5[0-8]|6[0-9]|7[0-9]|" ."8[0-9]|9[1-9])|6(?:0[0-9]|1[0-46-9]|2[0-9]|3[0-9]|" ."4[0-46-9]|5[0-9]|6[0-57-9]|7[013-57-9]|8[0-357-9]|" ."9[0-46-9])|7(?:0[0-35-9]|1[02-9]|2[0-79]|3[0-247-9]|" ."4[0-357-9]|5[03-79]|6[1-9]|7[0-358]|8[0-69]|9[04689])|" ."8(?:0[02-9]|1[2357-9]|2[0-9]|3[0-9]|4[013-9]|5[0-578]|" ."6[0-9]|7[0-24-9]|8[0-79]|9[0-57-9])|9(?:0[0-57-9]|" ."1[13-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]|6[0-25-79]|7[0-9]|" ."8[013-9]|9[013-8]))|" ."6(?:0(?:0[0-8]|1[127-9]|2[0-24-689]|3[0-35-9]|4[0-79]|" ."5[0-9]|6[0-9]|7[0-249]|8[03-7]|9[2-9])|1(?:0[017-9]|" ."1[013679]|2[0-579]|3[0-9]|4[0-4]|5[0-359]|6[014]|" ."7[0-9]|8[135-9]|9[0-7])|2(?:0[0-9]|10|20|3[0-35-9]|40|" ."50|60|70|80|90)|3(?:0[0-68]|10|20|30|40|50|60|7[09]|" ."80|90)|4(?:0[0-59]|1[089]|20|30|40|50|60|70|80|90)|" ."5(?:0[0-49]|10|20|30|40|50|60|70|80|90)|6(?:00|10|20|" ."30|40|50|60|80|90)|7(?:00|10|2[013]|30|40|50|60|70|80|" ."90)|8(?:0[0-9]|10|2[13-5]|40|50|60|70|8[0-57]|90)|" ."9(?:0[02]|1[0457]|2[05-79]|3[045]|4[05]|50|60|70|80))|" ."7(?:0(?:0[0-9]|1[0-9]|2[013-8]|39|4[0-3]|5[0-2]|90)|" ."1(?:0[0-9]|1[0-58]|2[02-467]|3[013-589]|4[01458]|" ."5[0147]|6[03-79]|7[01346-8]|8[13-7]|9[0-9])|" ."2(?:0[0-9]|1[0-9]|2[0-59]|3[0-249]|4[0-36-9]|5[0-579]|" ."6[0-46]|7[0-2]|8[0-2]|9[0-9])|3(?:0[0-57-9]|1[0-689]|" ."2[07]|3[0-57]|4[0-46-9]|5[0-3]|60|70|8[0-24589]|90)|" ."4(?:0[0-579]|1[0-79]|2[0-79]|3[0-79]|4[0-8]|5[0-58]|" ."6[02-57-9]|70|8[0-46-9])|5(?:0[0-9]|1[05]|2[0-9]|" ."4[0-9]|5[0-9]|6[0-9]|70|8[0-35]|90)|6(?:0[0-9]|" ."1[0-24-7]|20|30|4[01569]|50|60|70|80|90)|7(?:0[0-689]|" ."1[014-7]|2[0-3]|30|50|60|7[126-9]|80|9[1-689])|" ."8(?:1[013-9]|20|3[0-57-9]|40|50|60|7[0-3569]|80|90)|" ."9(?:10|2[03]|3[0-39]|40|5[01]|61|70|8[1-369]|90))|" ."8(?:0(?:0[0-9]|1[0-57-9]|2[0-246-9]|3[02-5]|4[1-9]|" ."5[1-79]|6[0-24-7]|7[189]|8[1-9]|9[1-69])|" ."1(?:0[0-24-689]|1[0-9]|2[0-24-69]|3[0-59]|4[0-35-9]|" ."5[0-57-9]|6[02-79]|7[0-479]|8[0-689]|9[0-9])|" ."2(?:0[0-9]|1[0249]|2[0-39]|3[0-49]|4[0-49]|50|60|70|" ."8[0-9]|9[0-49])|3(?:0[0-46-9]|1[0-79]|2[0-2]|3[019]|" ."4[0-24-69]|5[0-69]|6[0-48]|7[0-9]|80|9[015])|" ."4(?:0[0-49]|1[0-35-79]|2[0-49]|3[019]|40|5[0178]|60|" ."7[0-29]|80|90)|5(?:0[0-79]|1[0-59]|20|3[0-69]|40|50|" ."60|70|80|9[0-29])|6(?:0[0-69]|1[029]|20|30|40|50|60|" ."70|80|90)|7(?:0[0-359]|1[0-58]|20|30|40|50|60|7[0189]|" ."80|90)|8(?:0[0-69]|10|20|30|40|5[0-249]|60|70|8[1-6]|" ."9[07])|9(?:1[05]|2[0-9]|3[01]|4[0-689]|5[05]|60|70|80|" ."9[05-7]))|" ."9(?:0(?:0[0-9]|1[0-8]|2[1-9]|3[0-9]|4[1-69]|5[0-69]|" ."6[0189]|7[0-79]|8[0-8]|9[1-389])|1(?:0[0-69]|10|20|30|" ."4[0-5]|50|60|70|8[0-2459]|90)|2(?:0[0-689]|10|20|" ."3[0-4]|40|50|60|70|90)|3(?:0[0-9]|10|20|30|40|50|60|" ."70|80|90)|4(?:0[0-49]|10|20|30|40|50|60)|5(?:00|10)|" ."600|700|800|9(?:39|5[03])))" ."|8(?:0(?:0(?:0[0-9]|1[0-79]|2[0-35-9]|3[0-46-9]|4[0-46-9]|" ."5[014-7]|6[0-489]|75|8[0-9]|9[0-79])|1(?:0[0-9]|" ."1[058]|2[02]|3[0-24-6]|4[02-6]|50|60|70|90)|" ."2(?:0[0-689]|10|20|30|40|50|60|70|90)|3(?:0[0-39]|10|" ."20|3[0-69]|40|50|60|70|90)|4(?:00|10|20|30|40|50|60|" ."70|80|90)|5(?:00|10|20|3[1-59]|40|50|60|70|80)|6(?:00|" ."10|20|30|40|50|70|80|90)|7(?:00|10|40|50|70|80)|" ."8(?:00|20|30|50|60|70|80|9[01])|9(?:1[09]|60|70|80))|" ."1(?:0(?:0[0-7]|1[1-9]|2[0-35-8]|3[014-9]|90)|1(?:0[0-9]|" ."1[056]|20|30|40|50|60|70|90)|2(?:0[0-9]|1[05]|20|30|" ."40|50|60|70|90)|3(?:0[0-5]|10|20|30|40|50|60|70|80|" ."90)|4(?:00|30|40|50|70|90)|5(?:0[0-369]|30|40|70|80)|" ."6(?:0[0-59]|30|40|60)|7(?:00|10)|800|990)|" ."2(?:0(?:0[0-689]|1[3-579]|2[47]|3[0237]|4[078]|5[347]|" ."6[057]|7[07]|8[07])|1(?:0[0-49]|10|20|30|40|50|60|70|" ."90)|2(?:0[0-28]|10|20|30|40|50|70|90)|3(?:0[0-3]|30|" ."40|50|60|70|90)|4(?:0[0-3]|10|40)|500|600|7(?:00|10)|" ."800)|" ."3(?:0(?:0[0-8]|1[2-69]|3[068]|4[0-289]|5[0-9]|6[0-59]|" ."7[016-9]|8[0-9]|9[0-57-9])|1(?:0[078]|1[019]|20|" ."3[016]|4[039]|50|6[0-467]|7[0-79]|8[013-57-9]|" ."9[0-269])|2(?:00|10|20|3[016-8]|40|50|60|70)|3(?:00|" ."1[0-7]|20|30|40|50|7[0-29]|80|90)|4(?:0[0-9]|1[128]|" ."20|30|40|60|70|8[0-9]|90)|5(?:0[0-479]|1[0-248]|20|30|" ."50|60|70|80|90)|6(?:0[0-4689]|1[03-68]|30|40|60|70|80|" ."90)|7(?:0[0-57]|20|40|80|90)|8(?:00|20|30|40|60|70|" ."90)|9(?:10|20|5[1-47]|80|9[0-8]))|" ."4(?:0(?:0[04-9]|1[013-689]|2[1-579]|3[1-6]|4[1-9]|" ."5[014689]|7[1278]|8[1-5]|9[0-9])|1(?:0[0-9]|10|2[0-4]|" ."3[0-59]|4[0-479]|50|60|70|90)|2(?:0[0-9]|10|20|3[0-2]|" ."40|50|60|7[0-9]|90)|3(?:0[0-9]|10|20|30|40|50|60|70|" ."80|90)|4(?:0[0-5]|10|20|30|40|50|60|70|80|90)|" ."5(?:0[0-57]|10|30|50|60|70|80)|6(?:0[0-39]|60)|" ."7(?:0[0-6]|40|50|60)|8(?:0[0-58]|10|20|30|40|50|60|" ."7[0-48])|9(?:0[1259]|1[1-9]|5[1-46]|6[13-57-9]|" ."7[1-367]))|" ."5(?:0(?:0[0-9]|1[0235-9]|2[01346]|3[356])|1(?:0[0-9]|" ."1[013489]|20|3[0-39]|40|50|6[0-579]|70|80|90)|" ."2(?:0[0-689]|10|20|30|40|50|60|70|80|9[0-29])|" ."3(?:0[0-79]|10|20|30|4[0-2]|50|60|70|90)|" ."4(?:0[0-4679]|10|20|30|40|50|60|70|80|90)|5(?:0[0-69]|" ."10|20|30|40|50|60|70|80|90)|6(?:0[0-479]|1[02-6]|20|" ."30|40|60|70|80|90)|7(?:0[0237-9]|10|40|50|70)|" ."80[03-69]|9(?:19|2[1-8]|3[0-4]))|" ."6(?:0(?:0[0-9]|1[0-3]|2[0-39]|3[04-68]|4[2-7]|5[0-6]|" ."6[0-35-9]|7[1-46]|8[0-9]|9[0-8])|1(?:0[0-9]|1[07]|20|" ."3[0-57-9]|40|50|60|70|80|90)|2(?:0[0-2469]|10|20|30|" ."40|50|60|70|8[0-29]|90)|3(?:00|10|20|30|40|50|6[0-29]|" ."70|80|90)|4(?:00|10|20|30|40|50|60|70|80|90)|" ."5(?:0[0-289]|10|30|40|50|80)|6(?:00|10)|700|800|" ."9(?:05|10|6[0-49]|8[0-4]))|" ."7(?:0(?:0[0-9]|1[0-35-8]|2[0-356]|3[0-46-9]|4[0-9]|" ."5[0-589]|6[015-9]|7[013-9]|8[0-59]|90)|1(?:00|10|20|" ."30|40|50|60|70|90)|2(?:0[0-356]|10|2[0-3]|30|40|50|60|" ."70|80|90)|3(?:00|10|20|30|40|50|60|70|80)|4(?:00|10|" ."20|30|40|60|70|80)|5(?:00|10|20|70|90)|6(?:00|20|40)|" ."7(?:00|20)|8(?:00|90)|9(?:00|19|20|30|50))|" ."8(?:0(?:0[0-9]|1[0-8]|2[015-79]|33|5[01]|60|8[4-689]|99)|" ."1(?:0[0-9]|10|2[0-3579]|3[0-39]|4[0-39]|5[0-6]|" ."6[0-259]|70|87|9[0-589])|2(?:0[0-79]|1[0-4]|20|30|40|" ."50|60|70|90)|3(?:0[0-7]|10|20|30|40|50|60|70|80|90)|" ."4(?:0[0-35-9]|10|20|30|40|50|60|70|80|90)|" ."5(?:0[0-479]|10|20|30|40|50|60|80)|6(?:00|30|40|50)|" ."700|80[0-59])|" ."9(?:0(?:0[0-79]|1[0-2569]|2[0-9]|30|89|9[0-59])|" ."1(?:0[0-9]|1[036]|20|30|4[04]|50|60|70|90)|" ."2(?:0[0-79]|10|20|30|40|50|60|70|90)|3(?:0[0-79]|10|" ."20|3[01]|40|50|60|80|90)|4(?:00|10|20|30|40|50|60|70|" ."80)|5(?:00|1[05]|2[05]|30|50|60|70|80)|6(?:00|30|60|" ."90)|7(?:00|10|40|7[0-2])|800))" ."|9(?:0(?:0(?:0[0-9]|1[0-689]|2[0-35]|40)|1(?:0[01]|10|20|30|40|" ."50|60|70)|200|3(?:00|30|40|50|60|70|80)|400|500|600|" ."700|8(?:00|50))|" ."1(?:0(?:0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]|" ."7[0-247-9]|80|9[07])|1(?:0[0-9]|2[0-9]|3[0-35-7]|" ."4[0-269]|5[0-46-9]|6[0-9]|7[0-47-9]|80|9[0-9])|" ."2(?:0[014579]|1[0134]|2[0-9]|30|4[01]|50|6[0-35-9]|70|" ."80|9[0-24-9])|3(?:0[0-9]|1[0-245]|2[0-589]|3[0-59]|" ."4[0-9]|5[013-59]|60|7[014]|8[0-9]|90)|4(?:0[0-79]|" ."1[024-8]|2[0-9]|30|40|50|6[0-3]|70|80|90)|5(?:10|20|" ."30|4[0-29]|5[01]|60|7[0-489]|80|90)|6(?:0[0-359]|" ."1[0239]|2[05]|30|40|50|60|70|80|9[0-9])|7(?:0[0-9]|" ."1[0-3]|20|30|4[0-9]|50|6[0-47]|70|8[013]|9[0-2])|" ."8(?:0[0-79]|1[0-5]|2[01]|30|4[019]|5[0-25]|6[01]|" ."7[0-9]|8[0-79]|9[0-689])|9(?:1[0-79]|2[1-4]|30|4[0-9]|" ."5[1-9]|6[1-9]|7[1-9]|8[1-68]))|" ."2(?:0(?:0[0-9]|1[0-9]|2[0-9]|3[3-9]|4[0-9]|5[0-9]|" ."6[013-9]|7[0-9]|8[1-9]|9[235-9])|1(?:0[0-689]|1[0-9]|" ."2[0-9]|3[0-9]|4[0-9]|5[0-9]|6[0-9]|7[0-9]|8[1-689]|" ."9[013-69])|2(?:0[0-689]|1[0-69]|2[0-9]|3[0-57-9]|" ."4[0-79]|5[0-46-9]|6[0-369]|7[0-59]|8[0-246-8]|" ."9[0-35-8])|3(?:0[0-9]|1[0-46-9]|2[0-9]|3[0-379]|" ."4[0-2]|5[0-79]|6[0-69]|7[029]|8[08]|9[0-9])|" ."4(?:0[0-9]|1[0-9]|2[03]|3[08]|4[1-578]|54|99)|" ."5(?:0[0-9]|1[1346-9]|2[1-57-9]|3[1-8]|4[1-6]|5[235]|" ."6[1-79]|7[13-8]|8[1-8]|9[1-9])|6(?:0[0-79]|1[13-6]|" ."2[24]|3[1-8]|4[1-359]|5[013-689]|6[05]|7[12579]|" ."8[2-689]|9[1358])|7(?:0[0-9]|1[1-5]|2[125-9]|3[05-9]|" ."4[1-578]|5[12568]|6[1-46-8]|7[2-469]|8[1-9]|9[1-9])|" ."8(?:0[0-9]|1[135-9]|2[0-4]|4[2-8]|5[1-69]|6[1-7]|" ."8[1-79]|9[1-8])|9(?:0[1-46-9]|1[1-9]|2[0-9]|3[0-9]|59|" ."7[0-57-9]|8[013-9]|99))|" ."3(?:0(?:0[0-35-9]|1[1-46-8]|2[124])|1(?:0[0-8]|1[0-24-8]|" ."2[0-367]|3[013-6]|4[0-9]|5[0-8]|6[0-9]|7[0-24-7]|" ."8[1-46-9]|9[0-79])|2(?:0[0-9]|1[0-46-9]|2[0-2]|" ."3[0135]|4[015]|50|6[01]|7[0145]|8[2-6]|9[047])|" ."3(?:0[0-8]|1[015]|2[0-5]|3[0-24-7]|4[0-689]|5[0-2]|" ."6[0-6]|70|8[0-2]|90)|4(?:0[0-8]|1[0-2]|2[0-4]|3[0167]|" ."4[01]|5[013-8]|6[0-5]|7[0239]|8[1-79]|93)|5(?:0[0-8]|" ."1[1-7]|2[1-46-8]|3[1-9]|4[1457]|5[4-68]|6[1-4]|" ."7[14-8]|8[1-9]|9[13])|6(?:0[0-689]|1[1-9]|2[1-37]|31|" ."9[1-9])|7(?:0[015]|1[129]|3[1346-8]|61)|8(?:0[0-267]|" ."1[2-6]|8[13-57]|9[19])|90[17-9])|" ."4(?:0(?:0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[1-5]|94)|" ."1(?:0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]|6[0-69]|" ."7[0-5]|9[0-79])|2(?:0[0-9]|1[0149]|2[0-9]|3[0-9]|" ."4[0-4679]|5[0-9]|6[0-9]|7[0-9]|81|90)|3(?:0[0-9]|" ."1[0-29]|2[0-247]|4[0-59]|5[013-79]|6[0-689]|7[0-9]|" ."8[0-9]|9[0-689])|4(?:0[0-9]|1[0-579]|20|3[0-9]|40|" ."5[0-79]|60|7[0-9]|80|90)|5(?:0[0-9]|1[0-9]|2[0-8]|" ."3[1-9]|4[1-46-9]|5[0-3]|6[1-9]|7[1-9]|8[1-9]|9[1-9])|" ."6(?:0[0-4679]|1[1-46-9]|2[1-36-8]|3[1-9]|4[1-578]|" ."5[1346-9]|6[13479]|7[1-9]|8[1-8])|7(?:0[0-4679]|" ."1[0-59]|2[1-9]|3[1-9]|4[1-589]|6[1-8]|8[1-59])|" ."8(?:0[0-9]|1[1-9]|3[1-39]|5[1-9]|6[1-79]|80|9[1-4])|" ."9(?:4[125-9]|5[1-689]|6[1-68]|7[1-8]))|" ."5(?:0(?:0[0-8]|1[0-9]|2[0-57-9]|3[0-8]|4[0-26]|5[0-69]|" ."6[0-79]|7[0-9]|9[0-8])|1(?:0[0-9]|1[0-27-9]|2[0-79]|" ."3[0-579]|4[0-6]|5[0-57-9]|6[0-259]|70|80|9[0-9])|" ."2(?:0[0-79]|1[0-9]|2[0-4689]|3[0-49]|40|5[0-29]|60|70|" ."80|90)|3(?:0[0-469]|1[0-689]|2[0-489]|3[0-5]|40|" ."5[015]|60|7[09]|80|90)|4(?:00|1[0-29]|20|30|4[015]|50|" ."6[01]|7[0-9]|80|90)|5(?:0[0-9]|10|2[0-9]|30|40|5[019]|" ."60|7[013]|80|90)|6(?:0[0-59]|1[0-9]|20|30|40|5[0-29]|" ."60|70|80|9[0-367])|7(?:0[0-9]|1[0-3569]|2[0-7]|3[1-4]|" ."4[0-27]|50|6[019]|70|80)|8(?:0[0-9]|1[0-6]|20|30|" ."4[02-4]|50|6[1-68]|7[0-79]|80|9[127])|9(?:0[12578]|" ."1[1-3569]|2[0-8]|3[0-4]|4[0-9]|5[0-46-9]|7[0-8]))|" ."8799)" .")",Germany=>"(?k:0(?:1(?:0(?:6[79]|9[79])|1(?:0[89]|2[79]|39|5[679]|69|8[79])|" ."2(?:1[79]|3[79]|5[79]|7[79])|3(?:0[79]|14|2[468])|" ."4(?:45|5[48]|6[258]|7[178])|5(?:58|61|8[79]|9[14])|" ."6(?:09|1[269]|23|40|6[25]|8[39])|7(?:05|2[38]|3[1478]|" ."44|6[28]|7[3468]|96)|8(?:09|1[469]|2[459]|33|4[478]|" ."55|77|96)|9(?:0[0469]|17|20|36|45|68|79|8[37]|" ."9[03468]))|" ."2(?:6(?:2[57]|33|4[03]|8[19]|9[249])|7(?:08|27|3[0369]|" ."4[278]|63|79|8[258]|9[14679])|8(?:2[6-9]|9[49])|" ."9(?:06|2[39]|43|5[3679]|7[79]|9[1479]))|" ."3(?:0(?:4[2468]|5[0-58]|9[69])|1(?:03|1[69]|3[09]|49|59|" ."72|85|97)|2(?:0[25]|2[269]|38|4[69]|53))|" ."4(?:1(?:0[3579]|29|5[57-9]|7[7-9])|2(?:0[579]|29|49|" ."7[579]|8[89]|99)|3(?:1[5-9]|2[89]|4[79]|5[67])|4(?:16|" ."2[05]|35|42|51|6[03])|5(?:09|19|23|39|52|6[457]|" ."7[1459])|6(?:0[03]|1[0378]|26|39|43|5[1457]|68|" ."8[03578])|7(?:03|20|36|4[169]|58|69|7[49])|8(?:08|" ."2[1478]|38|49|6[02]|74|8[069]|95)|9(?:1[06]|2[48]|" ."3[12468]))|" ."6(?:1(?:08|1[02468]|2[02468]|3[02]|79|8[48]|9[38])|2(?:17|" ."3[17]|4[269]|5[4589]|68|79|95)|3(?:08|1[1378]|33|" ."4[378]|6[69]|8[568])|4(?:0[68]|2[059]|49|5[68]|" ."6[34679]|84|93)|5(?:0[27]|2[68]|3[67]|4[2378]|56|67|" ."7[178])|6(?:18|28|3[268]|4[278]|67|79|8[268])|7(?:12|" ."2[124579]|31|49|66|7[349]|8[056]|9[1246])|" ."8(?:0[03489]|4[24679]|6[129]|8[689]|9[56])|9(?:0[159]|" ."1[78]|2[2568]))|" ."7(?:3(?:18|3[03468]|4[39]|56|6[68]|8[179])|4(?:07|" ."2[2679])|5(?:4[5689]|5[1247]|70|8[069])|6(?:07|1[369]|" ."29|39|46)|7(?:4[3579]|51|68|7[48])|8(?:06|19)|9(?:07|" ."19|2[24679]|37|5[02578]|73|8[0579]))|" ."8(?:0(?:5[68]|6[0246])|1(?:07|1[258]|3[24]|4[147])|2(?:09|" ."2[38]|3[3679]|48|58|6[12579]|8[09]|9[47])|3(?:0[149]|" ."1[258]|2[14-68]|4[049]|5[259]|7[13]|9[36])|4(?:12|" ."2[78]|3[29]|5[19]|68|85|9[169])|5(?:2[3579]|3[89]|" ."4[1378])|6(?:06|26|4[58]))|" ."9(?:0(?:28|30)|1(?:1[1-4679]|2[0235-8]|3[01])|2(?:1[27]|" ."2[1478]|3[256]|4[1349])|3(?:06|2[268]|37|5[0356]|66|" ."76|8[057]|9[02459])|4(?:05|19|2[379]|3[02579]|56|" ."6[58]|7[147]|8[1478]|96)|5(?:09|1[478]|26|4[48]|57|69|" ."7[3579]|99)|6(?:0[03]|1[89]|2[379]|3[348]|48|6[19])))" ."|1(?:0(?:1(?:1[579]|7[89])|24[3579]|3(?:1[57-9]|6[579])|" ."4(?:0[579]|3[579])|5(?:5[13579]|8[579])|62[3579]|" ."7(?:0[79]|1[13579]|7[79]|8[13579])|82[3579]|" ."9(?:6[13579]|9[79]))|" ."1011|2(?:0(?:4[3579]|5[13579]|99)|1(?:0[13579]|5[79]|" ."6[13579])|2(?:0[3579]|4[79]|7[79])|3(?:0[579]|4[79]|" ."5[13579])|4(?:3[579]|59|8[79])|5(?:2[4679]|5[579]|" ."8[79])|6(?:19|2[1379]|79|8[13579]))|" ."3(?:0(?:47|5[13579]|8[689])|1(?:2[579]|5[689]|8[79])|" ."3(?:4[79]|5[13579])|4(?:0[3579]|3[579]|6[579])|" ."5(?:0[3579]|8[13579]|9[13579])|62[79])|" ."4(?:0(?:5[023579]|89)|1(?:09|29|31|6[3579]|9[3579])|" ."4(?:6[179]|7[1368]|8[02])|5(?:13|32|4[278]|5[02478])|" ."6(?:12|2[147]|41|56|6[29])|7(?:1[25]|2[78]|7[02468]|" ."89|9[378])|8(?:06|2[2378])|9(?:13|29|4[37]|59|7[49]))|" ."5(?:2(?:3[0246]|9[59])|3(?:06|2[0468]|4[45]|66|7[02478])|" ."5(?:1[78]|2[68]|37|6[269])|7(?:11|3[28]|4[15689]|" ."5[124578])|8(?:06|27|3[1478]|48|59|6[48]|9[08])|" ."9(?:07|1[03]|26|3[68]))|" ."6(?:2(?:2[57]|30|4[478]|59|69|78)|3(?:0[367]|21|4[18]|" ."5[269])|5(?:15|4[078]|5[269]|6[257])|7(?:27|6[167]|75|" ."9[28])|8(?:1[68]|27|3[1357]|45|6[68])|9(?:09|18|2[18]|" ."4[59]))|" ."7(?:0(?:3[3469]|8[79]|9[1489])|1(?:09|11|2[169]|39|5[349]|" ."6[68]|79|9[24])|2(?:0[79]|1[3479]|3[57]|48|5[2589]|68|" ."79|91)|3(?:09|2[12689]|3[57]|4[89]|58|67|7[359]|89|" ."9[0-28])|4(?:06|19|2[49]|38|4[09]|5[49]|89|9[1358])|" ."50[69])|" ."8(?:0(?:5[579]|69)|1(?:0[679]|19|4[67]|8[124]|9[0568])|" ."2(?:09|11|25|3[01369]|4[69]|58|7[369]|9[29])|" ."3(?:1[147]|20|3[47]|47|56|7[45])|4(?:3[579]|4[25]|" ."6[159])|5(?:07|1[0369]|28|46|5[16]|6[59]|7[34]|8[16])|" ."609)|" ."9(?:0(?:5[3579]|6[13579]|7[13579]|8[69])|2(?:0[59]|17|30|" ."4[369]|58|60|73|88|94)|3(?:0[0369]|22|3[69]|48|57|" ."7[0246]|86|9[59])|4(?:06|1[27])))" ."|2(?:0(?:0(?:38|88|9[579])|14[4689]|2(?:49|5[13579])|35[04579]|" ."45[79]|53[579])|" ."1(?:0(?:29|3[13579]|7[3579])|1(?:0[79]|29|4[79])|" ."2(?:1[78]|2[0478]|44|5[5689]|6[16]|7[1249])|" ."3(?:3[579]|5[478]|6[0589]|7[169]|8[02568]|9[14578])|" ."4(?:0[013679]|23|3[5689]|4[124579]|65|8[13]|93)|" ."5(?:0[29]|1[46]|2[124679])|6(?:14|29|35|4[0134679]|" ."8[02-4]|98)|7(?:0[269]|1[0247]|2[03679]|3[02479]|45|" ."5[56]|6[2359]|7[0256]|8[124579]))|" ."2(?:0(?:4[13579]|8[13579])|1(?:1[13579]|4[3579]|59|" ."7[579])|29[79]|3(?:0[13579]|3[579]|59|9[13579])|" ."4(?:1[579]|5[3579])|5(?:2[3579]|4[79]|59|8[79])|" ."60[579]|76[13579]|8(?:4[468]|5[01]|69|8[059])|" ."9(?:2[679]|4[169]|5[25689]|6[24579]))|" ."3(?:5(?:39|5[2468]|6[024689]|70)|6(?:1[179]|2[36-9]|69|" ."8[349])|7(?:01|1[4579]|3[08]|4[34679]|58|69|7[4579]|" ."95)|8(?:1[23568]|2[0134679]|4[357]|58|6[03679]|79|" ."8[13]|9[689])|9(?:09|1[19]|23|36|4[2468]|52|6[68]|" ."7[024]|9[269]))|" ."4(?:1(?:0[35-79]|1[134689]|4[35-9]|59|61)|2(?:1[147]|" ."2[02369]|3[2589]|4[124578]|5[0134679])|3(?:06|2[1679]|" ."40|5[1478]|6[0134679]|76|9[2589])|40[124579]|" ."5(?:3[4679]|58|68|76|8[29]|9[48])|6(?:01|1[0369]|" ."2[0235689]|3[124578]|4[0134679])|7(?:68|8[2-47]|" ."9[0134679])|8(?:0[0235689]|1[134679]|37|48|5[0257]|" ."6[0134679]|7[0235689]|8[124578]|9[0134679])|9(?:3[79]|" ."4[134]|55|6[0369]|7[25-7]|8[03689]|9[124679]))|" ."5(?:3(?:3[5-7]|48|5[58]|6[1458]|7[013679])|4(?:04|2[19]|" ."3[67]|51|6[29]|7[49]|8[25689]|9[124579])|5(?:24|4[18]|" ."5[147]|6[0369]|7[235689]|8[124578]|9[0134679])|693|" ."7(?:0[49]|1[2589]|2[14579]|46|6[147]|7[0469]|8[2568]|" ."9[124579])|8(?:13|2[16]|3[26]|4[0259]|5[0235689]|" ."6[02-4689]|7[0235689]|8[124579]|99)|9(?:17|2[03467]|" ."38|46|80|9[2679]))|" ."6(?:1(?:2[1-3579]|3[135]|6[09]|8[08]|97)|2(?:0[39]|1[59])|" ."3(?:16|4[059]|8[24689])|4(?:09|19|27|34|4[16]|52|65|" ."74|8[679])|5(?:06|2[49]|32|48|5[36]|7[19])|6(?:0[357]|" ."2[49]|3[29]|55|7[06]|8[39])|7(?:2[135]|36|5[79]|89)|" ."8(?:02|1[07]|26|3[15]|4[24579]|71|9[279])|" ."9(?:0[134679]|19|3[15-79]|54|69))|" ."7(?:2(?:11|3[29]|4[35689]|5[12479]|83|99)|3(?:0[58]|1[38]|" ."2[147]|3[03679]|56|67|74|8[369])|4(?:04|1[29]|32|" ."4[269]|7[2468]|9[89])|5(?:68|7[02468]|80)|6(?:07|" ."1[269]|2[48]|3[278])|7(?:11|2[169]|49|5[135]|77|" ."9[38])|80[149])|" ."8(?:19[579]|2(?:0[13579]|1[13579]|3[79]|59|7[79])|" ."3(?:0[79]|2[579]|35|5[579])|7(?:1[79]|5[579]|7[79]|" ."90)|8(?:16|32|44|57|65|7[069]))|" ."9(?:22[13579]|3(?:0[38]|13|2[038]|3[169]|4[258]|" ."5[1-35689]|6[124579]|7[89]|8[69]|9[2-469])|4(?:1[036]|" ."39|5[169]|6[258]|7[1-35689]|8[124578]|9[0134679])|" ."5(?:25|49|5[369]|6[258]|7[14-689]|8[124578]|" ."9[0134679])|6(?:14|33|4[0369]|64|83|9[039])))" ."|3(?:0(?:1(?:59|6[13579]|7[13579])|4(?:19|49|5[13579])|5(?:19|" ."21|39|59)|6(?:2[579]|5[579]|69)|8(?:2[367]|5[135]|80|" ."90)|9(?:00|16|26|38|52|66|74|8[29]))|" ."1(?:0(?:08|2[089]|3[23569]|61|7[39]|8[457-9]|9[134679])|" ."1(?:3[4579]|41|57|6[27]|7[147]|8[058]|9[1569])|" ."2(?:2[468]|34|4[169]|75)|3(?:03|1[19])|5(?:15|35|" ."4[27]|5[235689]|82|9[25])|6(?:0[034689]|1[389]|" ."2[1-36-9]|3[2-46-8]|55|75|8[38]|9[1389])|7(?:0[0278]|" ."1[0-2457-9]|37|49|8[579])|8(?:12|32|4[08]|55|6[0378]))|" ."2(?:0(?:49|5[12])|1(?:0[578]|20|3[09])|2(?:57|78|89)|" ."3(?:12|39|51|6[19])|4(?:2[3579]|57|69|79)|5(?:4[579]|" ."84)|6(?:0[29]|57|76|8[39]|9[49])|7(?:5[68]|60|91)|" ."8(?:05|16|25|3[29]))|" ."3(?:0(?:14|3[49]|98)|1(?:0[0246]|29|42|54|6[15]|7[58]|" ."8[149])|3(?:11|3[0245]|78|97)|4(?:15|28|4[29])|519|" ."6(?:0[24579]|1[13579]|4[79]|59|89|99)|7(?:19|29|39|58|" ."75|90)|8(?:03|1[38]|2[49]))|" ."4(?:1(?:1[79]|2[13578]|3[0-24])|2(?:12|25|33|46|53|6[06]|" ."7[07]|8[169]|9[258])|3(?:0[258]|1[147]|2[03679]|46|" ."5[59]|69|7[69]|8[58]|9[369])|4(?:14|3[149]|54|66|" ."7[1479]|97)|5(?:08|1[369]|37|49|60|76|8[27]|9[0369])|" ."6(?:13|2[168]|3[02379]))|" ."5(?:0(?:3[79]|4[13]|66|75|8[0358]|9[1469])|1(?:0[248]|" ."1[024679])|2(?:16|3[269]|60|7[49]|8[2578])|3(?:05|15|" ."2[1579]|9[02468])|4(?:1[058]|2[38]|35|4[047]|5[27]|" ."6[0369])|5(?:1[069]|7[689]|8[0-6])|6(?:06|1[49]|25|" ."3[038]|4[1479]|8[3-9]|90)|7(?:08|1[369]|45|5[369]|" ."6[478]|8[19]|9[2469]))|" ."6(?:0(?:3[79]|4[13]|88|93)|1(?:0[03]|1[059]|2[49]|3[27]|" ."4[258]|5[147]|6[03679]|79|99)|2(?:0[58]|1[1479]|51|" ."6[69]|7[257]|8[024679])|3(?:04|18|2[03569]|41|5[58]|" ."6[479]|81|9[169])|4(?:04|1[49]|33|48|5[267]|6[069]))|" ."7(?:0(?:7[3579]|8[135])|1(?:15|2[047]|3[0369]|54|7[06]|" ."8[16]|9[1479])|2(?:1[3-8]|35|4[279]|69|76|8[147]|" ."9[03679])|3(?:08|18|27|39|45|5[159])|4(?:12|3[14]|" ."4[14579])|5(?:20|3[49]|47|74|8[169])|6(?:03|19|2[07]|" ."3[2359]|4[02379]|71|88|9[1679]))|" ."8(?:023|1(?:0[02468]|1[02468]|2[0246]|5[49]|6[25]|" ."7[0369])|2(?:2[689]|39|59|68|7[124579]|81)|3(?:0[024]|" ."1[259]|2[124579]|50|6[48]|7[235689]|8[124578])|" ."4(?:4[02468]|5[89]|6[124578]|7[0134679]|8[69])|5(?:18|" ."2[478]|3[01369]|4[237]|5[0134679])|6(?:4[024]|67|78|" ."85|90)|7(?:0[0479]|2[39])|8(?:2[0289]|3[568]|55|" ."7[1579]|89|9[59]))|" ."9(?:014|1(?:0[468]|1[02468]|2[02468]|30|6[47]|7[159])|" ."2(?:18|21|4[059]|6[14]|79|88|91)|3(?:07|1[79]|26|" ."4[035]|5[69]|65|87|9[378])|4(?:18|3[459]|4[3468])|" ."5(?:17|24|39|7[69]|9[069])|6(?:06|1[59]|2[49]|38|" ."4[69])))" ."|4(?:0(?:2(?:1[0-3579]|2[13579]|3[13579])|4(?:68|7[024679]|89)|" ."5(?:4[579]|89|9[13579])|6(?:2[579]|6[78]|70|99)|" ."7(?:2[134]|64|89)|8(?:22|32|78|8[0235]))|" ."1(?:06[135689]|1(?:69|79|89|99)|23[689]|3(?:34|52|6[36]|" ."7[29])|4(?:6[024689]|7[02])|5(?:1[5-7]|39|4[0-2]|" ."6[49])|7(?:4[7-9]|51)|8(?:12|36|4[49]))|" ."2(?:1(?:0[3579]|1[13579])|2(?:7[579]|8[13579])|3(?:2[79]|" ."49|69|89|99)|4(?:77|89|99)|5(?:49|5[135]|79)|" ."6(?:5[13579]|9[79])|7(?:19|81|99)|8(?:5[3579]|9[79])|" ."929)|" ."4(?:1(?:3[579]|4[13579])|2(?:2[579]|6[3579]|8[79])|3(?:09|" ."19|2[89]|39|5[79]|69|79|88)|5(?:3[246]|7[579]|81)|" ."6(?:2[357-9]|49|5[1-3])|7(?:8[79]|9[13579])|" ."8(?:0[13579]|6[679]|79|9[24]))|" ."5(?:1(?:2[78]|3[0134689]|4[13-579])|2(?:19|39|5[79]|" ."7[679]|89)|3(?:0[79]|2[679]|5[5-79])|4(?:03|68|" ."7[0235689]|81)|5(?:2[579]|49)|6(?:5[79]|6[135]|99)|" ."7(?:01|11|21|3[19]|68|7[02])|8(?:79|8[134689]|" ."9[124679])|96[468])|" ."6(?:04[579]|1(?:1[79]|4[579])|2(?:3[68]|4[024]|8[246])|" ."3(?:25|4[28]|5[49]|9[579])|4(?:1[49]|46|59|8[357]|99)|" ."5(?:09|1[49]|3[579]|6[29]))|" ."7(?:05[1357-9]|1(?:19|3[7-9]|6[679]|7[89]|9[89])|" ."2(?:2[689]|39|49|59|69|79)|4(?:4[1357]|75|95)|" ."5(?:0[69]|33|46|5[19]|74|89)|6(?:08|2[3-7]|38|47|52|" ."6[159])|79[89]|8(?:0[02-579]|29|39|77)|9(?:06|18|29))|" ."8(?:079|1(?:4[3579]|5[13579]|6[1357])|2(?:31|49|68|82|91)|" ."3(?:0[18]|17|2[49]|36|4[16]|5[16]|6[169])|4(?:29|" ."3[12]|55|65|77|8[058]|9[369])|5(?:2[79]|31|65|99)|" ."6(?:07|1[29]|2[49]|53|83|91)|7(?:03|12|2[07]|3[49]))|" ."9(?:0(?:7[468]|8[02468]|90)|1(?:24|34|43|52|63|7[069]|86|" ."9[16])|2(?:0[15]|1[49])|3(?:2[468]|56|77|93)|" ."4(?:0[16]|1[39]|2[49]|3[49]|48|5[13679]|7[79]|9[27])|" ."5(?:0[49]|25|36|4[59]|65|77|8[46]|9[34679])|6(?:10|" ."2[46]|3[2578]|61|8[158]|9[269])|7(?:16|33|4[04]|5[17]|" ."6[27]|7[0479])|8(?:0[89]|11|2[48]|3[258]|4[34679])))" ."|5(?:0(?:1(?:2[679]|69|7[01]|8[19])|2(?:26|59)|3(?:21|54|74|" ."89)|6(?:6[78]|7[0246-9])|7(?:3[3579]|6[579])|" ."8(?:2[3579]|5[89])|9(?:3[13579]|6[89]|9[679]))|" ."1(?:06[13579]|1(?:0[3579]|4[3579])|3(?:7[13579]|81|99)|" ."4(?:2[79]|6[579]|91)|5(?:03|1[59]|45|70|8[08]|9[78])|" ."6(?:4[357]|74|88)|7(?:0[29]|66|89))|" ."2(?:0(?:6[2468]|7[02468]|80)|1(?:34|46|5[269])|2(?:2[2-4]|" ."49)|3(?:49|5[135]|7[29]|8[258]|9[1369])|4(?:28|4[15]|" ."5[79]|77|99)|5(?:11|25|3[18]))|" ."3(?:1(?:1[13579]|2[13579]|7[3579])|22[579]|3(?:32|4[037]|" ."59)|4(?:2[46]|74|89|98)|5(?:0[15-8]|18|20|3[349]|" ."4[57]|57|6[027]|7[27-9])|6(?:04|19|39)|7(?:21|57|73|" ."83|97)|8(?:0[49]|19|4[024]|59|79|81|94)|9(?:0[29]|" ."1[39]|25|37|4[0579]))|" ."4(?:29[02-68]|3(?:0[689]|1[01346-8]|2[09]|3[128]|" ."4[0134679])|4(?:1[13]|2[124679]|39|41|5[0135-79]|" ."7[02]|8[3467]|9[278])|5(?:1[68]|2[34689]|3[134689]|" ."5[028]|68|7[04689]|8[4-79]|9[57])|6(?:08|1[0-24679]|" ."3[46]|4[679]|5[57]|6[24689]|7[35]|8[79]))|" ."5(?:1(?:1[68]|2[0246-9]|3[01])|2(?:18|3[2479]|46|5[27]|" ."6[238]|7[0168]|8[368]|9[1469])|4(?:1[13]|2[245]|" ."3[0257]|4[24]|5[0279]|69|71|8[137]|9[014679])|" ."5(?:4[356]|59|6[689]|7[168]|8[35]|9[0235-79])|" ."6(?:0[68]|1[89]|2[14679])|7(?:43|5[68]|6[578]|" ."7[4679]))|" ."6(?:0(?:68|7[0235-7])|1(?:12|3[023]|54|7[09]|82|91)|" ."2(?:0[346]|18|20|3[57]|4[249]|5[34]|69|7[16]|8[138]|" ."9[01459])|3(?:0[57]|1[67]|2[1-39]|3[023578]|4[01689]|" ."5[57]|68|7[079])|4(?:1[024]|2[2478]|5[79]|62|7[0279])|" ."5(?:6[467]|7[59]|8[147-9]|9[3489])|6(?:26|3[07]|" ."4[258]|5[1369])|7(?:2[79]|36|4[356]|5[1349]|6[1679])|" ."8(?:1[248]|2[0135689]|4[13]|5[0689]|6[124579]))|" ."7(?:0(?:7[2468]|80)|2(?:23|34|5[08]|71|9[09])|3(?:19|" ."3[49]|68|9[29])|4(?:13|39|62|8[29])|5(?:18|20|3[79]|" ."48|55|6[27]|7[278]|8[0134679])|6(?:1[024]|2[79]|" ."3[25689]|4[124578]))|" ."8(?:0(?:89|9[13579])|1(?:19|35)|2(?:39|56|85)|3(?:00|13|" ."3[29])|45[2-6]|5(?:0[79]|1[135]|40|53|66|79)|" ."6(?:3[68]|4[024]|75)|7(?:0[68]|10|3[09]|6[29]|91)|" ."8(?:0[29]|4[09]))|" ."9(?:0(?:6[3579]|7[1357])|1(?:74|9[29])|2(?:2[79]|69)|" ."3(?:02|2[09]|48|68|79|87|9[49])|4(?:2[357]|39|57|69|" ."94)|5(?:05|1[049]|5[5-8]|81|9[07])|60[29]|75[579]|" ."8(?:2[13]|46|72|89)|9(?:09|29|39|55|6[49])))" ."|6(?:0(?:3(?:08|1[13468]|2[0235-79]|8[5689])|4(?:3[1357-9]|" ."8[6-9])|5(?:2[89]|49|9[4689]))|" ."1(?:1(?:18|3[078]|69|84|9[147])|2(?:0[0369]|3[19]|50|67|" ."7[369])|3(?:48|5[02]|8[19])|4(?:4[09]|62|7[69]))|" ."3(?:0(?:6[579]|7[135])|1(?:10|28|50|65|79)|2(?:25|63)|" ."3(?:03|2[29])|4(?:05|5[02467]|77|86)|5(?:0[05]|1[27]|" ."26|3[38]|4[369]|7[19]|8[49]|9[49])|6(?:07|19|28|" ."3[3679]|54|67|7[49]|8[38]|9[14579])|7(?:39|4[13]|55|" ."6[28]|7[36]|85|9[16])|8(?:0[18]|1[14]|2[05689]|3[149]|" ."4[0369]|5[367]|6[0347-9]|7[124579]|97)|9(?:06|1[16]|" ."2[04578]|3[0134679]))|" ."4(?:2(?:8[3579]|9[1357])|3(?:19|31|4[27]|54|67|72|8[05]|" ."9[057])|40[14579]|5(?:21|46|6[09]|7[29]|8[49])|6(?:25|" ."46|5[38]|6[58]|7[38]|8[369])|7(?:11|20|3[29]|4[37]|" ."5[034679])|8(?:07|23|3[29]|46|5[039]))|" ."5(?:1(?:8[3579]|9[13579])|2(?:0[1357]|19|2[0-4]|3[29])|" ."3(?:07|2[169]|4[3-7]|66|75|8[58]|9[169])|4(?:28|39|51|" ."6[28]|7[49])|5(?:10|2[079]|49|5[0-68]|8[29]|9[479])|" ."6(?:0[46]|1[148]|2[034679])|7(?:19|60|79|95)|" ."8(?:1[27]|24|3[05]|43)|9(?:29|3[1346]))|" ."6(?:1(?:1[13579]|2[135-9]|3[0-3])|2(?:65|71|8[07]|9[29])|" ."3(?:33|46|5[29]|86|99)|4(?:24|40|5[039]|8[24]|97)|" ."5(?:0[0134679]|3[89]|40|57|64|7[18]|8[39])|6(?:06|" ."2[059]|36|4[069]|63|79|87|93)|7(?:0[169]|40|63|73|" ."8[07]|9[38])|8(?:0[269]|22|39|49|51|6[29]|7[179]|" ."8[257]|9[24])|9(?:0[13479]|1[4679]|5[3-57]|69|7[68]|" ."8[179]|9[469]))|" ."7(?:0(?:59|6[13579]|71|98)|1(?:05|1[27]|2[25-7]|3[346]|" ."4[1679]|5[027-9]|6[15-79])|2(?:2[79]|4[056]|5[1689]|" ."69|7[138]|8[013]|9[2457])|3(?:0[4578]|1[01679]|46|54|" ."6[013568]|7[346-8])|4(?:3[3-5]|5[49]|6[68]|7[1-35]|" ."8[02379])|5(?:4[79]|5[01]|7[4578]|8[0235-7]|" ."9[0-35689])|6(?:5[3579]|6[13]|7[78]|8[01568]|9[1379])|" ."7(?:0[015-7]|1[4-68]|2[2457-9]|3[12457]|4[24-689]|" ."5[2-4679])|8(?:0[68]|1[134679]|2[1-4679]))|" ."8(?:1(?:59|6[13579]|99)|2(?:19|29|39|59)|30[579]|5(?:19|" ."26|35|4[29])|6(?:23|4[279])|7(?:23|53|66|75|8[29]|" ."9[49])|80[49])|" ."9(?:1(?:1[578]|2[01346]|51|68|81|9[08])|2(?:07|14|2[16]|" ."3[149]|4[25]|5[0134679])|4(?:12|2[79]|3[4679]|69|" ."8[38]|93)|5(?:0[29]|1[478])))" ."|7(?:0(?:1(?:7[3468]|8[02468]|9[0-3579])|3(?:2[79]|7[2468])|" ."4(?:3[579]|69|99)|5(?:6[3579]|9[79])|6(?:19|29)|" ."7(?:3[46]|71|94)|8(?:06|25|39))|" ."1(?:0(?:3[24]|6[3579]|8[38]|93)|1(?:0[16]|1[16]|2[06]|" ."3[149]|4[49]|5[4579])|2(?:29|54|63|7[27]|8[27]|" ."9[2679])|3(?:3[246]|64|84|9[47])|40[49]|5(?:22|" ."4[0369]|54|6[036]|7[03679])|6(?:3[468]|4[02]|65|7[29]|" ."86|9[16])|7(?:0[16]|1[178]|2[0369]|3[2579]))|" ."2(?:07[0246]|1(?:08|1[69]|2[47]|3[158]|4[14579]|60|7[258]|" ."8[1469])|2(?:02|1[38]|2[14679]|50|7[05]|8[05]|" ."9[0134679])|3(?:36|48|5[15689]|6[124579]|79|93)|" ."4(?:0[16]|1[14579]|5[89]|6[19]|7[4579]|88)|5(?:0[15]|" ."1[0134679]|25|3[124579]|55|74|8[124579])|6(?:22|" ."3[169]|4[49]|5[4578]|6[0134679])|7(?:6[02468]|70|93)|" ."8(?:0[05]|1[038]|2[079]))|" ."3(?:0(?:3[357]|54|6[16]|7[29]|8[47]|9[2589])|" ."1(?:0[124578]|1[0134679])|2(?:07|3[05]|4[09]|5[27]|" ."6[25689]|7[124578])|3(?:12|2[69]|3[37]|4[024579])|" ."4(?:3[0-4]|4[17]|5[037]|6[03679]|79|8[5689]|" ."9[124579])|5(?:2[579]|4[07]|5[037]|6[035689]|" ."7[124579])|6(?:14|3[05]|42|5[05]|6[03679])|7(?:28|" ."3[02-4]|6[05]|7[0369]))|" ."4(?:0(?:7[2468]|8[01])|1(?:7[27]|8[29]|9[369])|2(?:06|" ."1[149]|2[369]|3[2589]|4[35689]|5[124579])|3(?:21|" ."3[67]|4[38]|5[47]|6[0369]|7[2469]|8[2589]|9[124579])|" ."4(?:05|17|2[034679])|5(?:23|3[258]|4[124579]|64|" ."7[259]|8[2569]|9[24579])|6(?:13|2[69]|3[2589]|53|" ."7[03679])|7(?:06|22|3[16]|4[034679])|8(?:21|3[1248]|" ."4[27]|5[058]|6[124579]|89)|9(?:0[69]|1[258]|2[14578]|" ."3[0134679]))|" ."5(?:0(?:15|3[18]|45|5[03679])|1(?:7[23579]|8[01]|96)|" ."2(?:03|1[07]|2[38]|3[369]|4[2589])|3(?:05|2[38]|" ."3[14579]|65|78|8[2579]|9[124579])|4(?:17|28|3[38]|" ."4[3679]))|" ."6(?:006|1(?:3[13579]|49|8[579]|99)|2(?:2[7-9]|75|87|97)|" ."3(?:07|16|27|3[27]|44|5[169])|4(?:37|48|56|6[17]|" ."7[034679])|5(?:3[024]|4[79]|71|9[3679])|6(?:46|6[19]|" ."76|8[49]|9[48])|7(?:0[3679]|26|44|5[16]|6[1478]|" ."7[0134679])|8(?:29|3[135]|4[68]|5[57]|6[35]|7[0279]|" ."8[79]|91))|" ."7(?:6(?:5[246]|94)|7(?:0[49]|16|2[38]|3[16]|4[0369]|56|" ."6[17]|7[036]|8[147]|9[0134679])|8(?:15|3[0369]|55|66|" ."7[16]|8[03679])|9(?:33|4[48]|55|6[036]|7[124578]))|" ."8(?:0(?:48|5[0246]|7[38]|8[3679]|98)|1(?:12|2[06]|3[26]|" ."4[1478]|66|76|8[37]|9[49])|2(?:24|3[49]|4[47]|5[0369]|" ."6[2679])|3(?:15|3[37]|4[35]|5[14579])|4(?:6[2457]|" ."7[69])|5(?:32|49|5[49]|6[47]|7[0369]|8[0235689]|" ."9[124578])|6(?:0[0134679]|28|47|5[258]|6[124579])|" ."7(?:13|27|3[03679]))|" ."9(?:098|1(?:0[02468]|1[0-2457]|8[39]|9[49])|2(?:06|1[159]|" ."2[47]|3[258]|4[149]|5[2468]|6[138]|7[1469]|8[0235689]|" ."9[124579])|3(?:12|3[16]|4[168]|5[0369]|6[124579]|79|" ."95)|4(?:00|1[058]|2[34679])|5(?:13|39|4[01]|7[68]|" ."8[589]|9[124579])|6(?:18|39|50|6[49]|7[47]|8[235689]|" ."9[124579])|7(?:13|25|3[03679]|61|7[147]|8[07]|9[038])|" ."8(?:0[124579]|22|37|4[38]|5[369]|6[258]|7[124579])))" ."|8(?:0(?:33[135-79]|469|53[89]|6(?:3[46-9]|8[679])|79[6-9]|" ."80[1-579]|9(?:3[3579]|9[23579]))|" ."1(?:24[13579]|3(?:69|7[13579])|47[5-79]|5(?:39|4[13579])|" ."6(?:6[79]|7[13579])|73[579]|82[579]|92[579])|" ."2(?:0(?:08|24|3[12]|4[19]|5[47]|6[14579])|1(?:10|31|40|52|" ."66|78|94)|2(?:05|1[16]|2[39]|3[479]|56|6[69]|7[25689]|" ."8[124578]|9[0134679])|3(?:19|27|35|4[03679]|62|77|" ."8[03679]|9[0235689])|4(?:0[124579]|18|3[1-35689]|" ."4[124579]|67|8[178]|9[0134679])|5(?:15|38|4[1479]))|" ."3(?:0(?:2[246]|43|5[29]|64|7[15]|8[038]|9[38])|1(?:0[149]|" ."1[259]|2[235689]|3[124579])|2(?:09|2[49]|3[36]|4[26]|" ."5[034679]|78)|3(?:0[18]|1[37]|2[49]|3[49]|4[2469]|" ."5[2589]|6[124578]|7[0134679]|95)|4(?:04|1[0367]|35|" ."5[1478]|71|8[3679])|5(?:12|27|3[0369]|4[34679]|" ."5[0235689]|6[124579])|6(?:07|2[034679]|46|6[16]|" ."7[0134679]|84)|7(?:0[0378]|14|27|3[04579]))|" ."4(?:0(?:28|3[0246]|48|5[16]|6[169]|7[269]|8[2589]|" ."9[124578])|1(?:0[0134679]|3[07]|4[049]|5[25]|" ."6[034689]|7[124578]|8[0134679])|3(?:07|2[369]|" ."3[23579]|47|59|6[47]|7[158]|8[14579])|4(?:05|1[69]|" ."2[478]|3[124579]|53|78|89|94)|5(?:0[38]|1[38]|2[49]|" ."3[39]|4[34679]|5[0235689]|6[124578]|7[0134679]))|" ."5(?:0(?:49|5[1357]|7[27]|8[048]|9[258])|1(?:0[147]|" ."1[0134679]|2[0235689]|3[124579])|2(?:2[19]|3[258]|" ."4[147]|5[034689]|76|83|9[0368])|3(?:0[124579]|5[46]|" ."68|7[56]|86|9[159])|4(?:0[2568]|1[0134679]|35|4[57]|" ."5[2679]|6[124579])|5(?:21|40|51|6[07]|7[09]|86|" ."9[189])|6(?:0[49]|1[47]|2[25]|3[05]|4[0369]|5[235689]|" ."6[124579])|7(?:16|37|48|57|64|7[478]))|" ."6(?:1(?:5[02-4679]|6[13579]|79|99)|3(?:16|43|56|68|81|" ."9[19])|4(?:05|15|2[04]|38|4[147]|5[0369]|6[25]|" ."7[03679]|8[0235689]|9[124578])|5(?:0[024578]|" ."1[013479]|29|5[14689]|6[124578]|7[0134679])|6(?:09|" ."3[37]|4[137]|5[0357]|6[03689]|7[2-689]|8[124578]|" ."9[024578])|7(?:0[0134679]|20|3[235689]|4[124578]|" ."5[0134679])|8(?:07|25|3[036]|4[25]|5[034679]|" ."6[0235689]|7[124579]|99)|9(?:1[169]|2[0235689]|" ."3[124578]|4[0134679]|56|7[124578]|8[0134679]))|" ."7(?:4(?:3[579]|48|5[29]|6[36]|7[147]|8[0478]|9[034679])|" ."5(?:09|27|3[48]|4[14579]|61)|6(?:00|16|29|3[47]|" ."4[02578]|5[0134679]|6[0235689]|7[124579])|7(?:00|19|" ."2[47]|3[034679]|4[0235689]|5[124578]|6[0134679]|" ."7[0235689]|8[124579]))|" ."8(?:0(?:4[568]|69|7[49]|8[56]|9[0479])|1(?:3[18]|4[2579]|" ."6[17]|7[1589])|2(?:1[2-4]|39|5[05]|6[037]|7[1369]|" ."8[14579]|99)|3(?:1[679]|26|39|48|5[36]|6[1478]|" ."7[0134679])|4(?:00|1[06]|2[27]|3[0367]|4[1478]|" ."5[0134679]|7[17]|8[0134679]|99)|5(?:1[258]|2[14579])|" ."6(?:05|3[0134679]|62|77|82|9[03679])|7(?:09|1[89]))|" ."9(?:0(?:40|7[3579]|81)|1(?:29|34|43|5[05]|6[058]|" ."7[134679]|8[0235689]|9[124578])|2(?:3[13]|5[07]|6[49]|" ."7[58]|8[147]|9[0134679])|3(?:12|3[15]|4[034679]|" ."5[0235689]|6[124578])|4(?:07|15|2[03689]|3[124578]|" ."4[0134679])|5(?:18|2[02]|37|4[27]|5[158]|6[1478]|84|" ."97)|6(?:0[14578]|1[0134679])))" ."|9(?:0(?:4(?:0[2389]|1[19]|2[579]|3[19]|4[139]|5[13579]|6[19]|" ."7[1358]|8[029]|91)|5(?:1[38]|22|3[07]|4[27]|5[269]|62|" ."7[149]|8[47]|9[269])|6(?:0[27]|1[034679])|76[23568])|" ."1(?:0(?:5[2468]|7[47]|8[03568]|9[0134679])|1(?:26|54|" ."6[16]|7[147]|8[03679])|2(?:07|17|2[047]|3[035689]|" ."4[124579]|57|7[58]|8[124679])|3(?:01|15|2[0257]|" ."3[02468]|4[14679]|5[0235689]|6[124579])|4(?:13|38|" ."4[38]|5[269]|6[0235689]|7[124578]|8[0134679])|5(?:22|" ."41|5[05]|6[047]|7[258]|8[03679]|9[0235689])|" ."6(?:0[124578]|1[0134679]|2[0235689]|3[124579])|" ."7(?:1[079]|2[0235689]|3[124578]|4[0134679]|57|8[158]|" ."9[0235689])|80[124579])|" ."2(?:2(?:24|37|4[259]|5[369]|6[0235689]|7[124578]|" ."8[0134679])|3(?:18|3[149]|4[258]|5[358]|6[0134679])|" ."4(?:21|3[169]|4[24579])|5(?:07|2[16]|3[369]|" ."4[0235689]|5[124579])|6(?:37|48|55|6[05]|7[06]|8[15]|" ."9[034679])|7(?:0[0235689]|1[124578]|2[0134679]))|" ."3(?:0(?:4[79]|5[13579]|7[37]|8[03679]|9[0235689])|" ."1(?:0[124579]|28|3[38]|4[29]|5[258]|6[147]|7[03679]|" ."8[0235689]|9[124579])|3(?:09|26|3[369]|4[235689]|" ."5[124689])|4(?:13|26|37|4[49]|5[358]|6[2468]|" ."7[0134679]|8[0235689]|9[124579]))|" ."4(?:0(?:3[246]|51|6[05]|7[28]|8[169]|9[49])|1(?:0[47]|" ."1[0368]|2[147]|3[03679]|4[0235689]|5[124578]|" ."6[0134679])|2(?:09|27|3[49]|4[49]|5[0235689]|" ."6[124579])|3(?:15|27|3[0369]|4[24578]|5[0134679]|" ."6[0235689]|7[124579])|4(?:05|19|2[48]|3[1679]|47|69|" ."74|8[16]|9[16])|5(?:0[158]|1[38]|2[2679]|3[0235689]|" ."4[124578]|5[0134679]|6[0235689]|7[124579]))|" ."5(?:0(?:28|3[02])|1(?:00|1[19]|26|3[18]|45|5[28]|6[38]|" ."7[369]|8[0235689]|9[124579])|2(?:13|3[34679])|3(?:26|" ."3[69]|4[69]|5[25689]|6[124579])|4(?:4[4578]|6[0369]|" ."7[38]|8[258]|9[0134679])|5(?:0[0235689]|1[124579])|" ."6(?:15|32|43|5[29]|66|7[169]|8[0235689]|9[124578])|" ."70[0134679])|" ."6(?:0(?:4[79]|5[02])|1(?:0[36]|1[047]|2[0369]|3[258]|" ."4[25689]|5[124578]|6[0134679]|7[0235689]|8[124578]|" ."9[0134679])|2(?:15|24|3[17]|4[27]|5[037]|6[0489]|" ."7[124579])|3(?:17|28|3[27]|4[269]|5[258]|6[14579])|" ."4(?:50|65|7[269]|8[24679])|5(?:15|2[348]))|" ."7(?:0(?:7[02468]|8[024])|199|2(?:0[49]|1[58]|2[258]|" ."3[024679]|4[134679]|5[0235689]|6[124578]|7[0134679]|" ."8[0235689]|9[124579])|3(?:18|20|3[247]|4[0268]|" ."5[03579])|4(?:12|2[124]|37|4[07]|5[036]|6[149]|7[58]|" ."8[368]|9[0134679])|5(?:0[0235689]|1[134679]|" ."2[0235689]|3[124579])|6(?:1[68]|3[138]|4[057]|" ."5[034679]|88)|7(?:0[258]|1[147]|2[03-579]|37|53|6[29]|" ."7[235689]|8[0235689]|9[124579])|8(?:16|28|3[34679]|" ."4[0235689]|5[124579]|77|9[26])|9(?:0[0134679]|22|" ."4[147]|5[03679]|80|9[0369]))|" ."8(?:5(?:2[7-9]|30|4[47]|5[349]|74|87|9[03679])|6(?:17|" ."3[149]|46|6[03679]|7[38]|93)|7(?:0[148]|1[146]|24|39|" ."4[3469]))|" ."9(?:0(?:8[4-79]|9[1246-9])|1(?:0[02]|30|89|9[258])|3(?:10|" ."26|3[048])|4(?:2[3578]|3[89]|4[148])|51[08]|6(?:10|" ."2[58]|3[1468])|7(?:06|1[38]|3[45]|5[259]|6[258])|" ."8(?:1[79]|26|3[0147]|4[268]|6[79]|8[057]|9[1478])|" ."9(?:47|5[58]|7[46]|8[68]|9[1468])))" .")",Greenland=>"(?k:2412" ."|39(?:0[05]|1[0-359]|2[0-4]|3[02]|40|5[0-35]|6[124]|" ."7[0-2]|8[0245]|92)" .")",Italy=>"(?k:0(?:0(?:0(?:1[0-357-9]|2[0-9]|3[0-9]|4[0-9]|5[0-57-9]|" ."6[0-35-9])|1(?:19|2[0-8]|3[1-9]|4[1-9]|5[1-9]|6[1-9]|" ."7[1-9]|8[1-9]|9[1-9]))|" ."1(?:0(?:1[0-24-9]|2[0-8]|3[02-9])|100)|" ."2(?:0(?:1[0-689]|2[0-68]|3[0-57-9]|4[0-9])|100)|" ."3(?:0(?:1[0-46-9]|2[0-9]|3[0-9]|4[0-9])|100)|" ."4(?:0(?:1[0-9]|2[0-9])|100)|" ."5(?:0(?:1[0-8]|2[0-689]|3[0-2459])|100)|" ."6(?:0(?:1[024689]|2[0-9]|3[013-689]|4[0-79]|5[013-79]|" ."6[0-689]|7[023]|8[1349])|1(?:00|2[1-9]|3[124]))|" ."7(?:0(?:1[0-9]|2[0-9]|3[0-9]|4[013-9])|100)|" ."8(?:0(?:1[0-35-9]|2[0-9]|3[0-9]|4[02-9])|100)|" ."9(?:0(?:1[0-9]|2[0-9]|3[0-9]|4[0-57-9]|7[0-9]|8[0-68]|" ."9[0-9])|1(?:00|2[1-9]|3[14]|70)))" ."|1(?:0(?:0(?:1[0-9]|2[02-689]|3[0-24-8]|4[0-68]|5[0-9]|6[0-9]|" ."7[0-8]|8[0-8]|9[0-589])|1(?:00|2[1-9]|3[1-9]|4[1-9]|" ."5[1-6]))|" ."1(?:0(?:1[0-8]|2[0-9])|100)|" ."2(?:0(?:1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-68]|6[0-689]|" ."7[0-9]|8[0-47-9])|100)|" ."3(?:0(?:1[0-27-9]|2[0-8]|3[0-9]|4[013-9]|60)|100|" ."8(?:1[124-8]|2[1-5]|3[13-6]|4[13-578]|5[1-6]|6[1-8]|" ."7[1-8]|8[1-8]|9[13-9])|900)|" ."4(?:0(?:1[0-9]|2[0-6]|3[0-79]|4[0-9]|5[0-57-9])|100)|" ."5(?:0(?:1[0-9]|2[0-9]|3[0-689]|4[0-689]|5[0-9]|6[0-9]|" ."7[0-9])|100)|" ."6(?:0(?:1[0-9]|2[0-9]|3[0-689]|4[0-9])|1(?:00|2[1-9]|" ."3[1-9]|4[1-9]|5[1-9]|6[1-7]))|" ."7(?:0(?:1[0-579]|2[0-8]|3[0-57-9]|4[0-8]|5[1-8])|100)|" ."8(?:0(?:1[0-9]|2[0-7]|3[0-9])|100)|" ."9(?:0(?:1[0-8]|2[0158]|3[0-478])|1(?:00|2[1-6]|3[1-9])))" ."|2(?:0(?:0(?:1[0-9]|2[0-9]|3[027]|40|56|6[0-9]|7[078]|8[0-9]|" ."9[0-9])|1(?:2[1-9]|3[1-9]|4[1-9]|5[1-9]|6[12])|" ."8(?:1[1-6]|2[1-6]|3[1-8]|4[1-7]|5[1-7]|6[1-7]|7[1-7]|" ."8[1-6])|900)|" ."1(?:0(?:1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9])|100)|" ."2(?:0(?:1[0-9]|2[0-9]|3[0-9]|4[04-6]|6[0369]|7[0-9])|100)|" ."3(?:0(?:1[0-9]|2[0-79]|3[0-8])|100|8(?:0[124-8]|1[13-9]|" ."2[1-9]|3[1-8]|4[1-9]|5[12457]|6[124578]|7[013-9]|" ."8[013-9]|9[0-9])|900)|" ."4(?:0(?:1[0-9]|2[0-9]|3[013-9]|4[0-9]|5[0-9]|6[0-9])|" ."1(?:00|2[1-9]))|" ."5(?:0(?:1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]|6[0-589]|" ."7[0-9]|8[0-9])|1(?:00|2[1-9]|3[1-6]))|" ."6(?:0(?:1[0-9]|2[0-9]|3[0-9]|4[0-9])|100|8(?:1[1-8]|" ."2[1-8]|3[1-9]|4[1-9]|5[1-9]|6[1-7])|900)|" ."7(?:0(?:1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-57-9])|100)|" ."8(?:0(?:1[0-79]|2[148]|4[0135-7]|5[03]|6[0-24-689]|" ."7[0-9])|100|8(?:0[1-5]|1[1-9]|2[1-8]|3[1-368]|4[1-5]|" ."5[1-9]|6[1-68]|7[135-79]|8[13-7]|9[13-9])|922)|" ."9(?:0(?:1[0-9]|2[0-9])|100))" ."|3(?:0(?:0(?:1[03-6]|2[0-9]|3[0-9])|1(?:00|2[1-6]|3[1-35]|" ."4[12]|7[0-5]))|" ."1(?:0(?:1[0-8]|2[0-9]|3[0-9]|4[0-9]|5[0-9])|100)|" ."2(?:0(?:1[02-6]|2[0-26-8]|3[0-7]|4[0-7])|100)|" ."3(?:0(?:1[0135-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]|7[024-9]|" ."8[0-7]|9[02457-9])|1(?:00|70))|" ."4(?:0(?:1[0-24-8]|7[0-9])|1(?:00|2[1-9]|3[1-9]|4[1-9]|51|" ."70))|" ."5(?:0(?:1[0-9]|2[0-9]|3[0-24-8]|4[0-8])|1(?:00|2[1-9]|" ."3[1-9]|4[1-3]))|" ."6(?:0(?:1[0-6]|2[0-8]|3[0-6]|4[0235-7]|5[0-7]|6[0-6]|" ."7[0-35-8])|100)|" ."7(?:0(?:1[0-9]|2[0-4689]|3[0-25689]|4[0-79]|5[0-9]|" ."6[02-46-9])|1(?:00|2[1-9]|3[1-9]|42))|" ."8(?:0(?:1[0-35-9]|2[0-9]|3[0-9]|4[0-35-9]|5[0-79]|6[0-9]|" ."7[0-9]|8[0-35-9])|100)|" ."9(?:0(?:1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-8])|100))" ."|4(?:0(?:0(?:1[0-9]|2[0-7]|3[02-8]|4[1-3568]|5[0-79]|6[0-9])|" ."1(?:00|2[1-9]|3[1-9]|41))|" ."1(?:0(?:1[0-9]|2[0-35-9]|3[0-9]|4[02-689]|5[1-9])|100)|" ."2(?:0(?:1[0-9]|2[0-8]|3[0-579]|4[0-9])|100)|" ."3(?:0(?:1[0-57-9]|2[0-24589]|3[025-9]|4[0-57-9]|" ."5[0-35689])|1(?:00|26))|" ."4(?:0(?:1[0-24-69]|2[0-35-9]|3[03-579]|4[1-357-9])|100)|" ."5(?:0(?:1[0-2457-9]|2[0-7]|3[0-9])|100)|" ."6(?:0(?:1[0-47-9]|2[02-9]|3[0-35-79]|4[0-9])|100)|" ."7(?:0(?:1[0-9]|2[013578]|3[02459]|4[23])|1(?:00|2[12])|" ."8(?:14|2[24-6]|3[2-8]|4[1-3]|5[3-5]|6[1-7])|900)|" ."8(?:0(?:1[0-578]|2[024-7])|100))" ."|5(?:0(?:0(?:1[02-489]|2[0-35-8]|3[1-9]|41|5[0-689]|6[0-8])|" ."1(?:00|2[1-79]|3[1-79]|4[1-5]))|" ."1(?:0(?:1[0-35-9]|2[0148]|3[014-79])|100)|" ."2(?:0(?:1[014-8]|2[0-24-9]|3[0-35-8]|4[13-8])|100)|" ."3(?:0(?:1[1-9]|2[0-7]|3[014-7]|4[0-357-9])|100)|" ."4(?:0(?:1[0-6]|2[136-9]|3[358])|100)|" ."5(?:0(?:1[0-689]|2[02357]|3[0-68]|4[0-2579]|5[14]|" ."6[0-24])|100)|" ."6(?:0(?:1[0-279]|2[0-589]|3[0-8]|4[013-68])|1(?:00|" ."2[1-8]))|" ."7(?:0(?:1[467]|2[0-3578]|3[0-46-9])|1(?:00|2[1-8]))|" ."8(?:0(?:1[0-2457-9]|2[02-7]|3[1346-8]|4[02-5]|5[13-5])|" ."100)|" ."9(?:0(?:1[1356]|2[14-6])|100))" ."|6(?:0(?:0(?:1[013589]|2[0-24-7]|3[013-9]|4[01348])|1(?:00|" ."2[1-9]|31))|" ."1(?:0(?:1[0-4]|2[0-689]|3[02-47-9]|4[0-9])|100)|" ."2(?:0(?:1[0-2457-9]|2[0-24-9]|3[24-689])|100)|" ."3(?:0(?:20|31|6[1-9]|7[1-9]|8[1-8]|9[1-6])|100|8(?:1[1-6]|" ."2[1-8]|3[1-9]|4[1-8]|5[1-8])|900)|" ."4(?:0(?:1[0-68]|2[013-8]|3[0-79]|4[0-79])|100)|" ."5(?:0(?:1[0-579]|2[02-9])|1(?:00|2[1-9]|3[12]))|" ."6(?:0(?:1[0-24-9]|2[0-36]|3[0-46-8]|4[0-7]|5[0-24])|100)|" ."7(?:0(?:1[02-579]|2[0-9]|3[0-9]|4[013-9]|5[0-9]|" ."6[0-46-9])|100))" ."|7(?:0(?:0(?:1[013-9]|2[0-9]|3[2378]|4[2-4]|5[46])|1(?:00|" ."2[1-9]|31))|" ."1(?:0(?:1[0-9]|2[0-9]|3[0-9]|4[0-3578])|100)|" ."2(?:0(?:1[02-9]|2[0-9])|100)|" ."3(?:0(?:1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9])|100)|" ."4(?:0(?:1[0-9]|2[0-8])|100)|" ."5(?:0(?:1[0-9]|2[0-9])|100)|" ."6(?:01[1-7]|12[135]))" ."|8(?:0(?:0(?:1[0-46-9]|2[0-9]|3[0-689]|4[0-24-9]|5[013-9]|" ."6[0-35-79]|7[013-9])|1(?:00|2[1-9]|3[1-9]|4[1-7]))|" ."1(?:0(?:1[0-467]|2[0-578]|3[0-9]|4[0-4679]|5[0-9])|100)|" ."2(?:0(?:1[0135-9]|2[0-9]|3[0-46-8])|100)|" ."3(?:0(?:1[0-8]|2[0-9]|3[0-24-9]|4[0-9]|5[0-9])|100)|" ."4(?:0(?:1[0-9]|2[0-9]|3[0-9]|4[02-9]|5[0-35-79]|6[0-25-9]|" ."7[03-9]|8[0-8]|9[0-25689])|1(?:00|2[1-9]|3[1-5]))|" ."5(?:0(?:1[0-8]|2[0-9]|3[0-9]|4[02-46-9]|5[0-9])|100)|" ."6(?:0(?:1[0-9]|2[0-9]|3[0-9]|4[0-9]|7[0-57-9]|8[0-9]|" ."9[0-7])|1(?:00|70))|" ."7(?:0(?:1[0-9]|2[0-46-9]|3[0-8]|4[0-8]|5[0-8]|6[0-24679]|" ."7[0-6])|100)|" ."8(?:0(?:2[0-245]|4[0-24-79]|5[014-6]|6[02457-9]|70)|100|" ."8(?:1[1-9]|2[1-5]|3[1-8]|4[12])|900)|" ."9(?:0(?:1[0-8]|2[0-9]|3[0-9]|4[0-9]|5[0246-8]|6[02-59])|" ."1(?:00|2[1-9]|3[1-5])|8(?:1[2-9]|2[1-4]|3[1-4]|4[1-4]|" ."5[1-3]|6[1-46-8])|900))" ."|9(?:0(?:0(?:1[0-9]|2[0-9]|3[0-9]|4[0-9])|1(?:00|2[1-9]|3[1-9]|" ."4[1-9]|51))|" ."1(?:0(?:1[0-9]|2[0-9])|100)|" ."2(?:0(?:1[0-9]|2[0-9])|100)|" ."3(?:01[0-9]|100)|" ."4(?:01[0-9]|100)|" ."5(?:0(?:1[0-9]|2[0-2457-9]|3[0-9]|4[0-9])|1(?:00|2[1-9]|" ."31))|" ."6(?:01[0-9]|100)|" ."7(?:01[0-9]|100)|" ."8(?:0(?:2[0-35-9]|3[0-9]|4[0-9]|5[013-9]|6[0-9]|7[0-9])|" ."1(?:00|2[1-9]|3[1-9]|4[1-9]|5[1-9]|6[1-8])))" .")",Liechtenstein=>"(?k:94(?:8[5-9]|9[0-8]))",Luxembourg=>"(?k:0(?:1(?:01|2[13-5]|3[12]|4[1-3]|61|7[13]|8[1-3]|9[12])|" ."2(?:02|11|31|41|51|6[23]|91)|" ."3(?:2[1-5]|32|42|6[12]|72|8[1-3]|91)|" ."4(?:0[1-3]|1[12]|2[12]|4[1-356]|5[13]|6[2-4]|7[12]|8[12]|" ."9[1-7])|" ."5(?:21|3[12]|5[1-4]|6[12]|8[1-4])|" ."6(?:1[12]|4[1-4]|6[1-4]|7[12]|9[12])|" ."7(?:2[1-3]|5[1-4]|6[13]|7[12])|" ."8(?:0[1-9]|1[1-4]|2[1-3]|3[1-4]|41|5[2-5]|61|81)|" ."9(?:0[134]|1[1-4]|2[12]|4[2-4]|5[1-4]|6[1-3]|7[1-3]|" ."8[1-3]|9[1-5]))" ."|1(?:0(?:09|1[0-9]|2[0-9]|30|50|60|90)|" ."1(?:1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-39]|6[01])|" ."2(?:0[89]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]|6[0-9]|" ."7[0-9]|8[0-3])|" ."3(?:09|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]|6[0-9]|7[0-6])|" ."4(?:09|1[1-9]|2[0-9]|3[0-4]|4[589]|5[0-9]|6[0-9]|7[0-9]|" ."8[0-4]|9[09])|" ."5(?:0[89]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-2])|" ."6(?:1[013-9]|2[0-9]|3[0-9]|4[0-9]|5[0-6]|6[01]|70)|" ."7(?:09|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-3])|" ."8(?:1[1-8]|2[0-2]|3[1-9]|4[0-356]|5[0-9]|6[0-8]|7[0-3]|" ."8[0-2]|9[6-9])|" ."9(?:1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-4]))" ."|2(?:0(?:1[0-9]|20|8[024-9]|9[013-9])|" ."1(?:1[1-9]|2[0-57-9]|3[0-57-9]|4[0-9]|5[0-9]|6[0-9]|" ."7[0-9]|8[0-4])|" ."2(?:1[0-5]|2[0-9]|3[0-4]|4[0-3]|6[1-35-9]|7[0-3])|" ."3(?:0[89]|1[0-9]|2[02-46-9]|3[0-9]|4[0-9]|5[0-9]|6[01]|70|" ."8[01])|" ."4(?:09|1[0-9]|2[02-9]|3[0-6]|4[0-9]|5[0-4])|" ."5(?:1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]|6[0-7])|" ."6(?:09|1[0-79]|2[0-9]|3[0-7]|5[1-4]|6[1-9]|7[0-4]|8[01])|" ."7(?:1[1-9]|2[0-9]|3[0-46-9]|4[01]|6[1-4])|" ."8(?:50|60|8[07-9])|" ."9(?:00|1[0-689]|2[0-25689]|3[0-9]|4[0-269]|5[0-8]|" ."6[014-68]|7[14-9]|8[0-8]|9[0-24-9]))" ."|3(?:2(?:0[15689]|1[0-9]|2[0-59]|3[0-9]|4[0-39]|5[0-9]|" ."6[015-79]|7[0-9]|8[0-8]|90)|" ."3(?:1[13-8]|2[0-9]|3[02-7]|4[015-9]|5[0-9]|6[0-9]|7[0-8]|" ."8[02-69]|9[0-8])|" ."4(?:0[1-39]|1[0-9]|2[0-9]|3[0-3569]|4[0-9]|5[0-4]|6[0-9]|" ."7[0-6]|8[0-9]|9[0-3])|" ."5(?:0[1-9]|1[0-7]|2[0-69]|3[0-29]|4[0-9]|5[0-5]|6[0-9]|" ."7[0-6]|8[2-589]|9[0-8])|" ."6(?:01|1[1-7]|2[0-2]|3[015-8]|4[0-4]|5[0-8]|60|7[0-9]|" ."8[0-2])|" ."7(?:0[15]|1[0-9]|2[0-9]|3[013-9]|4[0-4]|5[0-5]|6[1-8]|" ."7[0-6]|8[0-246-9]|90)|" ."8(?:01|1[0-9]|2[0-6]|3[0-9]|4[0-4]|5[0-9]|6[0-4]|7[0-9]|" ."8[0-4]|9[5-9])|" ."9(?:0[19]|1[0-9]|2[0-9]|3[0-9]|4[013-5]|6[01]|8[05]))" ."|4(?:0(?:0[1-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]|6[0-9]|" ."7[0-4]|8[0-68])|" ."1(?:0[0-35-9]|1[0-689]|2[0-356]|3[0-9]|4[0-39]|5[0-6]|" ."6[4-9]|7[0-9]|80)|" ."2(?:0[1-9]|1[013467]|2[0-2]|3[0-9]|4[0-9]|5[0-6]|6[0-8]|" ."7[0-25-9]|8[0-39])|" ."3(?:0[1-9]|1[04-9]|2[0-8]|3[0-7]|4[0-9]|5[0-5]|6[0-9]|" ."7[0-3]|8[0-5]|9[0-8])|" ."4(?:0[125-9]|1[0-9]|2[0-39]|3[0-9]|4[0-9]|5[019]|6[0-9]|" ."7[05-9]|8[0-9]|9[0-49])|" ."5(?:0[1-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]|6[0-59]|" ."7[0-9]|8[0-3]|9[0-9])|" ."6(?:0[1-9]|1[0-3]|2[0-9]|3[0-689]|4[0-9]|5[0136-8]|6[0-9]|" ."7[0-26-9]|8[0-9]|9[0-36-8])|" ."7(?:0[126-9]|1[0-9]|2[0-2]|3[0-9]|4[0-5]|5[0-9]|6[0-3]|" ."7[0-9]|8[0-6]|9[5-8])|" ."8(?:0[124-9]|1[0-589]|2[02-69]|3[0-47-9]|4[02-9]|5[03]|" ."7[0-9]|8[0-9]|9[0-5])|" ."9(?:0[126-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-689]|6[0-9]|" ."7[0-9]|8[0-24-9]|9[0-9]))" ."|5(?:2(?:01|1[1-9]|2[0-2]|3[0-9]|4[0134]|5[0-6]|80|9[09])|" ."3(?:1[024-8]|2[02468]|3[0-79]|4[0-2]|5[1-359]|6[0-9]|" ."7[0-8]|80)|" ."4(?:0[1-578]|1[0-9]|2[1-79]|3[0-59]|4[0-7]|5[01]|6[056]|" ."7[01]|8[0-3589]|9[59])|" ."5(?:0[15-7]|1[1-9]|2[0-3]|3[0-9]|4[0489]|5[0-9]|6[01]|" ."7[0-7])|" ."6(?:0[125]|1[0-9]|2[06-9]|3[0-9]|40|5[0-9]|7[015]|8[0-7]|" ."9[0-358])|" ."7(?:01|1[0-46-9]|2[0-3]|30|4[01]|5[0-6]|6[0-2]|7[0-6])|" ."8(?:0[189]|1[0-9]|2[0-689]|3[0-9]|4[0-46]|5[02-69]|6[0-9]|" ."7[0-68]|8[04-9]|9[0-389])|" ."9(?:4[0-3]|5[0-9]|6[0-49]|7[0-8]))" ."|6(?:1(?:01|1[1-9]|2[0-59]|3[0-9]|4[0-9]|5[05]|6[0-3569]|" ."7[015]|8[0-9]|9[05-7])|" ."2(?:01|1[0-5]|25|3[01589]|4[0356]|5[0-25])|" ."3(?:01|1[0-5]|40|50|60|70|80)|" ."4(?:0[12689]|1[0-9]|2[0-3]|3[0-9]|4[0-35-9]|5[0-5]|6[0-9]|" ."7[0-9]|8[0-8]|9[0-79])|" ."5(?:5[0-357-9]|6[02]|7[0-29]|8[0-35-7]|90)|" ."6(?:01|1[0-9]|2[0-3]|3[0-8]|4[5-9]|5[01]|6[013569]|7[0-8]|" ."8[0-9]|9[0-35])|" ."7(?:01|1[1-9]|2[0-6]|3[0-9]|4[0-5]|5[0-9]|6[0-5]|7[0-9]|" ."8[0-6]|9[0-6])|" ."8(?:15|3[0-9]|4[0-2]|5[0-28]|6[89]|7[01]|80)|" ."9(?:0[156]|1[0-9]|2[1-356]|3[01349]|4[0-8]|5[0156]|" ."6[0-29]|7[0-9]|8[0-25-9]|9[0-25-9]))" ."|7(?:2(?:0[129]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]|6[0-489]|" ."7[04])|" ."3(?:0[2-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]|6[0-4]|" ."7[0-9]|8[0-4]|9[0-25-7])|" ."4(?:09|1[0-25-8]|2[013-5]|3[0-35]|4[0-9]|5[0-8]|6[0-5]|" ."7[0135]|8[0-2])|" ."5(?:0[125-8]|1[1-9]|2[0-6]|3[1-9]|4[0-7]|5[3-9]|6[0-9]|" ."7[0-2]|9[0-9])|" ."6(?:01|1[023589]|2[0-7]|3[3-69]|4[019]|5[0-3]|6[0-4]|" ."7[03]|8[01])|" ."7(?:0[13]|1[0-6]|2[0-467]|3[0-57-9]|4[01]|5[089]|6[0-9]|" ."7[0-47-9]|8[0-9]|9[0-5]))" ."|8(?:0(?:0[125-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]|6[0-9]|" ."7[0-9]|8[0-9]|9[0-9])|" ."1(?:1[0-25-9]|2[013-9]|3[0-57-9]|4[0-25-79]|5[0-46-9]|" ."6[05-7]|79|8[0-9]|9[01])|" ."2(?:0[159]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-589]|6[0-9]|" ."7[0-47-9]|8[0-9]|9[0-5])|" ."3(?:0[1-3689]|1[0-9]|2[0-9]|3[0-9]|4[0-5]|5[0-9]|6[0-9]|" ."7[0-689]|8[013-8]|9[0-689])|" ."4(?:01|1[0-5]|2[0-4]|3[5-8]|4[0-57-9]|5[0-3]|6[0-9]|" ."7[0-9]|80)|" ."5(?:0[126-9]|1[01]|2[1-35-9]|3[0137-9]|4[0-6]|5[0-278]|" ."6[0-2])|" ."6(?:0[69]|1[0-5]|20)|" ."7(?:0[15-8]|1[015]|20)|" ."8(?:0[125689]|1[1-46-9]|2[0-6]|3[1-58]))" ."|9(?:0(?:0[1-46]|1[0-9]|2[0-9]|3[0-3]|4[0-8]|5[0-6]|6[0-9]|" ."7[0-2]|8[0-9]|9[0-489])|" ."1(?:1[5-9]|2[0-9]|3[0-7]|4[024-7]|5[013-8]|6[013-9]|" ."7[0-35-79]|8[0-4689]|9[01])|" ."2(?:0[1-9]|1[0-8]|2[014-9]|3[0-9]|4[0-59]|5[0-9]|6[0-8]|" ."7[35-9]|8[0-9]|9[0-4])|" ."3(?:30|40|5[0-79]|6[014-689]|7[0-35-8]|8[0-2]|9[0-25])|" ."4(?:0[15-9]|1[0-24-9]|2[0-6]|40|5[1-9]|6[1-6])|" ."5(?:0[126]|1[0-9]|2[0-3]|3[0-9]|4[0-5]|5[0-9]|60|7[0-9])|" ."6(?:3[1-35-9]|4[013-578]|5[013-79]|6[0235689]|7[0-468]|" ."8[12479]|9[06])|" ."7(?:0[16-9]|1[0-5]|3[78]|4[0-9]|5[1-9]|6[0-9]|7[0-69]|80)|" ."8(?:0[15-9]|3[013-9]|4[01])|" ."9(?:0[1-35-9]|1[0-3]|4[02-468]|5[0246]|6[02468]|7[0246]|" ."8[02]|9[0-39]))" .")",Monaco=>"(?k:980[0-9][0-9])",Norway=>"(?k:0(?:0(?:01|1[058]|2[14-68]|3[0-47]|4[05-8]|5[015]|60|80)|" ."1(?:0[1-79]|1[0-9]|2[0-589]|3[0-9]|5[0-57-9]|6[0-24-9]|" ."7[0-9]|8[0-8]|9[0-68])|" ."2(?:0[1-478]|1[1-8]|30|4[047]|5[0-9]|6[02-8]|7[0-9]|" ."8[0-467])|" ."3(?:0[1-9]|1[13-9]|23|30|4[09]|5[0-9]|6[0-9]|7[0-9]|" ."8[0-3])|" ."4(?:0[1-689]|1[0-35]|2[1-4]|4[0-25]|5[0-24-9]|6[0-57-9]|" ."7[02-9]|8[0-9]|9[0-6])|" ."5(?:0[1-9]|1[0-35-8]|20|40|5[0-9]|6[0-9]|7[0-9]|8[0-9]|" ."9[0-8])|" ."6(?:0[1-9]|1[1-9]|2[0-46]|5[0-9]|6[0-9]|7[0-9]|8[0-9]|" ."9[0-4])|" ."7(?:0[125]|1[02]|5[0-8]|6[03-8]|7[0-9]|8[1-9]|9[01])|" ."8(?:0[15-7]|40|5[0-8]|6[0-4]|7[0-7]|8[0-4]|9[01])|" ."9(?:0[1-578]|1[3-5]|5[0-9]|6[02-489]|7[0-35-9]|8[0-8]))" ."|1(?:0(?:0[135-9]|11|5[1-6]|6[1-57-9]|71|8[1346-9])|" ."1(?:0[129]|12|5[0-8]|6[0-9]|7[026-9]|8[12457-9])|" ."2(?:0[1-57]|1[45]|5[0-9]|6[236]|7[0-589]|8[13-6]|9[0145])|" ."3(?:0[0-79]|1[1-46-9]|2[1-9]|3[0-9]|4[0-24689]|5[0-46-9]|" ."6[0-9]|7[1-35-9]|8[013-9]|9[0-79])|" ."4(?:0[0-9]|1[0-9]|2[019]|3[0-2]|4[0-9]|5[013-578]|6[89]|" ."7[0-9]|8[0-8])|" ."5(?:0[1-4689]|1[0-9]|2[0-689]|3[0-9]|4[015]|5[056]|60|70|" ."8[01]|9[0-36-9])|" ."6(?:0[1-9]|1[02-9]|2[014-689]|3[02-46-9]|4[0-2]|" ."5[013-57-9]|6[1-7]|7[0-35689]|8[02-4]|9[02])|" ."7(?:0[1-9]|1[0-589]|2[0-7]|3[03-589]|4[0235-7]|5[1-479]|" ."6[013-9]|7[126-9]|8[1-9]|9[0-4689])|" ."8(?:0[1-9]|1[1-6]|2[0357]|3[0-3]|5[019]|6[0167]|7[0158]|" ."80|9[0-3])|" ."9(?:0[013]|1[0-2467]|2[013-9]|3[01]|4[01]|5[04]|6[013]|" ."7[01]))" ."|2(?:0(?:0[013-9]|1[0-9]|2[0-8]|3[0-6]|4[01]|5[0-8]|6[0-26-9]|" ."7[0-46]|8[01]|9[0-3])|" ."1(?:0[01]|1[046]|2[03]|3[034]|5[01]|6[0-24-6]|70)|" ."2(?:0[1-689]|1[0-46-9]|2[03-6]|3[0235]|40|56|6[014-6]|" ."7[01]|8[03])|" ."3(?:0[1-9]|1[25-9]|2[0-6]|3[024-8]|4[0145]|5[035]|6[045]|" ."72|8[0-9]|9[01])|" ."4(?:0[1-35-9]|1[0-2568]|2[0-357-9]|3[025-8]|4[0368]|5[01]|" ."60|7[6-8]|8[015])|" ."5(?:0[01]|1[02]|4[024]|5[025]|6[01]|8[0-24])|" ."6(?:0[1-9]|1[0-9]|2[4-69]|3[0-79]|4[0235-9]|5[1-36-9]|" ."6[0-9]|7[02-7]|8[02-8]|9[03-5])|" ."7(?:1[1-8]|20|30|4[023]|50|60|70)|" ."8(?:0[1-9]|1[015-9]|2[0-257]|3[0-26-9]|4[036-9]|5[013478]|" ."6[0-2467]|7[09]|8[0-2]|9[03])|" ."9(?:0[017]|1[078]|2[039]|3[03679]|4[03]|5[02-49]|6[067]|" ."7[3-57]|85))" ."|3(?:0(?:0[1-9]|1[1-9]|2[1-9]|3[0-9]|4[0-8]|5[013-8]|6[01]|" ."7[015]|8[0-9]|9[025])|" ."1(?:0[13-9]|1[0-9]|2[0-8]|3[1-357-9]|4[0-58]|5[0-47-9]|" ."6[0-9]|7[0-9]|8[0-9]|9[1-69])|" ."2(?:0[1-9]|1[0-9]|2[0-9]|3[0-9]|4[0-69]|5[1-9]|6[0-57-9]|" ."7[014-7]|8[0-245]|9[0-24-7])|" ."3(?:0[01]|2[0-2]|3[01]|4[0-2]|5[01589]|6[01]|7[01])|" ."4(?:0[1-9]|1[0-4]|2[015-8]|3[01]|4[0-2]|7[0-24-8]|8[0-4]|" ."9[01])|" ."5(?:0[1-47]|1[0-9]|2[0-689]|3[013-9]|4[014]|5[01]|6[01]|" ."7[015-79]|8[018]|9[35])|" ."6(?:0[1-689]|1[0-9]|2[0-46-9]|3[0-2]|4[6-8]|5[0268]|" ."6[0156]|7[1-9]|8[0134]|9[0-27])|" ."7(?:0[1-578]|1[0-9]|2[0-9]|3[0-9]|4[0-46-9]|5[03]|6[06]|" ."70|8[01357-9]|9[0-68])|" ."8(?:0[0-5]|1[0-2]|2[05]|3[0-6]|4[01489]|5[03-5]|64|70|" ."8[02-8]|9[0135])|" ."9(?:0[1-6]|1[0-9]|2[0-24589]|3[013679]|4[0-46-9]|50|" ."6[05-7]|70|9[13-9]))" ."|4(?:0(?:0[1-9]|1[0-9]|2[0-9]|3[1-6]|4[1-9]|5[0-9]|6[4-9]|" ."7[06-9]|8[1-9]|9[0-9])|" ."1(?:0[02]|1[09]|2[0346-9]|3[0479]|4[68]|5[02-4689]|" ."6[01347-9]|7[034]|8[027]|98)|" ."2(?:0[0189]|3[03-579]|4[04]|50|6[0245]|7[024-6]|80|" ."9[14-9])|" ."3(?:0[1-9]|1[0-9]|2[1-9]|3[02359]|4[0-9]|5[2-8]|" ."6[02-57-9]|7[0-689]|8[0179]|9[1-8])|" ."4(?:0[0-3]|20|3[2468]|4[013]|6[0235]|73|8[045]|9[0-2])|" ."5(?:0[1-69]|1[3-79]|2[0-589]|3[246]|4[04]|5[0-478]|6[03]|" ."7[5-79]|8[068]|9[056])|" ."6(?:0[4-689]|1[0-9]|2[0-689]|3[0-9]|4[05-7]|5[16-9]|" ."6[1-6]|7[0-9]|8[1-9]|9[13-9])|" ."7(?:0[0-35]|15|2[04]|3[03-57]|4[12578]|5[4-6]|6[068]|70|" ."80|9[0-5])|" ."8(?:0[1-489]|1[025-8]|2[013-578]|3[024689]|4[1-46-9]|" ."5[1-9]|6[1-589]|7[06-9]|8[4-9]|9[1-468])|" ."9(?:0[0-29]|1[0256]|20|34|5[0-35]|7[1-4]|8[05]|9[034]))" ."|5(?:0(?:0[3-9]|1[0-9]|2[0-2]|3[1-9]|4[1-35]|5[2-9]|6[378]|" ."7[235]|8[129]|9[346-9])|" ."1(?:0[14-9]|1[13-9]|2[124]|3[0-24-7]|4[1-8]|5[1-5]|6[0-5]|" ."7[0-46-9]|8[34])|" ."2(?:0[0-36-9]|1[0-25-8]|2[1-9]|3[0-25-9]|4[34]|5[1-47-9]|" ."6[0-578]|8[1-6]|9[139])|" ."3(?:0[0-9]|1[04589]|2[1-35-79]|3[13-7]|4[1-35-7]|" ."5[03-578]|6[0356]|7[1489]|8[0-24578]|9[2-46-9])|" ."4(?:0[1-46-9]|1[0-9]|2[0378]|3[07]|4[03-579]|5[0-57-9]|" ."6[02-5]|7[02-6]|8[046]|9[89])|" ."5(?:0[1-9]|1[124-9]|2[1-357-9]|3[1-8]|4[124-9]|5[01459]|" ."6[0135-8]|7[04-68]|8[02-689]|9[013-68])|" ."6(?:0[0-245]|1[024]|2[06-9]|3[025-7]|4[0-35-79]|5[023]|" ."8[0357]|9[03-6])|" ."7(?:0[0-9]|1[0-589]|2[1-9]|3[01346]|4[1-35-9]|5[0-2]|" ."6[03]|7[036-9]|8[0-8])|" ."8(?:0[3-9]|1[0-9]|2[0-24589]|3[1568]|4[157-9]|5[1-47-9]|" ."6[1-489]|7[1-36-9]|8[1246-9]|9[23569])|" ."9(?:0[2-46-8]|1[1-8]|3[16-9]|4[1378]|5[1-7]|6[0-267]|" ."7[07-9]|8[13467]|9[134]))" ."|6(?:0(?:0[1-9]|1[0-9]|2[0-68]|3[05-9]|4[03-8]|5[0-257-9]|" ."6[02-57-9]|7[06]|8[02-579]|9[0-24-689])|" ."1(?:0[0-6]|10|20|3[39]|4[0-469]|5[0-6]|6[0156]|7[04]|" ."8[34]|9[06])|" ."2(?:0[01]|1[0-68]|2[024]|3[089]|4[09]|5[09]|6[03-5]|7[02]|" ."8[0-35]|9[02-4])|" ."3(?:0[01]|1[05]|20|3[09]|50|6[034]|8[67]|9[0-9])|" ."4(?:0[1-57-9]|1[0-689]|2[1-359]|3[013-6]|4[03-57]|5[03-7]|" ."6[0-2]|7[0256]|8[01346-8]|9[0349])|" ."5(?:0[1-46-9]|1[0-24-8]|2[0-59]|3[089]|7[01]|90)|" ."6(?:0[01]|1[0-3]|2[0289]|3[0136-9]|4[02-5]|5[0235-9]|" ."7[04]|8[036-9]|9[0347-9])|" ."7(?:0[0-478]|1[013-9]|2[136-9]|3[0147]|4[01]|5[01]|6[13]|" ."7[0-26-9]|8[1-489]|9[1-35-9])|" ."8(?:0[0-9]|1[0-57-9]|2[1-36-9]|4[1378]|5[1-689]|6[13689]|" ."7[0-35-9]|8[124-8]|9[13-689])|" ."9(?:0[0-39]|1[24-9]|2[146-9]|4[0-2467]|5[1378]|6[1346-9]|" ."7[13578]|8[0-8]|9[1356]))" ."|7(?:0(?:0[3-6]|1[0-689]|2[0-9]|3[0-46-9]|4[0-9]|5[0-46-9]|" ."7[024589]|8[0-389]|9[127-9])|" ."1(?:0[015]|1[02-49]|2[015-79]|30|4[02]|5[02369]|6[05-9]|" ."7[06-8]|80|9[04])|" ."2(?:0[0136]|1[1-3]|2[13478]|3[124-689]|4[0-367]|5[025-79]|" ."6[013468]|7[03]|8[024-9]|9[0158])|" ."3(?:0[0-2]|1[05689]|2[0179]|3[1-68]|4[0-35]|5[013-578]|61|" ."7[024]|8[03467]|9[1-37-9])|" ."4(?:0[0-9]|1[0-9]|2[0-24-9]|3[0-9]|4[0-9]|5[0-9]|" ."6[1-35-9]|7[0-9]|8[0-9]|9[0-7])|" ."5(?:0[0-9]|1[02-479]|2[059]|3[013]|4[019]|5[01]|6[0236]|" ."70|8[0134]|9[016])|" ."6(?:0[0-9]|1[09]|2[02-49]|3[0-4]|5[0-8]|60|7[01]|90)|" ."7(?:0[1-57-9]|1[0-8]|2[4-69]|3[024-9]|4[024-68]|5[01]|" ."6[01]|7[017]|9[0167])|" ."8(?:0[0-58]|1[07-9]|2[02]|56|6[0349]|7[013]|8[24]|" ."9[02368])|" ."9(?:0[01]|4[04]|50|60|7[01367]|8[0-25]|9[034]))" ."|8(?:0(?:0[1-9]|1[0-69]|2[0-36-9]|3[0-278]|4[17-9]|5[068]|" ."6[34]|7[0-69]|8[46-9]|9[1-8])|" ."1(?:0[0238]|1[048]|2[08]|3[0568]|4[0569]|5[017-9]|6[018]|" ."7[08]|8[124-9]|9[035-8])|" ."2(?:0[0-35-9]|1[014589]|2[06]|3[0-3]|5[0156]|6[0146]|" ."7[013-68]|8[135689]|9[01478])|" ."3(?:0[0159]|1[0-7]|2[02-68]|40|5[27]|60|7[0236-8]|" ."8[02478]|9[0238])|" ."4(?:0[0-9]|1[0-6]|2[68]|3[0289]|4[57]|5[059]|6[59]|7[05]|" ."8[013-589]|93)|" ."5(?:0[1-9]|1[02-8]|2[023]|3[013-69]|4[036]|9[01])|" ."6(?:0[1-478]|1[03-8]|2[246]|3[048]|4[0-36-8]|5[124-9]|" ."6[013-6]|72|8[01]|9[01])|" ."7(?:0[01]|2[03-5]|3[0235]|4[023]|5[02-4]|6[12467]|70)|" ."8(?:0[0-59]|13|2[07]|30|4[24]|5[0-24]|6[015]|70|80|" ."9[0-27])|" ."9(?:0[0-24-9]|10|2[0-2]|6[01]|76|8[015]))" ."|9(?:0(?:0[6-9]|1[0-9]|2[02479]|3[0478]|4[02369]|5[05-79]|" ."6[02489])|" ."1(?:0[0-8]|1[089]|2[08]|3[0-24-8]|4[0-46-8]|5[1-369]|" ."6[1-39]|8[0-24-79]|9[02-57])|" ."2(?:40|5[1-9]|6[0-35-9]|7[0-9]|8[0-8]|9[0-4689])|" ."3(?:0[02-6]|1[0156]|2[12569]|3[4-6]|5[0578]|6[05]|" ."7[02369]|8[0-24-9]|9[1-35])|" ."4(?:0[2-9]|1[1459]|2[03-7]|3[069]|4[0-8]|5[013-5]|" ."7[01569]|8[0-9]|9[6-8])|" ."5(?:0[1-9]|1[0-9]|2[015]|3[1-36]|4[05]|5[01]|8[02-7]|" ."9[035])|" ."6(?:0[09]|1[056]|2[014]|5[07]|64|7[02]|9[0-2])|" ."7(?:0[09]|1[0-7]|22|3[05]|4[02]|5[01]|6[03-58]|7[0-35]|82|" ."90)|" ."8(?:0[02]|1[015]|2[06]|4[056])|" ."9(?:00|1[024-7]|25|3[05]|5[01]|60|8[0-2]|9[01]))" .")",'San Marino'=>"(?k:4789[0-9])",Spain=>"(?k:(?k:0[1-9]|[1-4][0-9]|5[0-2])(?k:[0-9])(?k:[0-9]{2}))",Switzerland=>"(?k:1(?:0(?:0[0-9]|1[0-2457-9]|2[02-9]|3[0-9]|4[0-7]|5[2-589]|" ."6[1-368]|7[0-36-8]|8[0-58]|9[0-8])|" ."1(?:1[02-7]|2[1-8]|3[124-6]|4[1-9]|6[2-9]|7[02-6]|8[02-9]|" ."9[5-7])|" ."2(?:0[0-9]|1[1-9]|2[02-8]|3[1-4679]|4[0-8]|5[1-8]|6[0-9]|" ."7[0-9]|8[13-9]|9[0-9])|" ."3(?:0[02-8]|1[0-35-8]|2[0-69]|3[078]|4[1-8]|5[02-8]|" ."7[2-7])|" ."4(?:0[014-9]|1[0235-8]|2[0-9]|3[0-9]|4[0-356]|5[02-4]|" ."6[2-48]|7[03-5]|8[2-69])|" ."5(?:09|1[02-5]|2[1-9]|3[02-8]|4[1-5]|5[1-5]|6[2-8]|" ."8[02-9]|95)|" ."6(?:0[7-9]|1[0-9]|2[3-8]|3[0-8]|4[2-9]|5[1-46-9]|" ."6[0135-79]|7[03-9]|8[0-9]|9[0-24-79])|" ."7(?:0[0-2457-9]|1[2-9]|2[0-8]|3[0-8]|4[0-24-9]|5[2-467]|" ."6[23]|7[2-6]|8[2-9]|9[1-7])|" ."8(?:0[0-9]|1[14-8]|2[02-4]|3[23]|4[4-7]|5[2-46]|6[02-9]|" ."7[0-5]|8[0245]|9[0-35-9])|" ."9(?:0[2-8]|1[1-489]|2[0-35-9]|3[2-46-8]|4[1-8]|5[013578]|" ."6[1-9]|7[1-8]|8[1-8]|9[1-467]))" ."|2(?:0(?:0[0-46-9]|1[02-79]|2[2-578]|3[4-7]|4[236]|5[2-46-8]|" ."6[3578]|7[2-5]|8[78])|" ."1(?:0[358]|1[2-7]|2[3467]|49)|" ."20[6-8]|3(?:0[0-46]|1[468]|2[25]|3[368]|4[05]|5[034]|" ."6[02-4])|" ."4(?:0[056]|1[46])|" ."5(?:0[0-5]|1[02-8]|2[035]|3[2-8]|4[02-5]|5[2-8]|6[02-5]|" ."7[25-7])|" ."6(?:0[3-8]|1[02356])|" ."7(?:1[02-8]|2[023]|3[23568]|4[02-8]|62)|" ."8(?:0[0235-7]|1[2-4]|2[2-9]|3[02]|4[23]|5[2-7]|6[34]|73|" ."8[2-9])|" ."9(?:0[02-8]|1[24-6]|2[2-6]|3[235]|4[2-467]|5[02-4]))" ."|3(?:0(?:0[0-8]|1[0-57-9]|2[0479]|3[02-9]|4[0-9]|5[02-4]|" ."6[35-8]|7[0-8]|8[2-9]|9[5-9])|" ."1(?:1[0-6]|2[2-8]|32|4[4578]|5[02-9]|7[2-9]|8[2-6])|" ."2(?:0[2-8]|1[02-6]|2[56]|3[2-8]|5[0-7]|6[2-46-8]|7[0-4]|" ."8[02-6]|9[2-8])|" ."3(?:0[235-9]|1[2-57]|2[1-6]|6[0235-8]|7[2-7]|80)|" ."4(?:0[0-2]|1[2-9]|2[1-9]|3[2-9]|5[2-7]|6[2-5]|7[2-6])|" ."5(?:0[346-8]|1[023]|3[1-8]|43|5[0-35-7])|" ."6(?:0[0-57-9]|1[2-9]|2[2-9]|3[1-68]|4[5-7]|5[2-8]|6[1-5]|" ."7[1-4])|" ."7(?:0[02-7]|1[13-8]|2[2-5]|5[2-8]|6[2-6]|7[0-35-8]|8[0-5]|" ."92)|" ."8(?:0[013-7]|1[2-68]|2[2-6]|5[2-8]|6[02-4])|" ."9(?:0[0-8]|1[0-46-9]|2[02-9]|3[0-57-9]|4[02-9]|5[1-7]|" ."6[0135-8]|7[0-9]|8[2-9]|9[1-9]))" ."|4(?:0(?:0[0-57-9]|1[0-35-9]|2[03-5]|3[0-59]|4[0-2]|5[1-9]|65|" ."7[058]|8[0-9]|9[1-6])|" ."1(?:0[1-8]|1[24-8]|2[3-7]|3[23]|4[2-8]|53)|" ."2(?:0[2-46-8]|2[2-9]|3[2-4]|4[2-7]|5[2-4])|" ."3(?:0[2-5]|1[02-7]|2[2-5]|3[2-4])|" ."4(?:02|1[0-9]|2[1-6]|3[1-8]|4[1-8]|5[0-35-8]|6[0-9]|" ."9[2-7])|" ."5(?:0[0-39]|1[2-5]|2[2-58]|3[2-9]|4[23]|5[1-46-8]|6[2-6]|" ."7[1346-9]|8[1-8])|" ."6(?:0[0139]|1[1-8]|2[0-689]|3[02-4]|40|5[2-8]|6[35])|" ."7(?:0[2-4]|1[02-9])|" ."8(?:0[0-35-9]|1[2-4]|5[236])|" ."9(?:0[0-2]|1[1-79]|2[2-4]|3[2-8]|4[2-4]|5[02-5]))" ."|5(?:0(?:0[014]|1[02-578]|2[2-8]|3[2-7]|4[02-46]|5[346-8]|" ."6[2-4]|7[02-9]|8[02-5])|" ."1(?:0[235-8]|1[236])|" ."2(?:0[01]|1[023]|2[2-5]|3[2-7]|4[2-6]|7[2-7])|" ."3(?:0[013-6]|1[2-8]|2[2-6]|3[02-4])|" ."4(?:0[0-24-68]|1[235-7]|2[0356]|3[0-26]|4[2-5]|5[2-4]|" ."6[2-7])|" ."5(?:0[2-7]|12|2[245])|" ."6(?:0[013-8]|1[0-9]|2[0-8]|3[02467]|4[2-7])|" ."7(?:0[2-8]|12|2[2-8]|3[2-7]|4[256]))" ."|6(?:0(?:0[02-9]|1[0-9]|2[0-8]|3[0-9]|4[2-578]|5[2356]|" ."6[0-46-8]|7[2-48]|8[3-6])|" ."1(?:0[2356]|1[02-4]|2[2356]|3[023]|4[2-7]|5[2-46]|" ."6[0-367]|7[034]|82|9[267])|" ."2(?:0[3-8]|1[0-8]|2[12]|3[1-6]|4[2-8]|5[23]|6[02-5]|" ."7[4-7]|8[013-9]|9[45])|" ."3(?:0[0-4]|1[02-57-9]|3[0-3]|4[0-69]|5[346]|6[235]|7[0-7]|" ."8[236-8]|9[01])|" ."4(?:0[2-5]|1[04-8]|2[2-4]|3[0-468]|4[0-3]|5[24]|6[0-9]|" ."7[2-6]|8[2457]|9[013])|" ."5(?:0[0136]|1[1-8]|2[3-8]|3[2-578]|4[0-9]|5[6-8]|6[235]|" ."7[1-9]|8[2-4]|9[02-9])|" ."6(?:0[0-245]|1[1-468]|22|3[1-7]|4[4-8]|5[2-9]|6[1-4]|" ."7[02-8]|8[2-5]|9[02-6])|" ."7(?:0[2357]|1[03-9]|2[0-4]|4[2-9]|6[034]|7[2-7]|8[01])|" ."8(?:0[2-9]|1[04-8]|2[1-35-8]|3[02-9]|5[02-5]|6[2-7]|" ."7[2-57]|83)|" ."9(?:0[0-8]|1[1-9]|2[124-9]|3[02-9]|4[2-9]|5[0-9]|6[2-8]|" ."7[46-9]|8[0-46-9]|9[0-9]))" ."|7(?:0(?:0[0-467]|1[2-9]|2[36-9]|3[12]|5[06-8]|6[2-4]|7[4-8]|" ."8[2-4])|" ."1(?:0[4679]|1[0-6]|2[26-8]|3[02-8]|4[1-9]|5[1-9]|6[2-8]|" ."7[2-6]|8[02-9])|" ."2(?:0[1-68]|1[2-5]|2[02-468]|3[1-35]|4[0-79]|5[02]|6[05]|" ."7[026-8])|" ."3(?:0[2-467]|1[02-57]|2[03-6])|" ."4(?:0[2-578]|1[1-9]|2[1-8]|3[0-8]|4[02-8]|5[0-9]|6[02-4]|" ."7[237]|8[24]|9[2-4])|" ."5(?:0[02-5]|1[2-7]|2[2-7]|3[02-7]|4[2356]|5[0-46-9]|" ."6[023])|" ."6(?:0[2-68]|10)|" ."7(?:10|4[1-8]))" ."|8(?:0(?:0[0-68]|1[0-256]|2[0-467]|3[0-46-9]|4[0-24-9]|" ."5[0-357-9]|6[013-68]|7[0145]|8[015-8]|9[0-3689])|" ."1(?:0[2-9]|1[2-578]|2[1-7]|3[02-6]|4[23]|5[2-8]|6[24-6]|" ."7[2-5]|8[0-57]|9[2-7])|" ."2(?:0[0-578]|1[02-9]|2[2-68]|3[1-689]|4[0-35-8]|5[2-59]|" ."6[0-9]|7[2-4]|8[05])|" ."3(?:0[1-9]|1[0-2457]|2[025]|3[0-25]|4[02-5]|5[2-7]|6[023]|" ."7[0-246])|" ."4(?:0[0-24-689]|1[0-68]|2[1-8]|4[247]|5[0-57-9]|6[0-8]|" ."7[124-9]|8[2-46-9]|9[2-9])|" ."5(?:0[0-35-8]|1[024]|2[02-6]|3[025-7]|4[02-8]|5[2-68]|" ."6[014-6]|7[02-7]|8[0-9]|9[02-9])|" ."6(?:0[02-8]|1[02-8]|2[0-7]|3[02-9]|4[056])|" ."7(?:0[02-46-8]|1[2-8]|2[235-7]|3[02-57-9]|40|5[0-9]|" ."6[25-7]|7[2-57]|8[2-4])|" ."8(?:0[0-8]|1[02356]|2[045]|3[2-6]|4[0-79]|5[2-8]|6[2-8]|" ."7[2-47-9]|8[0-9]|9[02-8])|" ."9(?:0[1-9]|1[0-9]|2[56]|3[2-4]|42|5[1-7]|6[24-7]|70))" ."|9(?:0(?:0[0146-9]|1[0-6]|2[02-9]|3[02-8]|4[2-4]|5[02-8]|" ."6[2-4])|" ."1(?:0[0-578]|1[2-6]|2[235-7])|" ."2(?:0[013-5]|1[2-7]|2[035]|3[01]|4[02-9])|" ."3(?:0[014-68]|1[2-5]|2[0235-7])|" ."4(?:0[0-5]|1[0134]|2[2-8]|3[04-7]|4[2-5]|5[0-3]|6[2-9]|" ."7[0-35-9])|" ."5(?:0[0-46-8]|1[02457]|2[3-7]|3[2-6]|4[235-8]|5[2-6]|" ."6[25]|73)|" ."6(?:0[1246-8]|1[2-5]|2[0-2]|3[013]|4[23]|5[0-25-8]))" .")",'Vatican City'=>"(?k:00120)",);my%alternatives=(Australia=>[qw /Australian/],France=>[qw /French/],Germany=>[qw /German/],);while (my ($country,$zip)=each%zip){my@names=($country);push@names=>@{$alternatives {$country}}if$alternatives {$country};for my$name (@names){my$pat_name=$name eq "Denmark" && $] < 5.00503 ? [zip=>$name,qw /-country=/]: [zip=>$name,qw /-prefix= -country=/];pattern name=>$pat_name,create=>sub {my$pt=_t $_ [1]{-prefix};my$cn=_c$country=>$_ [1]{-country};my$pfx="(?:(?k:$cn)-)";"(?k:$pfx$pt$zip)"},}}for my$country (qw /Netherlands Dutch/){pattern name=>['zip',$country=>qw /-prefix= -country=/,"-sep= "],create=>sub {my$pt=_t $_ [1]{-prefix};my$num='[1-9][0-9]{3}';my$let='[A-EGHJ-NPRTVWXZ][A-EGHJ-NPRSTVWXZ]|' .'S[BCEGHJ-NPRTVWXZ]';my$sep=__ $_ [1]{-sep};my$cn=_c Netherlands=>$_ [1]{-country};my$pfx="(?:(?k:$cn)-)";"(?k:$pfx$pt(?k:(?k:$num)(?k:$sep)(?k:$let)))"},}pattern name=>[qw /zip US -prefix= -country= -extended= -sep=-/],create=>sub {my$pt=_t $_ [1]{-prefix};my$et=_t $_ [1]{-extended};my$sep=__ $_ [1]{-sep};my$cn=_c USA=>$_ [1]{-country};my$pfx="(?:(?k:$cn)-)";my$zip="(?k:(?k:[0-9]{3})(?k:[0-9]{2}))";my$ext="(?:(?k:$sep)(?k:(?k:[0-9]{2})(?k:[0-9]{2})))";"(?k:$pfx$pt(?k:$zip$ext$et))"},;pattern name=>['zip','Australia'=>qw /-prefix= -country= -lax=/],create=>sub {my$pt=_t $_ [1]{-prefix};my$cn=_c Australia=>$_ [1]{-country};my$pfx="(?:(?k:$cn)-)";my$lax=!defined $_ [1]{-lax}|| $_ [1]{-lax};my$l0=$lax ? "0?" : "0";my$pat="(?|" ."(?|1(?:2(?:15|2[05]|3[05]|40)|" ."3(?:00|35|40|5[05]|60)|" ."4(?:35|45|5[05]|6[056]|7[05]|8[015]|9[059])|" ."5(?:15|6[05]|70|85|9[05])|" ."6(?:3[05]|40|55|60|7[05]|8[05])|" ."7(?:0[01]|1[05]|30|5[05]|65|90)|" ."8(?:0[05]|11|25|35|51|60|7[15]|85|90))" ."|2(?:0(?:0[0-246-9]|1[0-25-9]|[2-4][0-9]|5[0279]|" ."6[0-9]|7[0-79]|8[0-9]|9[02-79])|" ."1(?:[0-2][0-9]|3[0-8]|4[0-8]|5[0-9]|6[0-8]|" ."7[0-9]|9[0-9])|" ."2(?:0[03-9]|1[0-46-9]|2[0-9]|3[0-4]|5[016-9]|" ."6[0-57]|78|8[0-79]|9[0-9])|" ."3(?:0[02-9]|1[0-24-9]|2[0-9]|3[03-9]|4[0-8]|" ."5[0-9]|6[0159]|7[0-29]|8[0-26-8]|9[05-9])|" ."4(?:0[0-689]|1[015]|2[0-9]|3[019]|4[013-9]|" ."5[02-6]|6[02-69]|[78][0-9]|90)|" ."5(?:0[02568]|1[5-9]|2[025-9]|3[03-9]|4[015689]|" ."5[015-9]|6[03-9]|7[0-9]|8[0-8]|9[04])|" ."6(?:0[0-9]|1[0-24-9]|2[0-9]|3[0-3]|4[0-9]|" ."5[0-35689]|6[0135689]|7[1258]|8[01])|" ."7(?:0[0-35-8]|1[0-7]|2[0-25-79]|3[0-9]|4[57-9]|" ."5[0-46-9]|6[0-35-9]|7[03-9]|8[02-7]|9[0-57-9])|" ."8(?:0[03-9]|1[078]|2[0-9]|3[0-689]|4[02-9]|5[02]|" ."6[4-9]|7[013-9]|80|9[089])|" ."9(?:0[0-6]|1[1-4]))" ."|3(?:0(?:0[0-468]|1[0-35689]|2[0-9]|3[0-46-9]|[45][0-9]|" ."6[0-8]|7[0-689]|8[1-57-9]|9[013-79])|" ."1(?:0[1-9]|1[13-6]|2[1-9]|[34][0-9]|5[0-689]|" ."[6-9][0-9])|" ."2(?:0[0-24-7]|1[1-9]|2[0-8]|3[0-9]|4[0-39]|5[014]|" ."6[04-9]|7[0-9]|8[0-79]|9[2-4])|" ."3(?:0[0-59]|1[0-2457-9]|2[1-589]|3[0-578]|4[0-25]|" ."5[0-7]|6[0134]|7[013-57-9]|8[014578]|9[0-356])|" ."4(?:0[0-279]|1[2-589]|2[0347-9]|3[0-578]|4[0-246-8]|" ."5[0138]|6[0-57-9]|7[2578]|8[02357-9]|9[01468])|" ."5(?:0[0-25-79]|1[25-8]|2[0-3579]|3[0137]|4[02469]|" ."5[0-24-9]|6[1-8]|7[0-3569]|8[013-689]|9[014-79])|" ."6(?:0[78]|1[0246-9]|2[0-49]|3[0-9]|4[0134679]|" ."5[89]|6[0-69]|7[0-35-8]|8[2357-9]|9[01457-9])|" ."7(?:0[01457-9]|1[1-57-9]|2[02-8]|3[0235-9]|4[014679]|" ."5[0-9]|6[0-7]|7[057-9]|8[1-35-9]|9[1-35-79])|" ."8(?:0[02-9]|1[02-68]|2[0-5]|3[1-35]|4[0-247]|" ."5[0-46-9]|6[02459]|7[013-58]|8[025-9]|9[0-3568])|" ."9(?:0[02-49]|1[0-35689]|2[0-35-9]|3[01346-9]|4[0-6]|" ."5[01346-9]|6[024-7]|7[15-9]|8[01478]|9[0-256]))" ."|4(?:0(?:0[0-9]|1[0-47-9]|2[0-259]|3[0-24-7]|5[13-59]|" ."6[014-9]|7[02-8])|" ."1(?:0[1-9]|1[0-9]|2[0-57-9]|3[0-3]|5[1-9]|6[013-59]|" ."7[0-489]|8[34])|" ."2(?:0[57-9]|[12][0-9]|30|7[0-25]|8[057])|" ."3(?:0[013-79]|1[0-3]|4[0-7]|5[02-9]|6[0-5]|7[0-8]|" ."8[0-578]|90)|" ."4(?:0[0-8]|1[0-35-9]|2[0-8]|5[45]|6[12578]|" ."7[0-2457-9]|8[0-26-9]|9[0-46-8])|" ."5(?:0[0-9]|1[0-24-9]|2[01]|[56][0-9]|7[0-5]|8[01])|" ."6(?:0[01568]|1[0-5]|2[015-7]|30|5[059]|6[02]|" ."7[01346-8]|80|9[4579])|" ."7(?:0[0-79]|1[0-9]|2[0-8]|3[0-35-9]|4[0-6]|5[013467]|" ."9[89])|" ."8(?:0[02-9]|1[0-9]|2[0-589]|30|49|5[024-9]|" ."6[01589]|7[0-9]|8[0-8]|9[0-25]))" ."|5(?:0(?:0[016-9]|1[0-9]|2[0-5]|3[1-57-9]|4[0-9]|5[0-2]|" ."6[1-9]|7[0-6]|8[1-9]|9[0-8])|" ."1(?:0[6-9]|1[0-8]|2[015-7]|3[1-46-9]|4[0-24]|" ."[56][0-9]|7[0-4])|" ."2(?:0[1-4]|1[0-4]|2[0-3]|3[1-8]|4[0-5]|5[0-69]|" ."6[0-9]|7[0-35-9]|80|9[01])|" ."3(?:0[1-46-9]|1[01]|2[0-2]|3[0-3]|4[0-6]|5[0-7]|" ."60|7[1-4]|81)|" ."4(?:0[01]|1[0-9]|2[0-2]|3[1-4]|40|5[1-5]|6[0-24]|" ."7[0-3]|8[0-35]|9[0135])|" ."5(?:0[12]|10|2[0-3]|40|5[024-68]|60|7[0-35-7]|" ."8[0-3])|" ."6(?:0[0-9]|3[0-3]|4[0-2]|5[0-5]|6[01]|7[01]|80|90)|" ."7(?:0[01]|1[09]|2[02-5]|3[0-4])|" ."9(?:42|50))" ."|6(?:0(?:0[013-9]|1[0-24-9]|2[0-9]|3[0-8]|4[1-4]|" ."[56][0-9]|7[0-46-9]|8[1-4]|90)|" ."1(?:0[0-9]|1[0-2]|2[1-6]|4[7-9]|[56][0-9]|" ."7[0-6]|8[0-2])|" ."2(?:0[7-9]|1[013-58]|2[013-9]|3[0-36769]|4[034]|" ."5[1-68]|6[02]|7[15]|8[0-24-68]|90)|" ."3(?:0[24689]|1[1-35-8]|2[0-46-8]|3[0-35-8]|4[1368]|" ."5[0-35-9]|6[1357-9]|7[0235]|8[3-6]|9[0-8])|" ."4(?:0[13579]|1[0-589]|2[0-9]|3[0-46-8]|4[0235-8]|" ."5[02]|6[0-35-8]|7[0235-79]|8[0457-9]|90)|" ."5(?:0[1-79]|1[0-9]|2[1258]|3[0-25-7]|5[68]|" ."6[0246-9]|7[1245])|" ."6(?:0[35689]|1[2-46]|2[03578]|3[0-2589]|4[026])|" ."7(?:0[157]|1[0-468]|2[0-2568]|3[13]|4[03]|5[1348]|" ."6[025]|70|9[89])|" ."8(?:3[17-9]|4[0-9]|50|65|72|92)|" ."9(?:0[1-79]|1[0-9]|2[0-69]|3[1-69]|4[1-7]|5[1-9]|" ."6[013-9]|7[09]|8[1-9]|9[0-27]))" ."|7(?:0(?:0[0-24-9]|1[0-25-9]|2[0-7]|30|5[0-5])|" ."1(?:09|1[23679]|20|39|40|5[015]|6[23]|7[0-9]|" ."8[02-7]|90)|" ."2(?:09|1[0-6]|4[89]|5[02-9]|6[0-578]|7[05-7]|9[0-2])|" ."3(?:0[0-7]|1[056]|2[0-25]|3[01])|" ."4(?:6[6-9]|70))" ."|8(?:0(?:0[1-9]|1[0-2]))" ."|9726" ."|$l0(?:200|8(?:0[014]|1[0-5]|2[0-289]|3[0-24-9]|4[05-7]|" ."5[0-4]|6[0-2]|7[0-5]|8[0156])|909)" ."))";"(?k:$pfx$pt(?k:$pat))"};1;
REGEXP_COMMON_ZIP

$fatpacked{"Role/Tiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ROLE_TINY';
  package Role::Tiny;use strict;use warnings;our$VERSION='2.001004';$VERSION =~ tr/_//d;our%INFO;our%APPLIED_TO;our%COMPOSED;our%COMPOSITE_INFO;our@ON_ROLE_CREATE;BEGIN {*_WORK_AROUND_BROKEN_MODULE_STATE="$]" < 5.009 ? sub(){1}: sub(){0};*_WORK_AROUND_HINT_LEAKAGE ="$]" < 5.011 &&!("$]" >= 5.009004 && "$]" < 5.010001)? sub(){1}: sub(){0};*_MRO_MODULE="$]" < 5.010 ? sub(){"MRO/Compat.pm"}: sub(){"mro.pm"};*_CONSTANTS_DEFLATE="$]" >= 5.012 && "$]" < 5.020 ? sub(){1}: sub(){0}}sub _getglob {no strict 'refs';\*{$_[0]}}sub _getstash {no strict 'refs';\%{"$_[0]::"}}sub croak {require Carp;no warnings 'redefine';*croak=\&Carp::croak;goto&Carp::croak}sub Role::Tiny::__GUARD__::DESTROY {delete$INC{$_[0]->[0]}if @{$_[0]}}sub _load_module {my ($module)=@_;(my$file="$module.pm")=~ s{::}{/}g;return 1 if$INC{$file};return 1 if grep!/::\z/,keys %{_getstash($module)};my$guard=_WORK_AROUND_BROKEN_MODULE_STATE && bless([$file ],'Role::Tiny::__GUARD__');local %^H if _WORK_AROUND_HINT_LEAKAGE;require$file;pop @$guard if _WORK_AROUND_BROKEN_MODULE_STATE;return 1}sub _all_subs {my ($me,$package)=@_;my$stash=_getstash($package);return {map {;no strict 'refs';${"${package}::${_}"}=${"${package}::${_}"}if _CONSTANTS_DEFLATE;$_=>\&{"${package}::${_}"}}grep exists &{"${package}::${_}"},grep!/::\z/,keys %$stash }}sub import {my$target=caller;my$me=shift;strict->import;warnings->import;my$non_methods=$me->_non_methods($target);$me->_install_subs($target,@_);$me->make_role($target);$me->_mark_new_non_methods($target,$non_methods)if$non_methods && %$non_methods;return}sub _mark_new_non_methods {my ($me,$target,$old_non_methods)=@_;my$non_methods=$INFO{$target}{non_methods};my$subs=$me->_all_subs($target);for my$sub (keys %$subs){if (exists$old_non_methods->{$sub}&& $non_methods->{$sub}!=$subs->{$sub}){$non_methods->{$sub}=$subs->{$sub}}}return}sub make_role {my ($me,$target)=@_;return if$me->is_role($target);$INFO{$target}{is_role}=1;my$non_methods=$me->_all_subs($target);delete @{$non_methods}{grep /\A\(/,keys %$non_methods};$INFO{$target}{non_methods}=$non_methods;$APPLIED_TO{$target}={$target=>undef };for my$hook (@ON_ROLE_CREATE){$hook->($target)}}sub _install_subs {my ($me,$target)=@_;return if$me->is_role($target);my%install=$me->_gen_subs($target);*{_getglob("${target}::${_}")}=$install{$_}for sort keys%install;return}sub _gen_subs {my ($me,$target)=@_;((map {;my$type=$_;$type=>sub {push @{$INFO{$target}{modifiers}||=[]},[$type=>@_ ];return}}qw(before after around)),requires=>sub {push @{$INFO{$target}{requires}||=[]},@_;return},with=>sub {$me->apply_roles_to_package($target,@_);return},)}sub role_application_steps {qw(_install_methods _check_requires _install_modifiers _copy_applied_list)}sub apply_single_role_to_package {my ($me,$to,$role)=@_;_load_module($role);croak "This is apply_role_to_package" if ref($to);croak "${role} is not a Role::Tiny" unless$me->is_role($role);for my$step ($me->role_application_steps){$me->$step($to,$role)}}sub _copy_applied_list {my ($me,$to,$role)=@_;@{$APPLIED_TO{$to}||={}}{keys %{$APPLIED_TO{$role}}}=()}sub apply_roles_to_object {my ($me,$object,@roles)=@_;croak "No roles supplied!" unless@roles;my$class=ref($object);bless($_[1],$me->create_class_with_roles($class,@roles))}my$role_suffix='A000';sub _composite_name {my ($me,$superclass,@roles)=@_;my$new_name=join('__WITH__',$superclass,my$compose_name=join '__AND__',@roles);if (length($new_name)> 252){$new_name=$COMPOSED{abbrev}{$new_name}||= do {my$abbrev=substr$new_name,0,250 - length$role_suffix;$abbrev =~ s/(?<!:):$//;$abbrev.'__'.$role_suffix++}}return wantarray ? ($new_name,$compose_name): $new_name}sub create_class_with_roles {my ($me,$superclass,@roles)=@_;croak "No roles supplied!" unless@roles;_load_module($superclass);{my%seen;if (my@dupes=grep 1==$seen{$_}++,@roles){croak "Duplicated roles: ".join(', ',@dupes)}}my ($new_name,$compose_name)=$me->_composite_name($superclass,@roles);return$new_name if$COMPOSED{class}{$new_name};for my$role (@roles){_load_module($role);croak "${role} is not a Role::Tiny" unless$me->is_role($role)}require(_MRO_MODULE);my$composite_info=$me->_composite_info_for(@roles);my%conflicts=%{$composite_info->{conflicts}};if (keys%conflicts){my$fail=join "\n",map {"Method name conflict for '$_' between roles " ."'".join("' and '",sort values %{$conflicts{$_}})."'" .", cannot apply these simultaneously to an object."}keys%conflicts;croak$fail}my@composable=map$me->_composable_package_for($_),reverse@roles;my@requires=grep {my$method=$_;!grep $_->can($method)&&!$COMPOSED{role}{$_}{modifiers_only}{$method},@composable}@{$composite_info->{requires}};$me->_check_requires($superclass,$compose_name,\@requires);*{_getglob("${new_name}::ISA")}=[@composable,$superclass ];@{$APPLIED_TO{$new_name}||={}}{map keys %{$APPLIED_TO{$_}},@roles }=();$COMPOSED{class}{$new_name}=1;return$new_name}sub apply_role_to_package {shift->apply_single_role_to_package(@_)}sub apply_roles_to_package {my ($me,$to,@roles)=@_;return$me->apply_role_to_package($to,$roles[0])if@roles==1;my%conflicts=%{$me->_composite_info_for(@roles)->{conflicts}};my@have=grep$to->can($_),keys%conflicts;delete@conflicts{@have};if (keys%conflicts){my$fail=join "\n",map {"Due to a method name conflict between roles " ."'".join(' and ',sort values %{$conflicts{$_}})."'" .", the method '$_' must be implemented by '${to}'"}keys%conflicts;croak$fail}my@role_methods=map$me->_concrete_methods_of($_),@roles;local @{$_}{@have}for@role_methods;delete @{$_}{@have}for@role_methods;if ($INFO{$to}){delete$INFO{$to}{methods}}our%BACKCOMPAT_HACK;if($me ne __PACKAGE__ and exists$BACKCOMPAT_HACK{$me}? $BACKCOMPAT_HACK{$me}: $BACKCOMPAT_HACK{$me}=$me->can('role_application_steps')==\&role_application_steps && $me->can('apply_single_role_to_package')!=\&apply_single_role_to_package){for my$role (@roles){$me->apply_single_role_to_package($to,$role)}}else {for my$step ($me->role_application_steps){for my$role (@roles){$me->$step($to,$role)}}}$APPLIED_TO{$to}{join('|',@roles)}=1}sub _composite_info_for {my ($me,@roles)=@_;$COMPOSITE_INFO{join('|',sort@roles)}||= do {for my$role (@roles){_load_module($role)}my%methods;for my$role (@roles){my$this_methods=$me->_concrete_methods_of($role);$methods{$_}{$this_methods->{$_}}=$role for keys %$this_methods}my%requires;@requires{map @{$INFO{$_}{requires}||[]},@roles}=();delete$requires{$_}for keys%methods;delete$methods{$_}for grep keys(%{$methods{$_}})==1,keys%methods;+{conflicts=>\%methods,requires=>[keys%requires]}}}sub _composable_package_name_for {my ($me,$role)=@_;'Role::Tiny::_COMPOSABLE::'.$role}sub _composable_package_for {my ($me,$role)=@_;my$composed_name=$me->_composable_package_name_for($role);return$composed_name if$COMPOSED{role}{$composed_name};$me->_install_methods($composed_name,$role);my$base_name=$composed_name.'::_BASE';_getstash($base_name);{no strict 'refs';@{"${composed_name}::ISA"}=($base_name)}my$modifiers=$INFO{$role}{modifiers}||[];my@mod_base;my@modifiers=grep!$composed_name->can($_),do {my%h;@h{map @{$_}[1..$#$_-1],@$modifiers}=();keys%h};for my$modified (@modifiers){push@mod_base,"sub ${modified} { shift->next::method(\@_) }"}my$e;{local $@;eval(my$code=join "\n","package ${base_name};",@mod_base);$e="Evaling failed: $@\nTrying to eval:\n${code}" if $@}die$e if$e;$me->_install_modifiers($composed_name,$role);$COMPOSED{role}{$composed_name}={modifiers_only=>{map {$_=>1}@modifiers },};return$composed_name}sub _check_requires {my ($me,$to,$name,$requires)=@_;return unless my@requires=@{$requires||$INFO{$name}{requires}||[]};if (my@requires_fail=grep!$to->can($_),@requires){if (my$to_info=$INFO{$to}){push @{$to_info->{requires}||=[]},@requires_fail}else {croak "Can't apply ${name} to ${to} - missing ".join(', ',@requires_fail)}}}sub _non_methods {my ($me,$role)=@_;my$info=$INFO{$role}or return {};my%non_methods=%{$info->{non_methods}|| {}};my%not_methods=reverse %{$info->{not_methods}|| {}};return \%non_methods unless keys%not_methods;my$subs=$me->_all_subs($role);for my$sub (grep!/\A\(/,keys %$subs){my$code=$subs->{$sub};if (exists$not_methods{$code}){$non_methods{$sub}=$code}}return \%non_methods}sub _concrete_methods_of {my ($me,$role)=@_;my$info=$INFO{$role};return$info->{methods}if$info && $info->{methods};my$non_methods=$me->_non_methods($role);my$subs=$me->_all_subs($role);for my$sub (keys %$subs){if (exists$non_methods->{$sub}&& $non_methods->{$sub}==$subs->{$sub}){delete$subs->{$sub}}}if ($info){$info->{methods}=$subs}return$subs}sub methods_provided_by {my ($me,$role)=@_;croak "${role} is not a Role::Tiny" unless$me->is_role($role);sort (keys %{$me->_concrete_methods_of($role)},@{$INFO{$role}->{requires}||[]})}sub _install_methods {my ($me,$to,$role)=@_;my$methods=$me->_concrete_methods_of($role);my%existing_methods;@existing_methods{keys %{$me->_all_subs($to)}}=();my$applied_to=$APPLIED_TO{$to};if ($applied_to && %$applied_to){require(_MRO_MODULE);my%isa=map +($_=>1),@{mro::get_linear_isa($to)};my@composed=grep $_ ne $role && $isa{$me->_composable_package_name_for($_)},keys %{$APPLIED_TO{$to}};for my$package (@composed){@existing_methods{keys %{$me->_concrete_methods_of($package)}}=()}}delete$INFO{$to}{methods}if$INFO{$to};for my$i (keys %$methods){next if exists$existing_methods{$i};my$glob=_getglob "${to}::${i}";*$glob=$methods->{$i};next unless$i =~ /^\(/ && ((defined&overload::nil && $methods->{$i}==\&overload::nil)|| (defined&overload::_nil && $methods->{$i}==\&overload::_nil));my$overload=${_getglob "${role}::${i}"};next unless defined$overload;*$glob=\$overload}$me->_install_does($to)}sub _install_modifiers {my ($me,$to,$name)=@_;return unless my$modifiers=$INFO{$name}{modifiers};my$info=$INFO{$to};my$existing=($info ? $info->{modifiers}: $COMPOSED{modifiers}{$to})||= [];my@modifiers=grep {my$modifier=$_;!grep $_==$modifier,@$existing}@{$modifiers||[]};push @$existing,@modifiers;if (!$info){for my$modifier (@modifiers){$me->_install_single_modifier($to,@$modifier)}}}my$vcheck_error;sub _install_single_modifier {my ($me,@args)=@_;defined($vcheck_error)or $vcheck_error=do {local $@;eval {require Class::Method::Modifiers;Class::Method::Modifiers->VERSION(1.05);1}? 0 : $@};$vcheck_error and die$vcheck_error;Class::Method::Modifiers::install_modifier(@args)}my$FALLBACK=sub {0};sub _install_does {my ($me,$to)=@_;return if$me->is_role($to);my$does=$me->can('does_role');*{_getglob "${to}::does"}=$does unless$to->can('does');return if$to->can('DOES')and $to->can('DOES')!=(UNIVERSAL->can('DOES')|| 0);my$existing=$to->can('DOES')|| $to->can('isa')|| $FALLBACK;my$new_sub=sub {my ($proto,$role)=@_;$proto->$does($role)or $proto->$existing($role)};no warnings 'redefine';return *{_getglob "${to}::DOES"}=$new_sub}sub does_role {my ($proto,$role)=@_;require(_MRO_MODULE);for my$class (@{mro::get_linear_isa(ref($proto)||$proto)}){return 1 if exists$APPLIED_TO{$class}{$role}}return 0}sub is_role {my ($me,$role)=@_;return!!($INFO{$role}&& ($INFO{$role}{is_role}|| $INFO{$role}{not_methods}|| $INFO{$role}{non_methods}))}1;
ROLE_TINY

$fatpacked{"Role/Tiny/With.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ROLE_TINY_WITH';
  package Role::Tiny::With;use strict;use warnings;our$VERSION='2.001004';$VERSION =~ tr/_//d;use Role::Tiny ();use Exporter 'import';our@EXPORT=qw(with);sub with {my$target=caller;Role::Tiny->apply_roles_to_package($target,@_)}1;
ROLE_TINY_WITH

$fatpacked{"Sub/Defer.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'SUB_DEFER';
  package Sub::Defer;use strict;use warnings;use Exporter qw(import);use Scalar::Util qw(weaken);use Carp qw(croak);our$VERSION='2.006006';$VERSION=eval$VERSION;our@EXPORT=qw(defer_sub undefer_sub undefer_all);our@EXPORT_OK=qw(undefer_package defer_info);sub _getglob {no strict 'refs';\*{$_[0]}}BEGIN {my$no_subname;*_subname =defined&Sub::Util::set_subname ? \&Sub::Util::set_subname : defined&Sub::Name::subname ? \&Sub::Name::subname : (eval {require Sub::Util}&& defined&Sub::Util::set_subname)? \&Sub::Util::set_subname : (eval {require Sub::Name}&& defined&Sub::Name::subname)? \&Sub::Name::subname : ($no_subname=1,sub {$_[1]});*_CAN_SUBNAME=$no_subname ? sub(){0}: sub(){1}}sub _name_coderef {shift if @_ > 2;_CAN_SUBNAME ? _subname(@_): $_[1]}sub _install_coderef {my ($glob,$code)=(_getglob($_[0]),_name_coderef(@_));no warnings 'redefine';if (*{$glob}{CODE}){*{$glob}=$code}else {no warnings 'prototype';*{$glob}=$code}}our%DEFERRED;sub undefer_sub {my ($deferred)=@_;my$info=$DEFERRED{$deferred}or return$deferred;my ($target,$maker,$options,$undeferred_ref,$deferred_sub)=@$info;if (!($deferred_sub && $deferred eq $deferred_sub || ${$undeferred_ref}&& $deferred eq ${$undeferred_ref})){return$deferred}return ${$undeferred_ref}if ${$undeferred_ref};${$undeferred_ref}=my$made=$maker->();if (defined($target)&& $deferred eq *{_getglob($target)}{CODE}||''){no warnings 'redefine';*{_getglob($target)}=$made}my$undefer_info=[$target,$maker,$options,$undeferred_ref ];$info->[5]=$DEFERRED{$made}=$undefer_info;weaken ${$undefer_info->[3]};return$made}sub undefer_all {undefer_sub($_)for keys%DEFERRED;return}sub undefer_package {my$package=shift;undefer_sub($_)for grep {my$name=$DEFERRED{$_}&& $DEFERRED{$_}[0];$name && $name =~ /^${package}::[^:]+$/}keys%DEFERRED;return}sub defer_info {my ($deferred)=@_;my$info=$DEFERRED{$deferred||''}or return undef;my ($target,$maker,$options,$undeferred_ref,$deferred_sub)=@$info;if (!($deferred_sub && $deferred eq $deferred_sub || ${$undeferred_ref}&& $deferred eq ${$undeferred_ref})){delete$DEFERRED{$deferred};return undef}[$target,$maker,$options,($undeferred_ref && $$undeferred_ref ? $$undeferred_ref : ()),]}sub defer_sub {my ($target,$maker,$options)=@_;my$package;my$subname;($package,$subname)=$target =~ /^(.*)::([^:]+)$/ or croak "$target is not a fully qualified sub name!" if$target;$package ||= $options && $options->{package}|| caller;my@attributes=@{$options && $options->{attributes}|| []};if (@attributes){/\A\w+(?:\(.*\))?\z/s || croak "invalid attribute $_" for@attributes}my$deferred;my$undeferred;my$deferred_info=[$target,$maker,$options,\$undeferred ];if (@attributes || $target &&!_CAN_SUBNAME){my$code =q[#line ].(__LINE__+2).q[ "].__FILE__.qq["\n] .qq[package $package;\n] .($target ? "sub $subname" : '+sub').join('',map " :$_",@attributes).q[ {
          package Sub::Defer;
          # uncoverable subroutine
          # uncoverable statement
          $undeferred ||= undefer_sub($deferred_info->[4]);
          goto &$undeferred; # uncoverable statement
          $undeferred; # fake lvalue return
        }]."\n" .($target ? "\\&$subname" : '');my$e;$deferred=do {no warnings qw(redefine closure);local $@;eval$code or $e=$@};die$e if defined$e}else {$deferred=sub {$undeferred ||= undefer_sub($deferred_info->[4]);goto &$undeferred};_install_coderef($target,$deferred)if$target}weaken($deferred_info->[4]=$deferred);weaken($DEFERRED{$deferred}=$deferred_info);return$deferred}sub CLONE {%DEFERRED=map {defined $_ ? ($_->[4]? ($_->[4]=>$_): ($_->[3]&& ${$_->[3]})? (${$_->[3]}=>$_): ()): ()}values%DEFERRED}1;
SUB_DEFER

$fatpacked{"Sub/Exporter.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'SUB_EXPORTER';
  use 5.006;use strict;use warnings;package Sub::Exporter;{$Sub::Exporter::VERSION='0.987'}use Carp ();use Data::OptList 0.100 ();use Params::Util 0.14 ();use Sub::Install 0.92 ();sub _group_name {my ($name)=@_;return if (index q{-:},(substr$name,0,1))==-1;return substr$name,1}sub _expand_groups {my ($class,$config,$groups,$collection,$seen,$merge)=@_;$seen ||= {};$merge ||= {};my@groups=@$groups;for my$i (reverse 0 .. $#groups){if (my$group_name=_group_name($groups[$i][0])){my$seen={%$seen };splice@groups,$i,1,_expand_group($class,$config,$groups[$i],$collection,$seen,$merge)}else {next unless my%merge=%$merge;my$prefix=(delete$merge{-prefix})|| '';my$suffix=(delete$merge{-suffix})|| '';if (Params::Util::_CODELIKE($groups[$i][1])or Params::Util::_SCALAR0($groups[$i][1])){$groups[$i][0]=$prefix .$groups[$i][0].$suffix}else {my$as =ref$groups[$i][1]{-as}? $groups[$i][1]{-as}: $groups[$i][1]{-as}? $prefix .$groups[$i][1]{-as}.$suffix : $prefix .$groups[$i][0].$suffix;$groups[$i][1]={%{$groups[$i][1]},%merge,-as=>$as }}}}return \@groups}sub _expand_group {my ($class,$config,$group,$collection,$seen,$merge)=@_;$merge ||= {};my ($group_name,$group_arg)=@$group;$group_name=_group_name($group_name);Carp::croak qq(group "$group_name" is not exported by the $class module) unless exists$config->{groups}{$group_name};return if$seen->{$group_name}++;if (ref$group_arg){my$prefix=(delete$merge->{-prefix}||'').($group_arg->{-prefix}||'');my$suffix=($group_arg->{-suffix}||'').(delete$merge->{-suffix}||'');$merge={%$merge,%$group_arg,($prefix ? (-prefix=>$prefix): ()),($suffix ? (-suffix=>$suffix): ()),}}my$exports=$config->{groups}{$group_name};if (Params::Util::_CODELIKE($exports)or Params::Util::_SCALAR0($exports)){my$group_arg=$merge ? {%$merge }: {};delete$group_arg->{-prefix};delete$group_arg->{-suffix};my$group=Params::Util::_CODELIKE($exports)? $exports->($class,$group_name,$group_arg,$collection): $class->$$exports($group_name,$group_arg,$collection);Carp::croak qq(group generator "$group_name" did not return a hashref) if ref$group ne 'HASH';my$stuff=[map {[$_=>$group->{$_}]}keys %$group ];return @{_expand_groups($class,$config,$stuff,$collection,$seen,$merge)}}else {$exports =Data::OptList::mkopt($exports,"$group_name exports");return @{_expand_groups($class,$config,$exports,$collection,$seen,$merge)}}}sub _mk_collection_builder {my ($col,$etc)=@_;my ($config,$import_args,$class,$into)=@$etc;my%seen;sub {my ($collection)=@_;my ($name,$value)=@$collection;Carp::croak "collection $name provided multiple times in import" if$seen{$name }++;if (ref(my$hook=$config->{collectors}{$name})){my$arg={name=>$name,config=>$config,import_args=>$import_args,class=>$class,into=>$into,};my$error_msg="collection $name failed validation";if (Params::Util::_SCALAR0($hook)){Carp::croak$error_msg unless$class->$$hook($value,$arg)}else {Carp::croak$error_msg unless$hook->($value,$arg)}}$col->{$name }=$value}}sub _collect_collections {my ($config,$import_args,$class,$into)=@_;my@collections =map {splice @$import_args,$_,1}grep {exists$config->{collectors}{$import_args->[$_][0]}}reverse 0 .. $#$import_args;unshift@collections,[INIT=>{}]if$config->{collectors}{INIT};my$col={};my$builder=_mk_collection_builder($col,\@_);for my$collection (@collections){$builder->($collection)}return$col}sub setup_exporter {my ($config)=@_;Carp::croak 'into and into_level may not both be supplied to exporter' if exists$config->{into}and exists$config->{into_level};my$as=delete$config->{as}|| 'import';my$into =exists$config->{into}? delete$config->{into}: exists$config->{into_level}? caller(delete$config->{into_level}): caller(0);my$import=build_exporter($config);Sub::Install::reinstall_sub({code=>$import,into=>$into,as=>$as,})}sub _key_intersection {my ($x,$y)=@_;my%seen=map {$_=>1}keys %$x;my@names=grep {$seen{$_}}keys %$y}my%valid_config_key;BEGIN {%valid_config_key=map {$_=>1}qw(as collectors installer generator exports groups into into_level),qw(exporter),}sub _assert_collector_names_ok {my ($collectors)=@_;for my$reserved_name (grep {/\A[_A-Z]+\z/}keys %$collectors){Carp::croak "unknown reserved collector name: $reserved_name" if$reserved_name ne 'INIT'}}sub _rewrite_build_config {my ($config)=@_;if (my@keys=grep {not exists$valid_config_key{$_}}keys %$config){Carp::croak "unknown options (@keys) passed to Sub::Exporter"}Carp::croak q(into and into_level may not both be supplied to exporter) if exists$config->{into}and exists$config->{into_level};if ($config->{exporter}){Carp::cluck "'exporter' argument to build_exporter is deprecated. Use 'installer' instead; the semantics are identical.";$config->{installer}=delete$config->{exporter}}Carp::croak q(into and into_level may not both be supplied to exporter) if exists$config->{into}and exists$config->{into_level};for (qw(exports collectors)){$config->{$_}=Data::OptList::mkopt_hash($config->{$_},$_,['CODE','SCALAR' ],)}_assert_collector_names_ok($config->{collectors});if (my@names=_key_intersection(@$config{qw(exports collectors)})){Carp::croak "names (@names) used in both collections and exports"}$config->{groups}=Data::OptList::mkopt_hash($config->{groups},'groups',['HASH','ARRAY','CODE','SCALAR',]);$config->{groups}{default}||= [];$config->{groups}{all}||= [keys %{$config->{exports}}];$config->{generator}||= \&default_generator;$config->{installer}||= \&default_installer}sub build_exporter {my ($config)=@_;_rewrite_build_config($config);my$import=sub {my ($class)=shift;my$special=(ref $_[0])? shift(@_): {};Carp::croak q(into and into_level may not both be supplied to exporter) if exists$special->{into}and exists$special->{into_level};if ($special->{exporter}){Carp::cluck "'exporter' special import argument is deprecated. Use 'installer' instead; the semantics are identical.";$special->{installer}=delete$special->{exporter}}my$into =defined$special->{into}? delete$special->{into}: defined$special->{into_level}? caller(delete$special->{into_level}): defined$config->{into}? $config->{into}: defined$config->{into_level}? caller($config->{into_level}): caller(0);my$generator=delete$special->{generator}|| $config->{generator};my$installer=delete$special->{installer}|| $config->{installer};my$import_args=Data::OptList::mkopt([@_ ]);$import_args=[[-default=>undef ]]unless @$import_args;my$collection=_collect_collections($config,$import_args,$class,$into);my$to_import=_expand_groups($class,$config,$import_args,$collection);_do_import({class=>$class,col=>$collection,config=>$config,into=>$into,generator=>$generator,installer=>$installer,},$to_import,)};return$import}sub _do_import {my ($arg,$to_import)=@_;my@todo;for my$pair (@$to_import){my ($name,$import_arg)=@$pair;my ($generator,$as);if ($import_arg and Params::Util::_CODELIKE($import_arg)){$generator=sub {$import_arg};$as=$name}else {$import_arg={$import_arg ? %$import_arg : ()};Carp::croak qq("$name" is not exported by the $arg->{class} module) unless exists$arg->{config}{exports}{$name};$generator=$arg->{config}{exports}{$name};$as=exists$import_arg->{-as}? (delete$import_arg->{-as}): $name}my$code=$arg->{generator}->({class=>$arg->{class},name=>$name,arg=>$import_arg,col=>$arg->{col},generator=>$generator,});push@todo,$as,$code}$arg->{installer}->({class=>$arg->{class},into=>$arg->{into},col=>$arg->{col},},\@todo,)}sub default_generator {my ($arg)=@_;my ($class,$name,$generator)=@$arg{qw(class name generator)};if (not defined$generator){my$code=$class->can($name)or Carp::croak "can't locate exported subroutine $name via $class";return$code}return$generator->($class,$name,$arg->{arg},$arg->{col})if Params::Util::_CODELIKE($generator);return$class->$$generator($name,$arg->{arg},$arg->{col})}sub default_installer {my ($arg,$to_export)=@_;for (my$i=0;$i < @$to_export;$i += 2){my ($as,$code)=@$to_export[$i,$i+1 ];if (ref$as eq 'SCALAR'){$$as=$code}elsif (ref$as){Carp::croak "invalid reference type for $as: " .ref$as}else {Sub::Install::reinstall_sub({code=>$code,into=>$arg->{into},as=>$as })}}}sub default_exporter {Carp::cluck "default_exporter is deprecated; call default_installer instead; the semantics are identical";goto&default_installer}setup_exporter({exports=>[qw(setup_exporter build_exporter),_import=>sub {build_exporter($_[2])},],groups=>{all=>[qw(setup_exporter build_export) ],},collectors=>{-setup=>\&_setup },});sub _setup {my ($value,$arg)=@_;if (ref$value eq 'HASH'){push @{$arg->{import_args}},[_import=>{-as=>'import',%$value }];return 1}elsif (ref$value eq 'ARRAY'){push @{$arg->{import_args}},[_import=>{-as=>'import',exports=>$value }];return 1}return}"jn8:32";
SUB_EXPORTER

$fatpacked{"Sub/Exporter/Progressive.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'SUB_EXPORTER_PROGRESSIVE';
  package Sub::Exporter::Progressive;$Sub::Exporter::Progressive::VERSION='0.001013';use strict;use warnings;sub _croak {require Carp;&Carp::croak}sub import {my ($self,@args)=@_;my$inner_target=caller;my$export_data=sub_export_options($inner_target,@args);my$full_exporter;no strict 'refs';no warnings 'once';@{"${inner_target}::EXPORT_OK"}=@{$export_data->{exports}};@{"${inner_target}::EXPORT"}=@{$export_data->{defaults}};%{"${inner_target}::EXPORT_TAGS"}=%{$export_data->{tags}};*{"${inner_target}::import"}=sub {use strict;my ($self,@args)=@_;if (grep {length ref $_ or $_ !~ / \A [:-]? \w+ \z /xm}@args){_croak 'your usage of Sub::Exporter::Progressive requires Sub::Exporter to be installed' unless eval {require Sub::Exporter};$full_exporter ||= Sub::Exporter::build_exporter($export_data->{original});goto$full_exporter}elsif (defined((my ($num)=grep {m/^\d/}@args)[0])){_croak "cannot export symbols with a leading digit: '$num'"}else {require Exporter;s/ \A - /:/xm for@args;@_=($self,@args);goto \&Exporter::import}};return}my$too_complicated=<<'DEATH';sub sub_export_options {my ($inner_target,$setup,$options)=@_;my@exports;my@defaults;my%tags;if (($setup||'')eq '-setup'){my%options=%$options;OPTIONS: for my$opt (keys%options){if ($opt eq 'exports'){_croak$too_complicated if ref$options{exports}ne 'ARRAY';@exports=@{$options{exports}};_croak$too_complicated if grep {length ref $_}@exports}elsif ($opt eq 'groups'){%tags=%{$options{groups}};for my$tagset (values%tags){_croak$too_complicated if grep {length ref $_ or $_ =~ / \A - (?! all \b ) /x}@{$tagset}}@defaults=@{$tags{default}|| []}}else {_croak$too_complicated}}@{$_}=map {/ \A  [:-] all \z /x ? @exports : $_}@{$_}for \@defaults,values%tags;$tags{all}||= [@exports ];my%exports=map {$_=>1}@exports;my@errors=grep {not $exports{$_}}@defaults;_croak join(', ',@errors)." is not exported by the $inner_target module\n" if@errors}return {exports=>\@exports,defaults=>\@defaults,original=>$options,tags=>\%tags,}}1;
  You are using Sub::Exporter::Progressive, but the features your program uses from
  Sub::Exporter cannot be implemented without Sub::Exporter, so you might as well
  just use vanilla Sub::Exporter
  DEATH
SUB_EXPORTER_PROGRESSIVE

$fatpacked{"Sub/Exporter/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'SUB_EXPORTER_UTIL';
  use strict;use warnings;package Sub::Exporter::Util;{$Sub::Exporter::Util::VERSION='0.987'}use Data::OptList ();use Params::Util ();sub curry_method {my$override_name=shift;sub {my ($class,$name)=@_;$name=$override_name if defined$override_name;sub {$class->$name(@_)}}}BEGIN {*curry_class=\&curry_method}sub curry_chain {my (@opt_list)=@_;my$pairs=Data::OptList::mkopt(\@opt_list,'args','ARRAY');sub {my ($class)=@_;sub {my$next=$class;for my$i (0 .. $#$pairs){my$pair=$pairs->[$i ];unless (Params::Util::_INVOCANT($next)){my$str=defined$next ? "'$next'" : 'undef';Carp::croak("can't call $pair->[0] on non-invocant $str")}my ($method,$args)=@$pair;if ($i==$#$pairs){return$next->$method($args ? @$args : ())}else {$next=$next->$method($args ? @$args : ())}}}}}sub merge_col {my (%groups)=@_;my%merged;while (my ($default_name,$group)=each%groups){while (my ($export_name,$gen)=each %$group){$merged{$export_name}=sub {my ($class,$name,$arg,$col)=@_;my$merged_arg=exists$col->{$default_name}? {%{$col->{$default_name}},%$arg }: $arg;if (Params::Util::_CODELIKE($gen)){$gen->($class,$name,$merged_arg,$col)}else {$class->$$gen($name,$merged_arg,$col)}}}}return%merged}sub __mixin_class_for {my ($class,$mix_into)=@_;require Package::Generator;my$mixin_class=Package::Generator->new_package({base=>"$class\:\:__mixin__",});no strict 'refs';if (ref$mix_into){unshift @{"$mixin_class" ."::ISA"},ref$mix_into}else {unshift @{"$mix_into" ."::ISA"},$mixin_class}return$mixin_class}sub mixin_installer {sub {my ($arg,$to_export)=@_;my$mixin_class=__mixin_class_for($arg->{class},$arg->{into});bless$arg->{into}=>$mixin_class if ref$arg->{into};Sub::Exporter::default_installer({%$arg,into=>$mixin_class },$to_export,)}}sub mixin_exporter {Carp::cluck "mixin_exporter is deprecated; use mixin_installer instead; it behaves identically";return mixin_installer}sub like {sub {my ($value,$arg)=@_;Carp::croak "no regex supplied to regex group generator" unless$value;my@values=eval {$value->isa('Regexp')}? ($value,undef): @$value;while (my ($re,$opt)=splice@values,0,2){Carp::croak "given pattern for regex group generater is not a Regexp" unless eval {$re->isa('Regexp')};my@exports=keys %{$arg->{config}->{exports}};my@matching=grep {$_ =~ $re}@exports;my%merge=$opt ? %$opt : ();my$prefix=(delete$merge{-prefix})|| '';my$suffix=(delete$merge{-suffix})|| '';for my$name (@matching){my$as=$prefix .$name .$suffix;push @{$arg->{import_args}},[$name=>{%merge,-as=>$as }]}}1}}use Sub::Exporter -setup=>{exports=>[qw(like name_map merge_col curry_method curry_class curry_chain mixin_installer mixin_exporter) ]};1;
SUB_EXPORTER_UTIL

$fatpacked{"Sub/Install.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'SUB_INSTALL';
  use strict;use warnings;package Sub::Install;$Sub::Install::VERSION='0.928';use Carp;use Scalar::Util ();sub _name_of_code {my ($code)=@_;require B;my$name=B::svref_2object($code)->GV->NAME;return$name unless$name =~ /\A__ANON__/;return}sub _CODELIKE {(Scalar::Util::reftype($_[0])||'')eq 'CODE' || Scalar::Util::blessed($_[0])&& (overload::Method($_[0],'&{}')? $_[0]: undef)}sub _build_public_installer {my ($installer)=@_;sub {my ($arg)=@_;my ($calling_pkg)=caller(0);for (qw(into from)){$arg->{$_}=$calling_pkg unless$arg->{$_}}Carp::croak "named argument 'code' is not optional" unless$arg->{code};if (_CODELIKE($arg->{code})){$arg->{as}||= _name_of_code($arg->{code})}else {Carp::croak "couldn't find subroutine named $arg->{code} in package $arg->{from}" unless my$code=$arg->{from}->can($arg->{code});$arg->{as}=$arg->{code}unless$arg->{as};$arg->{code}=$code}Carp::croak "couldn't determine name under which to install subroutine" unless$arg->{as};$installer->(@$arg{qw(into as code) })}}my$_misc_warn_re;my$_redef_warn_re;BEGIN {$_misc_warn_re=qr/
      Prototype\ mismatch:\ sub\ .+?  |
      Constant subroutine .+? redefined
    /x;$_redef_warn_re=qr/Subroutine\ .+?\ redefined/x}my$eow_re;BEGIN {$eow_re=qr/ at .+? line \d+\.\Z/};sub _do_with_warn {my ($arg)=@_;my$code=delete$arg->{code};my$wants_code=sub {my$code=shift;sub {my$warn=$SIG{__WARN__}? $SIG{__WARN__}: sub {warn @_};local$SIG{__WARN__}=sub {my ($error)=@_;for (@{$arg->{suppress}}){return if$error =~ $_}for (@{$arg->{croak}}){if (my ($base_error)=$error =~ /\A($_) $eow_re/x){Carp::croak$base_error}}for (@{$arg->{carp}}){if (my ($base_error)=$error =~ /\A($_) $eow_re/x){return$warn->(Carp::shortmess$base_error)}}($arg->{default}|| $warn)->($error)};$code->(@_)}};return$wants_code->($code)if$code;return$wants_code}sub _installer {sub {my ($pkg,$name,$code)=@_;no strict 'refs';*{"$pkg\::$name"}=$code;return$code}}BEGIN {*_ignore_warnings=_do_with_warn({carp=>[$_misc_warn_re,$_redef_warn_re ]});*install_sub=_build_public_installer(_ignore_warnings(_installer));*_carp_warnings=_do_with_warn({carp=>[$_misc_warn_re ],suppress=>[$_redef_warn_re ],});*reinstall_sub=_build_public_installer(_carp_warnings(_installer));*_install_fatal=_do_with_warn({code=>_installer,croak=>[$_redef_warn_re ],})}sub install_installers {my ($into)=@_;for my$method (qw(install_sub reinstall_sub)){my$code=sub {my ($package,$subs)=@_;my ($caller)=caller(0);my$return;for (my ($name,$sub)=%$subs){$return=Sub::Install->can($method)->({code=>$sub,from=>$caller,into=>$package,as=>$name })}return$return};install_sub({code=>$code,into=>$into,as=>$method })}}sub exporter {my ($arg)=@_;my%is_exported=map {$_=>undef}@{$arg->{exports}};sub {my$class=shift;my$target=caller;for (@_){Carp::croak "'$_' is not exported by $class" if!exists$is_exported{$_};install_sub({code=>$_,from=>$class,into=>$target })}}}BEGIN {*import=exporter({exports=>[qw(install_sub reinstall_sub) ]})}1;
SUB_INSTALL

$fatpacked{"Sub/Quote.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'SUB_QUOTE';
  package Sub::Quote;sub _clean_eval {eval $_[0]}use strict;use warnings;use Sub::Defer qw(defer_sub);use Scalar::Util qw(weaken);use Exporter qw(import);use Carp qw(croak);BEGIN {our@CARP_NOT=qw(Sub::Defer)}use B ();BEGIN {*_HAVE_IS_UTF8=defined&utf8::is_utf8 ? sub(){1}: sub(){0};*_HAVE_PERLSTRING=defined&B::perlstring ? sub(){1}: sub(){0};*_BAD_BACKSLASH_ESCAPE=_HAVE_PERLSTRING()&& "$]"==5.010_000 ? sub(){1}: sub(){0};*_HAVE_HEX_FLOAT=!$ENV{SUB_QUOTE_NO_HEX_FLOAT}&& "$]" >= 5.022 ? sub(){1}: sub(){0};my$nvsize=8 * length pack 'F',0;my$nvmantbits =$nvsize==16 ? 11 : $nvsize==32 ? 24 : $nvsize==64 ? 53 : $nvsize==80 ? 64 : $nvsize==128 ? 113 : $nvsize==256 ? 237 : 237 ;my$precision=int(log(2)/log(10)*$nvmantbits);*_NVSIZE=sub(){$nvsize};*_NVMANTBITS=sub(){$nvmantbits};*_FLOAT_PRECISION=sub(){$precision}}our$VERSION='2.006006';$VERSION =~ tr/_//d;our@EXPORT=qw(quote_sub unquote_sub quoted_from_sub qsub);our@EXPORT_OK=qw(quotify capture_unroll inlinify sanitize_identifier);our%QUOTED;my%escape;if (_BAD_BACKSLASH_ESCAPE){%escape=((map +(chr($_)=>sprintf '\x%02x',$_),0 .. 0x31,0x7f),"\t"=>"\\t","\n"=>"\\n","\r"=>"\\r","\f"=>"\\f","\b"=>"\\b","\a"=>"\\a","\e"=>"\\e",(map +($_=>"\\$_"),qw(" \ $ @)),)}sub quotify {my$value=$_[0];no warnings 'numeric';!defined$value ? 'undef()' : (!(_HAVE_IS_UTF8 && utf8::is_utf8($value))&& length((my$dummy='')& $value)&& 0 + $value eq $value)? ($value!=$value ? ($value eq (9**9**9*0)? '(9**9**9*0)' : '(-(9**9**9*0))'): $value==9**9**9 ? '(9**9**9)' : $value==-9**9**9 ? '(-9**9**9)' : $value==0 ? (sprintf('%g',$value)eq '-0' ? '-0.0' : '0',): $value !~ /[e.]/i ? ($value > 0 ? (sprintf '%u',$value): (sprintf '%d',$value)): do {my$float=$value;my$max_factor=int(log(abs($value))/ log(2))- _NVMANTBITS;my$ex_sign=$max_factor > 0 ? 1 : -1;FACTOR: for my$ex (0 .. abs($max_factor)){my$num=$value / 2**($ex_sign * $ex);for my$precision (_FLOAT_PRECISION .. _FLOAT_PRECISION+2){my$formatted=sprintf '%.'.$precision.'g',$num;$float=$formatted if$ex==0;if ($formatted==$num){if ($ex){$float =$formatted .($ex_sign==1 ? '*' : '/').($ex > _NVMANTBITS ? "2**$ex" : sprintf('%u',2**$ex))}last FACTOR}}if (_HAVE_HEX_FLOAT){$float=sprintf '%a',$value;last FACTOR}}"$float"}):!length($value)&& length((my$dummy2='')& $value)? '(!1)' : _BAD_BACKSLASH_ESCAPE && _HAVE_IS_UTF8 && utf8::is_utf8($value)? do {$value =~ s/(["\$\@\\[:cntrl:]]|[^\x00-\x7f])/
        $escape{$1} || sprintf('\x{%x}', ord($1))
      /ge;qq["$value"]}: _HAVE_PERLSTRING ? B::perlstring($value): qq["\Q$value\E"]}sub sanitize_identifier {my$name=shift;$name =~ s/([_\W])/sprintf('_%x', ord($1))/ge;$name}sub capture_unroll {my ($from,$captures,$indent)=@_;join('',map {/^([\@\%\$])/ or croak "capture key should start with \@, \% or \$: $_";(' ' x $indent).qq{my ${_} = ${1}{${from}->{${\quotify $_}}};\n}}keys %$captures)}sub inlinify {my ($code,$args,$extra,$local)=@_;$args='()' if!defined$args;my$do='do { '.($extra||'');if ($code =~ s/^(\s*package\s+([a-zA-Z0-9:]+);)//){$do .= $1}if ($code =~ s{
      \A((?:\#\ BEGIN\ quote_sub\ PRELUDE\n.*?\#\ END\ quote_sub\ PRELUDE\n)?\s*)
      (^\s*) my \s* \(([^)]+)\) \s* = \s* \@_;
    }{}xms){my ($pre,$indent,$code_args)=($1,$2,$3);$do .= $pre;if ($code_args ne $args){$do .= $indent .'my ('.$code_args.') = ('.$args.'); '}}elsif ($local || $args ne '@_'){$do .= ($local ? 'local ' : '').'@_ = ('.$args.'); '}$do.$code.' }'}sub quote_sub {my$options=(ref($_[-1])eq 'HASH' and ref($_[-2])eq 'HASH')? pop : {};my$captures=ref($_[-1])eq 'HASH' ? pop : undef;undef($captures)if$captures &&!keys %$captures;my$code=pop;my$name=$_[0];if ($name){my$subname=$name;my$package=$subname =~ s/(.*)::// ? $1 : caller;$name=join '::',$package,$subname;croak qq{package name "$package" too long!} if length$package > 252;croak qq{package name "$package" is not valid!} unless$package =~ /^[^\d\W]\w*(?:::\w+)*$/;croak qq{sub name "$subname" too long!} if length$subname > 252;croak qq{sub name "$subname" is not valid!} unless$subname =~ /^[^\d\W]\w*$/}my@caller=caller(0);my ($attributes,$file,$line)=@{$options}{qw(attributes file line)};if ($attributes){/\A\w+(?:\(.*\))?\z/s || croak "invalid attribute $_" for @$attributes}my$quoted_info={name=>$name,code=>$code,captures=>$captures,package=>(exists$options->{package}? $options->{package}: $caller[0]),hints=>(exists$options->{hints}? $options->{hints}: $caller[8]),warning_bits=>(exists$options->{warning_bits}? $options->{warning_bits}: $caller[9]),hintshash=>(exists$options->{hintshash}? $options->{hintshash}: $caller[10]),($attributes ? (attributes=>$attributes): ()),($file ? (file=>$file): ()),($line ? (line=>$line): ()),};my$unquoted;weaken($quoted_info->{unquoted}=\$unquoted);if ($options->{no_defer}){my$fake=\my$var;local$QUOTED{$fake}=$quoted_info;my$sub=unquote_sub($fake);Sub::Defer::_install_coderef($name,$sub)if$name &&!$options->{no_install};return$sub}else {my$deferred=defer_sub(($options->{no_install}? undef : $name),sub {$unquoted if 0;unquote_sub($quoted_info->{deferred})},{($attributes ? (attributes=>$attributes): ()),($name ? (): (package=>$quoted_info->{package})),},);weaken($quoted_info->{deferred}=$deferred);weaken($QUOTED{$deferred}=$quoted_info);return$deferred}}sub _context {my$info=shift;$info->{context}||= do {my ($package,$hints,$warning_bits,$hintshash,$file,$line)=@{$info}{qw(package hints warning_bits hintshash file line)};$line ||= 1 if$file;my$line_mark='';if ($line){$line_mark="#line ".($line-1);if ($file){$line_mark .= qq{ "$file"}}$line_mark .= "\n"}$info->{context}="# BEGIN quote_sub PRELUDE\n" ."package $package;\n" ."BEGIN {\n" ."  \$^H = ".quotify($hints).";\n" ."  \${^WARNING_BITS} = ".quotify($warning_bits).";\n" ."  \%^H = (\n" .join('',map "    ".quotify($_)." => ".quotify($hintshash->{$_}).",\n",grep!(ref$hintshash->{$_}&& $hintshash->{$_}=~ /\A(?:\w+(?:::\w+)*=)?[A-Z]+\(0x[[0-9a-fA-F]+\)\z/),keys %$hintshash)."  );\n" ."}\n" .$line_mark ."# END quote_sub PRELUDE\n"}}sub quoted_from_sub {my ($sub)=@_;my$quoted_info=$QUOTED{$sub||''}or return undef;my ($name,$code,$captures,$unquoted,$deferred)=@{$quoted_info}{qw(name code captures unquoted deferred)};$code=_context($quoted_info).$code;$unquoted &&= $$unquoted;if (($deferred && $deferred eq $sub)|| ($unquoted && $unquoted eq $sub)){return [$name,$code,$captures,$unquoted,$deferred ]}return undef}sub unquote_sub {my ($sub)=@_;my$quoted_info=$QUOTED{$sub}or return undef;my$unquoted=$quoted_info->{unquoted};unless ($unquoted && $$unquoted){my ($name,$code,$captures,$package,$attributes)=@{$quoted_info}{qw(name code captures package attributes)};($package,$name)=$name =~ /(.*)::(.*)/ if$name;my%captures=$captures ? %$captures : ();$captures{'$_UNQUOTED'}=\$unquoted;$captures{'$_QUOTED'}=\$quoted_info;my$make_sub ="{\n" .capture_unroll("\$_[1]",\%captures,2)."  package ${package};\n" .($name ? "  no warnings 'closure';\n  sub ${name} " : "  \$\$_UNQUOTED = sub ").($attributes ? join('',map ":$_ ",@$attributes): '')."{\n" ."  (\$_QUOTED,\$_UNQUOTED) if 0;\n" ._context($quoted_info).$code ."  }".($name ? "\n  \$\$_UNQUOTED = \\&${name}" : '').";\n" ."}\n" ."1;\n";if (my$debug=$ENV{SUB_QUOTE_DEBUG}){if ($debug =~ m{^([^\W\d]\w*(?:::\w+)*(?:::)?)$}){my$filter=$1;my$match =$filter =~ /::$/ ? $package.'::' : $filter =~ /::/ ? $package.'::'.($name||'__ANON__'): ($name||'__ANON__');warn$make_sub if$match eq $filter}elsif ($debug =~ m{\A/(.*)/\z}s){my$filter=$1;warn$make_sub if$code =~ $filter}else {warn$make_sub}}{no strict 'refs';local *{"${package}::${name}"}if$name;my ($success,$e);{local $@;$success=_clean_eval($make_sub,\%captures);$e=$@}unless ($success){my$space=length($make_sub =~ tr/\n//);my$line=0;$make_sub =~ s/^/sprintf "%${space}d: ", ++$line/emg;croak "Eval went very, very wrong:\n\n${make_sub}\n\n$e"}weaken($QUOTED{$$unquoted}=$quoted_info)}}$$unquoted}sub qsub ($) {goto&quote_sub}sub CLONE {my@quoted=map {defined $_ ? ($_->{unquoted}&& ${$_->{unquoted}}? (${$_->{unquoted}}=>$_): (),$_->{deferred}? ($_->{deferred}=>$_): (),): ()}values%QUOTED;%QUOTED=@quoted;weaken($_)for values%QUOTED}1;
SUB_QUOTE

$fatpacked{"Syntax/Construct.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'SYNTAX_CONSTRUCT';
  package Syntax::Construct;use 5.006002;use strict;use warnings;our$VERSION='1.018';my%introduces=('5.032'=>[qw[unicode13.0 chained-comparisons unicode-identifier-status unicode-name-property]],'5.030'=>[qw[unicode12.1 uniprop_wildcards qr'N turkic-casing]],'5.028'=>[qw[delete% unicode10.0 state@=]],'5.026'=>[qw[<<~ /xx ^CAPTURE unicode9.0 unicode-scx]],'5.024'=>[qw[unicode8.0 \b{lb} sprintf-reorder]],'5.022'=>[qw[<<>> \b{} /n unicode7.0 attr-const fileno-dir ()x= hexfloat chr-inf empty-slice /x-unicode]],'5.020'=>[qw[attr-prototype drand48 %slice unicode6.3 \p{Unicode} utf8-locale s-utf8-delimiters]],'5.018'=>[qw[computed-labels while-each]],'5.014'=>[qw[?^ /r /d /l /u /a auto-deref ^GLOBAL_PHASE \o package-block srand-return prototype+]],'5.012'=>[qw[package-version ... each-array keys-array values-array delete-local length-undef \N while-readdir]],'5.010'=>[qw[// ?PARNO ?<> ?| quant+ regex-verbs \K \R \v \h \gN readline() stack-file-test recursive-sort /p lexical-$_]],'5.008001'=>[qw[s-utf8-delimiters-hack]],old=>[qw[?? for-qw @_=split]],);my%removed=('auto-deref'=>'5.024','lexical-$_'=>'5.024','??'=>'5.022','s-utf8-delimiters-hack'=>'5.020','for-qw'=>'5.018','@_=split'=>'5.012',);my%alias=('split-populates-@_'=>'@_=split','\H'=>'\h','\V'=>'\v','defined-or'=>'//','lexical-default-variable'=>'lexical-$_','readline-argv'=>'readline()','regex-generic-linebreak'=>'\R','regex-horizontal-whitespace'=>'\h','regex-keep-left'=>'\K','regex-named-capture-group'=>'?<>','regex-possessive-quantifier'=>'quant+','regex-possessive-match'=>'quant+','regex-preserve-match-captures'=>'/p','regex-recursive-subpattern'=>'?PARNO','regex-relative-backreference'=>'\gN','regex-reset-branch'=>'?|','regex-vertical-whitespace'=>'\v','statement-ellipsis'=>'...','yada-yada'=>'...','triple-dot'=>'...','regex-non-newline'=>'\N','non-destructive-subst'=>'/r','non-destructive-substitution'=>'/r','regex-restrict-ascii-range'=>'/a','regex-unicode-strings'=>'/u','regex-use-default-modifiers'=>'?^','regex-compile-as-default'=>'/d','regex-compile-as-locale'=>'/l','regex-compile-as-unicode-strings'=>'/u','global-phase'=>'^GLOBAL_PHASE','octal-escape'=>'\o','hash-slice'=>'%slice','attribute-prototype'=>'attr-prototype','regex-property-unicode'=>'\p{Unicode}','wide-char-delimiters'=>'s-utf8-delimiters','unicode-6.3'=>'unicode6.3','double-diamond'=>'<<>>','operator-double-diamond'=>'<<>>','regex-non-capturing'=>'/n','\b{gcb}'=>'\b{}','\b{wb}'=>'\b{}','\b{sb}'=>'\b{}','regex-unicode-boundary'=>'\b{}','regex-unicode-grapheme-cluster-boundary'=>'\b{}','regex-unicode-word-boundary'=>'\b{}','regex-unicode-sentence-boundary'=>'\b{}','attribute-const'=>'attr-const','list-repetition-assignment'=>'()x=','hexadecimal-floating-numbers'=>'hexfloat','pack-inf'=>'chr-inf','regex-x-unicode'=>'/x-unicode','regex-x-handles-unicode'=>'/x-unicode','unicode-7.0'=>'unicode7.0','unicode-8.0'=>'unicode8.0','regex-unicode-line-break-boundary'=>'\b{lb}','printf-precision-argument-reorder'=>'sprintf-reorder','sprintf-precision-argument-reorder'=>'sprintf-reorder','unicode-9.0'=>'unicode9.0','heredoc-indent'=>'<<~','regex-xx'=>'/xx','capture-variable'=>'^CAPTURE','hash-delete-slice'=>'delete%','unicode-10.0'=>'unicode10.0','state-array'=>'state@=','state-hash'=>'state@=','list-context-state'=>'state@=','named-char-in-single-quoted-regex'=>"qr'N",'unicode-12.1'=>'unicode12.1','unicode-13.0'=>'unicode13.0','unicode-identifier-type'=>'unicode-identifier-status',);my%_introduced=map {my$version=$_;map {$_=>$version}@{$introduces{$version}}}keys%introduces;my%introduced=%_introduced;delete@introduced{@{$introduces{old}}};sub _hook {{drand48=>sub {require Config;warn "Unknown rand implementation at ",_position(1),".\n" unless 'Perl_drand48' eq $Config::Config{randfunc}},'turkic-casing'=>sub {eval {use locale;require POSIX;POSIX::setlocale(POSIX::LC_ALL(),'tr_TR.UTF-8');lc 'I' ne 'i'}or die 'Turkic locale casing not working at ' ._position(1)."\.\n"},}}sub removed {my$construct=shift;return$construct ? $removed{$construct}|| $alias{$construct}&& $removed{$alias{$construct}}: keys%removed}sub introduced {my$construct=shift;return$construct ? $introduced{$construct}|| $alias{$construct}&& $introduced{$alias{$construct}}: keys%introduced}sub _position {join ' line ',(caller(1 +!!shift))[1,2]}sub import {shift;my$min_version=0;my$max_version=6;my ($constr,$d_constr);my@actions;for my$name (@_){local $_=exists$alias{$name}? $alias{$name}: $name;if ($introduced{$_}){($min_version,$constr)=($introduced{$_},$name)if$introduced{$_}gt $min_version}elsif (!$removed{$_}){die "Unknown construct `$name' at ",_position(),".\n"}if ($removed{$_}){($max_version,$d_constr)=($removed{$_},$name)if$removed{$_}lt $max_version}my$action=_hook()->{$_};push@actions,$action if$action}die 'Empty construct list at ',_position(),".\n" unless @_;my$nearest_stable=(my$is_stable=$] =~ /^[0-5]\.[0-9][0-9][02468]/)? $] : do {my ($major,$minor)=$] =~ /^([0-5])\.([0-9][0-9][13579])/;++$minor;"$major.$minor"};warn "Faking version $nearest_stable to test removed constructs.\n" unless$is_stable;die "$d_constr removed in $max_version at ",_position(),".\n" if$max_version le $nearest_stable;die "Unsupported construct $constr at ",_position(),sprintf " (Perl %.3f needed)\n",$min_version unless$min_version le $];$_->()for@actions}sub _is_old_empty {@{$introduces{old}}? 0 : 1}__PACKAGE__
SYNTAX_CONSTRUCT

$fatpacked{"Try/Tiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TRY_TINY';
  package Try::Tiny;use 5.006;our$VERSION='0.30';use strict;use warnings;use Exporter 5.57 'import';our@EXPORT=our@EXPORT_OK=qw(try catch finally);use Carp;$Carp::Internal{+__PACKAGE__}++;BEGIN {my$su=$INC{'Sub/Util.pm'}&& defined&Sub::Util::set_subname;my$sn=$INC{'Sub/Name.pm'}&& eval {Sub::Name->VERSION(0.08)};unless ($su || $sn){$su=eval {require Sub::Util}&& defined&Sub::Util::set_subname;unless ($su){$sn=eval {require Sub::Name;Sub::Name->VERSION(0.08)}}}*_subname=$su ? \&Sub::Util::set_subname : $sn ? \&Sub::Name::subname : sub {$_[1]};*_HAS_SUBNAME=($su || $sn)? sub(){1}: sub(){0}}my%_finally_guards;sub try (&;@) {my ($try,@code_refs)=@_;my$wantarray=wantarray;my ($catch,@finally)=();for my$code_ref (@code_refs){if (ref($code_ref)eq 'Try::Tiny::Catch'){croak 'A try() may not be followed by multiple catch() blocks' if$catch;$catch=${$code_ref}}elsif (ref($code_ref)eq 'Try::Tiny::Finally'){push@finally,${$code_ref}}else {croak('try() encountered an unexpected argument (' .(defined$code_ref ? $code_ref : 'undef').') - perhaps a missing semi-colon before or')}}_subname(caller().'::try {...} '=>$try)if _HAS_SUBNAME;local$_finally_guards{guards}=[map {Try::Tiny::ScopeGuard->_new($_)}@finally ];my$prev_error=$@;my (@ret,$error);my$failed=not eval {$@=$prev_error;if ($wantarray){@ret=$try->()}elsif (defined$wantarray){$ret[0]=$try->()}else {$try->()};return 1};$error=$@;$@=$prev_error;if ($failed){push @$_,$error for @{$_finally_guards{guards}};if ($catch){for ($error){return$catch->($error)}}return}else {return$wantarray ? @ret : $ret[0]}}sub catch (&;@) {my ($block,@rest)=@_;croak 'Useless bare catch()' unless wantarray;_subname(caller().'::catch {...} '=>$block)if _HAS_SUBNAME;return (bless(\$block,'Try::Tiny::Catch'),@rest,)}sub finally (&;@) {my ($block,@rest)=@_;croak 'Useless bare finally()' unless wantarray;_subname(caller().'::finally {...} '=>$block)if _HAS_SUBNAME;return (bless(\$block,'Try::Tiny::Finally'),@rest,)}{package Try::Tiny::ScopeGuard;use constant UNSTABLE_DOLLARAT=>("$]" < '5.013002')? 1 : 0;sub _new {shift;bless [@_ ]}sub DESTROY {my ($code,@args)=@{$_[0]};local $@ if UNSTABLE_DOLLARAT;eval {$code->(@args);1}or do {warn "Execution of finally() block $code resulted in an exception, which " .'*CAN NOT BE PROPAGATED* due to fundamental limitations of Perl. ' .'Your program will continue as if this event never took place. ' ."Original exception text follows:\n\n" .(defined $@ ? $@ : '$@ left undefined...')."\n" }}}__PACKAGE__ 
TRY_TINY

$fatpacked{"namespace/clean.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'NAMESPACE_CLEAN';
  package namespace::clean;use warnings;use strict;our$VERSION='0.27';$VERSION=eval$VERSION if$VERSION =~ /_/;our$STORAGE_VAR='__NAMESPACE_CLEAN_STORAGE';use B::Hooks::EndOfScope 'on_scope_end';BEGIN {my$provider;if ("$]" < 5.008007){require Package::Stash::PP;$provider='Package::Stash::PP'}else {require Package::Stash;$provider='Package::Stash'}eval <<"EOS" or die $@}use namespace::clean::_Util qw(DEBUGGER_NEEDS_CV_RENAME DEBUGGER_NEEDS_CV_PIVOT);my$RemoveSubs=sub {my$cleanee=shift;my$store=shift;my$cleanee_stash=stash_for($cleanee);my$deleted_stash;SYMBOL: for my$f (@_){next SYMBOL if$store->{exclude}{$f };my$sub=$cleanee_stash->get_symbol("&$f")or next SYMBOL;my$need_debugger_fixup=(DEBUGGER_NEEDS_CV_RENAME or DEBUGGER_NEEDS_CV_PIVOT)&& $^P & 0x01 && defined&DB::sub && ref(my$globref=\$cleanee_stash->namespace->{$f})eq 'GLOB' && ($deleted_stash ||= stash_for("namespace::clean::deleted::$cleanee"));if (DEBUGGER_NEEDS_CV_RENAME and $need_debugger_fixup){namespace::clean::_Util::get_subname($sub)eq ($cleanee_stash->name ."::$f")and $deleted_stash->add_symbol("&$f",namespace::clean::_Util::set_subname($deleted_stash->name ."::$f",$sub),)}elsif (DEBUGGER_NEEDS_CV_PIVOT and $need_debugger_fixup){$deleted_stash->add_symbol("&$f",$sub)}my@symbols=map {my$name=$_ .$f;my$def=$cleanee_stash->get_symbol($name);defined($def)? [$name,$def]: ()}'$','@','%','';$cleanee_stash->remove_glob($f);DEBUGGER_NEEDS_CV_PIVOT and $need_debugger_fixup and *$globref=$deleted_stash->namespace->{$f};$cleanee_stash->add_symbol(@$_)for@symbols}};sub clean_subroutines {my ($nc,$cleanee,@subs)=@_;$RemoveSubs->($cleanee,{},@subs)}sub import {my ($pragma,@args)=@_;my (%args,$is_explicit);ARG: while (@args){if ($args[0]=~ /^\-/){my$key=shift@args;my$value=shift@args;$args{$key }=$value}else {$is_explicit++;last ARG}}my$cleanee=exists$args{-cleanee }? $args{-cleanee }: scalar caller;if ($is_explicit){on_scope_end {$RemoveSubs->($cleanee,{},@args)}}else {my$functions=$pragma->get_functions($cleanee);my$store=$pragma->get_class_store($cleanee);my$stash=stash_for($cleanee);my%except=map {($_=>1)}($args{-except }? (ref$args{-except }eq 'ARRAY' ? @{$args{-except }}: $args{-except }): ());for my$f (keys %$functions){next if$except{$f };next unless$stash->has_symbol("&$f");$store->{remove}{$f }=1}on_scope_end {$RemoveSubs->($cleanee,$store,keys %{$store->{remove}})};return 1}}sub unimport {my ($pragma,%args)=@_;my$cleanee=exists$args{-cleanee }? $args{-cleanee }: scalar caller;my$functions=$pragma->get_functions($cleanee);my$store=$pragma->get_class_store($cleanee);for my$f (keys %$functions){next if$store->{remove}{$f }or $store->{exclude}{$f };$store->{exclude}{$f }=1}return 1}sub get_class_store {my ($pragma,$class)=@_;my$stash=stash_for($class);my$var="%$STORAGE_VAR";$stash->add_symbol($var,{})unless$stash->has_symbol($var);return$stash->get_symbol($var)}sub get_functions {my ($pragma,$class)=@_;my$stash=stash_for($class);return {map {$_=>$stash->get_symbol("&$_")}$stash->list_all_symbols('CODE')}}'Danger! Laws of Thermodynamics may not apply.' 
  
  sub stash_for (\$) {
    $provider->new(\$_[0]);
  }
  
  1;
  
  EOS
NAMESPACE_CLEAN

$fatpacked{"namespace/clean/_Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'NAMESPACE_CLEAN__UTIL';
  package namespace::clean::_Util;use warnings;use strict;use base 'Exporter';our@EXPORT_OK=qw(DEBUGGER_NEEDS_CV_RENAME DEBUGGER_NEEDS_CV_PIVOT);use constant DEBUGGER_NEEDS_CV_RENAME=>(("$]" > 5.008_008)and ("$]" < 5.013_006));use constant DEBUGGER_NEEDS_CV_PIVOT=>((!DEBUGGER_NEEDS_CV_RENAME)and ("$]" < 5.015_005));BEGIN {DEBUGGER_NEEDS_CV_RENAME and (eval <<'EOS' or die $@)}1;
  {
    my( $sub_name_loaded, $sub_util_loaded );
  
    sub _namer_load_error {
      return '' if $sub_util_loaded or $sub_name_loaded;
  
      # if S::N is loaded first *and* so is B - then go with that, otherwise
      # prefer Sub::Util as S::U will provide a faster get_subname and will
      # not need further require() calls
      # this is rather arbitrary but remember this code exists only perls
      # between 5.8.9 ~ 5.13.5
  
      # when changing version also change in Makefile.PL
      my $sn_ver = 0.04;
  
      local $@;
      my $err = '';
  
      (
        ! (
          $INC{"B.pm"}
            and
          $INC{"Sub/Name.pm"}
            and
          eval { Sub::Name->VERSION($sn_ver) }
        )
          and
        eval { require Sub::Util }
          and
        # see https://github.com/moose/Moo/commit/dafa5118
        defined &Sub::Util::set_subname
          and
        $sub_util_loaded = 1
      )
        or
      (
        eval { require Sub::Name and Sub::Name->VERSION($sn_ver) }
          and
        $sub_name_loaded = 1
      )
        or
      $err = "When running under -d on this perl $], namespace::clean requires either Sub::Name $sn_ver or Sub::Util to be installed"
      ;
  
      $err;
    }
  
    sub set_subname {
      if( my $err = _namer_load_error() ) {
        die $err;
      }
      elsif( $sub_name_loaded ) {
        &Sub::Name::subname;
      }
      elsif( $sub_util_loaded ) {
        &Sub::Util::set_subname;
      }
      else {
        die "How the fuck did we get here? Read source and debug please!";
      }
    }
  
    sub get_subname {
      if(
        _namer_load_error()
          or
        ! $sub_util_loaded
      ) {
        require B;
        my $gv = B::svref_2object( $_[0] )->GV;
        join '::', $gv->STASH->NAME, $gv->NAME;
      }
      else {
        &Sub::Util::subname;
      }
    }
  }
  1;
  EOS
NAMESPACE_CLEAN__UTIL

$fatpacked{"oo.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'OO';
  package oo;use Moo::_strictures;use Moo::_Utils qw(_load_module);sub moo {print <<'EOMOO';exit 0}BEGIN {my$package;sub import {moo()if $0 eq '-';$package=$_[1]|| 'Class';if ($package =~ /^\+/){$package =~ s/^\+//;_load_module($package)}}use Filter::Simple sub {s/^/package $package;\nuse Moo;\n/}}1;
   ______
  < Moo! >
   ------
          \   ^__^
           \  (oo)\_______
              (__)\       )\/\
                  ||----w |
                  ||     ||
  EOMOO
OO

s/^  //mg for values %fatpacked;

my $class = 'FatPacked::'.(0+\%fatpacked);
no strict 'refs';
*{"${class}::files"} = sub { keys %{$_[0]} };

if ($] < 5.008) {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      my $pos = 0;
      my $last = length $fat;
      return (sub {
        return 0 if $pos == $last;
        my $next = (1 + index $fat, "\n", $pos) || $last;
        $_ .= substr $fat, $pos, $next - $pos;
        $pos = $next;
        return 1;
      });
    }
  };
}

else {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      open my $fh, '<', \$fat
        or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
      return $fh;
    }
    return;
  };
}

unshift @INC, bless \%fatpacked, $class;
  } # END OF FATPACK CODE


# ABSTRACT: create pkg-config metadata files
# PODNAME: mkpkgconfig

use strict;
use warnings;

use Getopt::Long::Descriptive;
use File::Basename;
use File::Spec::Functions;
use Carp;

our $VERSION = 'v2.0.1';

use constant {
    ALL_VARS       => 1,
    REQUESTED_VARS => 2,
    NEEDED_VARS    => 3,
};

our %VarsAuto = (
    exec_prefix => '${prefix}',

    bindir  => '${exec_prefix}/bin',
    sbindir => '${exec_prefix}/sbin',

    libdir     => '${exec_prefix}/lib',
    pkg_libdir => '${libdir}/${package}',

    libexecdir     => '${exec_prefix}/libexec',
    pkg_libexecdir => '${libexecdir}/${package}',

    datarootdir => '${prefix}/share',

    datadir     => '${datarootdir}',
    pkg_datadir => '${datadir}/${package}',

    sysconfdir     => '${prefix}/etc',
    pkg_sysconfdir => '${sysconfdir}/${package}',

    localstatedir     => '${prefix}/var',
    pkg_localstatedir => '${localstatedir}/${package}',

    includedir     => '${prefix}/include',
    pkg_includedir => '${includedir}/${package}',

    docdir  => '${datarootdir}/doc/${package}',
    infodir => '${datarootdir}/info',
    mandir  => '${datarootdir}/man',
);

my %KeywordOptions = (
    Name               => { required => 1 },
    Description        => { required => 1 },
    Requires           => { required => 0 },
    Libs               => { required => 0 },
    Conflicts          => { required => 0 },
    Cflags             => { required => 0 },
    URL                => { required => 0 },
);




main( @ARGV ) unless caller;

sub main {

    local @ARGV = @_;

    # save original options for output;
    my @sARGV = @ARGV;
    my $opt   = parse_opts();

    require App::mkpkgconfig::PkgConfig;

    my $conf = App::mkpkgconfig::PkgConfig->new;

    # add standard variables
    $conf->add_variable( prefix  => $opt->prefix )  if defined $opt->prefix;
    $conf->add_variable( package => $opt->package ) if defined $opt->package;
    $conf->add_variable( version => $opt->modversion );

    # add auto generated variables
    $conf->add_variables( \%VarsAuto )
      if defined $opt->auto;

    # override from user
    $conf->add_variables( $opt->var );

    # add standard keywords
    $conf->add_keyword( Name        => $opt->name );
    $conf->add_keyword( Description => $opt->description );
    $conf->add_keyword( Version     => '${version}' );
    for my $kwd ( qw(  Requires Libs Conflicts Cflags ) ) {
        my $mth = lc $kwd;
        $conf->add_keyword( $kwd => $opt->$mth )
          if defined $opt->$mth;
    }

    # override from user
    $conf->add_keywords( $opt->kwd );

    #<<< no tidy
    my @vars_needed =
      # output all variables, used or not
        $opt->usevars == ALL_VARS       ? $conf->variables
      # output only requested  + keyword dependencies
      : $opt->usevars == REQUESTED_VARS ? ( keys %{ $opt->var } , @{ $opt->auto // [] } )
      # only variables actually used by keywords
      : $opt->usevars == NEEDED_VARS    ? ()
      :                                   die( "unknown filter for variables: ", $opt->usevars, "\n" );
    #>>>

    $conf->write(
        $opt->output,
        write    => ( $opt->usevars == ALL_VARS ? 'all' : 'req' ),
        vars     => \@vars_needed,
        comments => [
            "This file was created by $0 ($VERSION) via",
            join( ' ', $0, @sARGV ) ] );
}


sub parse_opts {

    my %Map_usevars = (
        'all'       => ALL_VARS,
        'requested' => REQUESTED_VARS,
        'req'       => REQUESTED_VARS,
        'needed'    => NEEDED_VARS
    );

    my ( $opt, $usage ) = Getopt::Long::Descriptive::describe_options(
        "%o <options>",
        [ 'output|o=s', "output [stdout]" ],
        [
            'usevars|u:s',
            "which variables to output",
            {
                default   => { reverse %Map_usevars }->{ +NEEDED_VARS },
                callbacks => {
                    'valid output variables' => sub {
                        return 1 if defined $Map_usevars{ $_[0] };
                        die(
                            "$_[0] isn't one of 'all', 'req', 'requested', or 'used'\n"
                        );
                    }
                } }
        ],
        [ 'auto:s@', "generate a default set of variables" ],
        [
            'list-auto',
            "output a list of variables generated by the --auto option",
            { shortcircuit => 1 }
        ],

        [],
        ['Variables:'],
        [ 'var|variable=s%', 'define variables', { default => {} } ],
        [ 'prefix=s',        "'prefix' variable", ],
        [ 'package=s',       "'package' variable", ],
        [
            'modversion|modversion=s',
            '"version" variable and Version keyword)',
            { required => 1 }
        ],

        [],
        ['Keywords:'],

        [ 'kwd|keyword=s%', 'define keywords', { default => {} } ],

        (
            map { [
                    qq(\u$_|\l$_=s),
                    qq("\u$_" keyword),
                    { (
                            $KeywordOptions{$_}{required}
                              // 0 ? ( required => 1 ) : ()
                        ),
                    },
                ]
              }
              keys %KeywordOptions
        ),

        [],
        ['Miscellaneous::'],

        [ 'version|v', 'output version and exit', { shortcircuit => 1 } ],

        [
            'help|h',
            'output short help message and exit',
            { shortcircuit => 1 }
        ],

        [
            'manual|m',
            'output full manual page and exit',
            { shortcircuit => 1 }
        ],
    );

    print( $usage->text ), exit if $opt->help;
    print( $VERSION, "\n" ), exit if $opt->version;
    if ( $opt->manual ) {
        require Pod::Usage;
        Pod::Usage::pod2usage(
            { -exitval => 0, -verbose => 2, -output => \*STDOUT } );
    }

    if ( $opt->list_auto ) {
        require List::Util;
        my $length = List::Util::max( map { length( $_ ) } keys %VarsAuto );
        printf( "%-*s = %s\n", $length, $_, $VarsAuto{$_} )
          for sort keys %VarsAuto;
        exit;
    }

    if ( defined $opt->auto ) {
        my @auto = map { split /,/ } @{ $opt->auto };
        $opt->{auto} = \@auto;
    }

    $opt->{usevars} = $Map_usevars{ $opt->usevars };

    return $opt;
}



1;

#
# This file is part of App-mkpkgconfig
#
# This software is Copyright (c) 2020 by Smithsonian Astrophysical Observatory.
#
# This is free software, licensed under:
#
#   The GNU General Public License, Version 3, June 2007
#

__END__

=pod

=for :stopwords Diab Jerius Smithsonian Astrophysical Observatory

=head1 NAME

mkpkgconfig - create pkg-config metadata files

=head1 VERSION

version v2.0.1

=head1 SYNOPSIS

mkpkgconfig I<options>

=head1 DESCRIPTION

B<mkpkgconfig> creates a B<pkg-config> metadata (C<.pc>) file.
B<pkg-config> variables and keywords are defined on the command line,
variable dependencies are validated, and the configuration file is output.
"Standard" variables (such as C<$libdir>, C<$datadir>) may be automatically
created, and only variables which are used are output.

=head2 Variables and Keywords

B<pkg-config> distinguishes between I<variables> and I<keywords>. Values for both may include
interpolated variables, as in C<< Cflags: -I ${include} >>.

Some commonly used variables have dedicated command line options:

  --prefix     : base prefix for paths
  --package    : filesystem compatible package name
  --modversion : package version

(C<--modversion> sets the I<version> variable; the C<--version> flag will output the version of C<mkpkgconfig>).

C<--modversion> is required.  C<--prefix> and C<--package> may be
required if a keyword requires them or C<--auto> is set and
auto-generated variables require it.

Common keywords also have dedicated options:

  --Name
  --Conflicts
  --Description
  --Requires
  --Libs
  --Cflags
  --URL

The C<--Name> and C<--Description> options are required. The
C<Version> keyword is automatically set to C<< ${version} >>. It is
not possible to set it directly from the command line.

Other variables and keywords may be specified via the C<--var> and
C<--kwd> options, respectively:

  --var name=value
  --kwd name=value

which may be used more than once.

=head2 Automatically Generated Variables

C<mkpkgconfig> can automatically generate a number of "standard"
variables, such as I<bindir>, I<libdir>, etc, based upon the I<prefix>
variable.  Use the L</--list-auto> option to output a list of these
variables.

=head1 OPTIONS

=head2 General Options

=over

=item --output

Where the configuration file is to be written.  It defaults to the
standard output stream.

=item --usevars C<all>|C<requested>|C<needed>

Which variables should be output.  It defaults to C<needed>.

=over

=item C<all>

output all variables, needed or not, including automatically generated
ones if C<< --auto >> was specified;

=item C<requested>

output only requested variables (via-C<< -var variable=value >> or C<<
--auto=variable,... >>) and keyword dependencies;

=item C<needed>

output only those variables actually used by keywords

=back

=back

=head2 Variables

=over

=item C<--var> I<name>=I<value>

Set the variable named I<name> to I<value>.

=item C<--prefix> I<value>

Set the C<prefix> variable.

=item C<--package> I<value>

Set the C<package> variable

=item C<--modversion> I<value>

Set the C<version> value

=item C<--auto>

=item C<--auto> I<list of variables>

Generate a set of variables.  Use C<--list-auto> to see what is generated.

If passed a list of variable names, those will be output if C<--usevars> is set to C<requested>.

Individual variables may be overriden using C<--var>.

=item C<--list-auto>

Output a list of the automatically generated keywords and exit.

=back

=head3 Keywords

=over

=item C<--kwd> I<name>=I<value>

Set the keyword named I<name> to I<value>.

=item C<--Name>  I<value>

=item C<--name> I<value>

Set the I<Name> keyword.
This parameter is required.

=item C<--Description> I<value>

=item C<--description> I<value>

Set the I<Description> keyword.
This parameter is required.

=item C<--Requires> I<value>

=item C<--requires> I<value>

Set the I<Requires> keyword.

=item C<--Conflicts> I<value>

=item C<--conflicts>  I<value>

Set the I<Conflicts> keyword.

=item C<--Libs> I<value>

=item C<--libs>  I<value>

Set the I<Libs> keyword.

=item C<--Cflags> I<value>

=item C<--cflags>  I<value>

Set the I<Cflags> keyword.

=back

=head2 Miscellaneous

=over

=item --version

Output the version of B<mkpkgconfig> and exit.

=item --help

Output a short help message and exit.

=item --manual

Output the manual and exit.

=back

=head1 SUPPORT

=head2 Bugs

Please report any bugs or feature requests to bug-app-mkpkgconfig@rt.cpan.org  or through the web interface at: https://rt.cpan.org/Public/Dist/Display.html?Name=App-mkpkgconfig

=head2 Source

Source is available at

  https://gitlab.com/djerius/app-mkpkgconfig

and may be cloned from

  https://gitlab.com/djerius/app-mkpkgconfig.git

=head1 AUTHOR

Diab Jerius <djerius@cpan.org>

=head1 COPYRIGHT AND LICENSE

This software is Copyright (c) 2020 by Smithsonian Astrophysical Observatory.

This is free software, licensed under:

  The GNU General Public License, Version 3, June 2007

=cut
